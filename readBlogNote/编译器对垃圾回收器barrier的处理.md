## 摘要
这篇[文章](https://robcasloz.github.io/blog/2024/02/14/when-should-a-compiler-expand-garbage-collection-barriers.html)讨论了 Java 的 JIT 编译器 C2 在处理垃圾回收器需要的屏障指令时的一些细节。从开始的使用一种 early barrier expand 实验改成 late barrier expand （文章提出了 JEP 并在 Java24 中实现），并根据实现讨论了后者的优缺点。
### 背景
一般来说，编译器作者都认为在编译过程中尽可能的多暴露程序信息给编译器是很好的行为。目的是为了让编译器利用这些信息执行精确的分析并执行更强大的优化。但是，对于复杂的软件产品，特别是工业级编译器，总是需要考虑权衡。对于编译器来说，更多的程序信息会占用更多的编译时间并让编译器更难维护。
### 及早展开屏障指令
C2 针对垃圾回收器的屏障指令使用了 IR 。这些额外的指令插入在内存访问的周围，通知垃圾回收器关于访问的细节，比如在内存写操作前后，访问的内存位置存储的值什么。处理 GC 屏障指令的一种方式（也是大多数编译器工程师认为正确的方式）是在编译器中间表示（ IR ）中，想处理其他程序操作一样，明确统一的看待屏障操作。这么做的理由是，可以把它允许编译器可以将它的常规分析和转换机制应用到转换 GC 屏障指令为高度优化的汇编指令中。这种方式被称为 early barrier expand ，因为它在编译链开始的时候就将屏障指令转换为 IR 操作。
这一方式目前是 C2 处理 JVM 默认垃圾回收器（ G1 ）需要的屏障指令的方式。某些垃圾回收器对内存的读写都要求设置屏障指令，但是 G1 只针对写要求屏障指令，但不仅仅是屏障指令。G1 的写屏障指令由超过100个 IR 操作表示，最终大概是50个 x64 指令。由于内存写操作非常频繁，所以这会让 IR 体积增加。下面的代码是一个很简单的内存操作：
```java
void write(Foo foo,Bar bar){
    foo.f = bar;
}
```
但是它的[控制流图](https://robcasloz.github.io/blog/assets/write-barrier.png)非常大。更大的 IR 意味着更高的编译开销。文中提到的初步测试说到大约 C2 的全部执行时间的20%都是 G1 屏障指令 IR 操作。
### 延迟展开屏障指令
因此，作者在编译器处理 GC 屏障指令时选择在编译期间不再将这些指令暴露给编译器，仅仅是在代码发射时间将对应的指令“粘贴”在内存访问指令周围。这个看起来很原始的实现（叫做 late barrier expansion 延迟展开屏障指令）一个不可否认的优势是：简单。由于如此简单，他可以很方便的实现，这让作者它们初步实验中 C2 实现得到了极大的加速。
### 性能问题
可能会有一种观点，由于延迟展开屏障指令仅仅是在最终的汇编代码中“粘贴”了对应的屏障指令，而没有和应用其他部分一起被分析和优化，因此肯定会产生质量更糟糕的代码。虽然纸面上这是真的，但是将 C2 从及早转换为延迟展开后，作者没有观察到任何显著的性能下降。似乎 G1 的屏障指令没有太多的优化空间，而且即使存在效率低下的潜在负面影响，也被现代 CPU 掩盖了。
### 维护
延迟屏障指令展开模式可能缺少可维护性，因为它要求针对编译器针对目标编译平台手写实现。这在通常的情况下是一个问题，不过由于 JDK 为了字节码解释，已经包含了平台独立的 G1 屏障指令实现，作者只需要简单的修改就可以为 C2 重用它们。上述内容已经在 [JEP475](https://openjdk.org/jeps/475) 中实现，并在 Java 24 中发布。