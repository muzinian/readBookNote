## IR 设计思考
[文章](https://cr.openjdk.org/~jrose/draft/code-media.html)描述了在设计 IR 过程中需要考虑的内容。优化编译通常涉及到选择一个合适的中间表示（ Intermediate representations IR ）。这个文章讨论了常见的 IR 功能以及理想的 IR 需要的功能点。
### 需求
#### _可转换（ transformable ）_
IR 必须在单个节点，子图，以及 wholesale 上支持灵活高效的转换（ transformation ）。为了支持转换的代码实现必须清晰和简洁（必须要可单元测试的）。 IR 的设计和实现必须帮助程序员在提议的转换下检测程序语义是否保持。如果转换修改了 IR ，这种修改必须证明排除了会修改语义的副作用。
#### _局部（ Local ）_
IR 节点 B 的意义必须依赖（尽可能的依赖）于通过边（ A->B 和 B->A ）直接连接的节点意义。如果一个节点的意义某种程度上依赖于非直接的节点，那么这种耦合要么要在直接节点中完全体现，要么要被仔细的记录在文档中并在所有转换中得到尊重。
#### _统一（ Unifiled ）_
用于优化编译的 IR 套件 代表了很大范围的构造，从方法到字节码，再到简单的操作和机器原语。在 JVM 的工具链中 IR 的实现代码，概念以及词汇应该尽可能统一，允许他人可以通过依靠常见概念和符号更加快速的学习每个 IR （或者 IR 的各个层级）（这个需求不强迫或者排除单个大一统的 IR ）。
#### _多级（ Multi-level ）_
某些优化适合在或者接近源代码/字节码粒度上执行。 IR 不必须要过早的降低到理想化的 RISC -层级或者机器层级，直到在粗粒度或者源码级别的优化结束后再执行（这个需求要求 IR 套件必须多层级，不必须是单个大一统 IR ）。
#### _显式（ Explicit ）_
IR 中，因果依赖必须显式的表示和辩护。如果 IR 节点 A 执行了一个副作用，它必须能很容易的定位到被 A 节点影响到的节点 B 的边界（这允许替换 A 的转换可以找到并编辑所有受影响的节点）。
#### _可跟踪（ Tractable ）_
IR 必须允许优化逻辑要求的空间和时间在工程限制内。算法理论复杂度应该限制为整个输入代码大小的准线性复杂度。基本的节点级 IR 操作应该是节点复杂度准线性复杂度。图级别的 IR （例如计算和缓存派生的依赖或者类型）应该是图复杂度的准线性复杂度。（准线性意味着我们对于输入大小$N$总是可以期待$O(N \times polylog(N) )$。更复杂的算法复杂度，比如平方或者暴力只适用于受限的规模）。
#### _高效（ Efficient ）_ 
对于期望的优化负载，包括创建操作，转换和遍历， IR 必须实现为合理小的性能开销（每输入代码单元大小）。 IR 实现必须避免数据结构过于分散或者指针过多，避免产生过多 Java 对象或者分配速率，或者过多的方法多态。编译负载总是可以扩大（通过内联或者频繁重新编译），以吸收任何资源预算，因此更高效的优化直接促成了更普遍的优化。
#### _ Java 可表达（ Java-expressible ）_
IR 必须能用 Java 高效实现。 Java API 必须很好的文档化并且自然地使用和扩展到普通样子的 Java 代码。（这个要求原则上可以应用于其他语言，但是对于 JVM 来说很自然）
#### _可检测（ Inspectable ）_
IR 必须支持人类可读的表示。
#### _可序列化_
IR 必须要支持序列化表示，支持单元测试和实时重放。读写方法需要高度保真。二进制和文本格式都可以
### 定义
* 计算机运行代码处理数据
* 代码（ __Code__ ）定义了计算机执行的步骤以及处理的数据
* 代码还包含 __元数据（ metadata ）__，这些元数据将名字和其他元数据与基本程序关联起来
* __源代码（ Source code ）__ 由符号化文本组成，人类可以读写
* __原生代码（ Native code ）__ 由可以被硬件高效执行的二进制指令和关联上的元数据组成
* Java __类文件（ class files ）__ 包含数据定义（类），字节码和其他元数据
### 编译管道
* __编译管道（ compilation pipeline ）__ 是一步一步将源码转换成原生代码的（__编译__ 源码 __生成__ 原生代码）
* 某些 pipeline 是在代码运行前很久 __离线（ off-line ）__ 工作的，有些是跟随代码运行 __在线（ on-line ）__ 工作。比如，类文件就是 javac 离线生成的。原生代码通常由 __JIT__ 在线生成。
* 每个 pipeline 阶段（可能除了第一个）都工作于特性的 __IR__ （代码的中间表示）上
* 用于存储（比如类文件）的 IR 有序列化的表现形式。
* IR 通常是以内存中的数据结构的方式处理，无论是否是序列化的。
* pipeline 的输入输出应该是“ tappable ”，可以检视（ inspection ），记录和其他度量（因此 IR 应该支持高保真的序列化以及人类可读的表现形式）。
* pipeline 阶段必须允许灵活的组合。
  * 阶段各自必须正确，从输入到输出都保留语义。（这个属性必须能以某种方式证明，至少通过代码检查和单元测试）
  * 某些阶段只运行一次（ 解析（ parsing ），低化（ lowering ））
  * 某些阶段迭代运行直到代码“稳定”（增量内联，循环转换）。
### IR 图节点
* 所有 IR 都是由 __节点（ node ）__ 构成的图。（主要用来序列化的 IR 延伸了这个视角，但是它可以容纳它们）
* 节点代表代码中可分开且不同的部分，以及与之关联的行为
* 几个例子：
  * 总的：数据处理，内存访问，控制流（包括循环）
  * 源码节点：源代码操作符，常量，名字，声明，语句，方法，类
  * 机器节点：原始（硬件）指令，指令模版（类似宏的指令组），常量，调用点（ call site ），块或者方法边界
  * 字节码节点：类似于原生代码，但是是为了 JVM 字节码而不是硬件（包括异常控制和托管指针）。
  * 优化期间：跨平台 __理想节点（ ideal node ）__（ RISC 类型的操作），依赖控制的 __约束节点（ constraint node ）__（记录推断），__调用节点（ call node ）__（是否内联，是否常量）。
  * 效果包含：__内存节点（ memory node ）__（内存效果合并）， SSA 支持（比如 __ phi 节点 （ phi node ）__ 或者 __ lambda 节点（ lambda node ）__），__盒节点（ box node ）__
### IR 图边
* 节点`A`和`B`之间的 __边__ 表示某种直接的因果关系或者`A`和`B`之间的 __依赖（ dependency ）__。
* 在图中，我们说原因在 __上面（ upward ）__ 或者 __较早（ early ）__，它们的效果在 __下面（ downward ）__ 或者 __稍后（ later ）__。根据图生成的机器指令的最终执行相对于图来说是向下流动。
* 边的例子：
  * __控制依赖（ Control dependency ）__：在正常执行顺序中，节点`B`必须跟着节点`A`
  * __异常边（ Exception edge ）__：如果`A`抛出异常，节点`B`跟着节点`A`
  * __数据依赖（ Data dependency ）__：节点`B`要求来自节点`A`的值
  * __内存依赖（ Memory dependency ）__：节点`B`要求来自节点`A`的内存状态
  * __主宰（ Dominator ）__：节点`A`是在`B`前必要执行的最低节点
  * __后主宰（ Post-Dominator ）__：在正常执行顺序中，节点`B`是在节点`A`后必须要执行的最高节点
  * __循环成员（ Loop member ）__：节点`B`是由`A`表示的循环的成员（`A`主宰`B`，而且它们由一个环“强”连接，任何经过`B`的环也包含`A`）
  * __反依赖（ Anti-dependency ）__：在`B`发布副作用到一个重叠状态前节点`A`必须读取一个内存状态。
* 边是有向的但是逻辑上双向。如果节点`A`和`B`由类型是`E`的边关联起来且在图里`A`在`B`上面，可以写作`A -E->B`。
* 对于任意给定的边类型，实现总有倾向的遍历方向（向上或者向下），但必须提供可以按照非倾向方向的方式遍历节点边。（例如， IR 必须支持向上和向下遍历，因为某些优化技巧是从效果到原因起作用的，而其他是从原因到效果起作用的）
### 节点值
* 节点`A`的行为从运行节点的代码中产生一个或者多个部分结果的行为叫做节点的 __值__。
* 节点行为的最小例子是单个原生指令（在寄存器分配前它可能是`addl t1, t2`）。这样的节点值可能是由这个指令加载到这个指令的输出寄存器（`t1`）中的结果。
* 那个指令的输入值可以表示为连接必须在之前执行的节点和这个节点的输入边（ input edge ）（意思是，节点`A`以及`A`之前必须要执行的其他节点，这个值就作为连接`A`和其他节点的边，且这边是`A`的输入边）。
* 后面使用这个指令值的节点，将会通过这个节点的输出边（ output edge ）连接到这个节点。
### transformations
* __AST （ 抽象语法树 abstract syntax tree ）__ 是通过解析文本或者二级制产生的 IR
* AST 是一个树，内部节点只有一个入度，存在内在的解析顺序。
* 原生代码可以通过遍历 AST 直接生成。
* 最佳的原生代码是通过 __转换（ transforming ）__ 源码解析和原生代码生成之间的图获得的。
* 转换必须要保留程序语义，不过存在很多技巧。
* 基本转换包括：
  * __重排序（ reordering ）__ 一个节点（或者子图）。（它可能向上移动到主宰位置或者向下移动为理论的后主宰。数据操作符也可能为了规范表达式而重排序）
  * __分割（ splitting ）__ 一个节点（或子图）为两个或者多个节点（或子图）。（每个分割都执行原始的任务，但是针对的是受原始影响的图的一部分）
  * __合并（ merging ）__ 两个或多个节点（或子图）为一个。
  * 根据相等性 __替换（ replacing ）__ 一个节点（或者子图）。（常见例子是规范化，强度减弱，降低，内联和循环重组织）
* 转换可能是 __局部的（ local ）__，在很小的直径范围内（涉及到的节点之间的边只有几跳）的子图做修改。这样的转换相对很容易证明因此很有价值。
* 局部转换例子：
  * 常量折叠（`3+2`修改为`5`）,规范化（`(x+2)+3`改为`x+5`）,强度减弱（`x*8`改为`x<<3`）
  * 用命名常量的值替换这个常量
  * 用条件移动替换小的“钻石”（指的是控制结构）
  * 删除或者合并一个测试到已存在的测试
* 转换也可以是 __非局部的（ non-local ）__，用一个子图替换另一个子图（或者整个图）
* 非局部转换例子：
  * 从源码 __解析（ parse ）__ 为字节码， 从0开始创建新的 AST 或者图。
  * 复制整个子图（为了内联或者循环分割）。一个变种的复制是反序列化子图。
  * 从一个 IR （子图或者整个程序）类型 __降低（ lower ）__ 到另一个类型。 
  * 将理想化的 IR __匹配（ match ）__ 为可用的机器节点类型（典型的是对整个程序执行，不留下原始的内容）。 
* 大多有效的转换时不重要的，大多数重要的转换涉及到程序的热区域。
* 转换效果应该关注于那些提升会显著影响整个程序的代码区域
* 全局执行的转换要么成本低（ CCP ， GVN ）要么不可避免（解析）
* 原则上 AST 为了更适合代码生成可以转换为更优的 AST ，但是这很复杂
* 有着更少内在顺序、形式更通用的图使用起来帮助更大
### IR 设计考量
* 设计 IR 就需要定义节点和边，包括它们的各种类型和含义。
* 必须给节点和边定义 __装饰（ decoration ）__。
* IR 不能由它的元素自由组合，存在结构化的约束。
* 节点行为可以对应为源构造（ AST 节点 ），__理想化（ idealized ）__ 操作（数组范围检查），或者原生指令。
* 选择并不互斥，它们会同时存在时， __降低（ lowering ）__ 转换会将面向源码的构造转换为中间理想化构造，再转换为原生指令。
* 更高层的节点是紧实易于验证，低层级节点允许更大范围的转换。
* 装饰可以包含比如历史剖析，源代码语言类型或者源码调试信息这样的输入属性
* 装饰也可以包含衍生出来的属性，比如 __IR 类型（ IR type ）__，__寄存器分配（ register allocation ）__，__指令选择（ instruction selections ）__。
* IR 图允许 __临时衍生的（ temporarily derived ）__ 元素，就是从输入节点和边计算出来的边，节点或者装饰（这些衍生节点通常存储在为了特定的全局转换创建的附属表（ side tables ）中，或者是懒计算的，或者临时插入稍后删除）。
* 例子：
  * 一个节点的直接主宰是一个衍生的边，这个边连接到的是根据更基本的排序约束计算出来的节点（因为主宰非局部地依赖上述两个节点之间的节点的边，从来不会是单个节点的简单的独立的可编辑属性）。
  * 节点可能在一趟计算逆后序（ RPO 编号不是独立可编辑的，只能通过一趟贯穿整个程序的计算得到 ）之后被装饰上一个序列号。
  * 一个约束节点可能被创建（但是稍后被删除）从而表示一个类型约束，这个约束在整个子图中都存在。
* 节点和边包含传递了程序额外信息的装饰
* 装饰是对于节点的断言，它们和节点是不同的
### IR 类型
* __IR 特定的类型（ IR-specific types ）__ 是节点很重要的装饰（常叫做“ IR 类型”或者“类型”，和源代码或者是实现语言的类型不同）。
* 类型代表了一组关于节点（值或者其他行为）的可靠断言（相等地，类型可以看作代表一组节点可能产生的一组可能的具体值）。
* 类型和源码级别的数据类型和声明是不同的，尽管典型地它们会引用或者嵌入源码级别的数据类型和声明。
* 实现的数据类型和 IR 的类型不同，尽管它们常常会引用 IR 的类型。
* __IR 类型系统__ 是模拟了特定断言或者值集合的可能类型的形式化模式（ IR type system is a formal scheme of possible types which model specific sets of assertions or values ）。
* 不存在最大的，普遍的或者完美自然的类型系统可以用实际限制来表达。
* 下列 IR 类型是有用的：
  * 离散值，包括空和整型范围
  * 值的类型除了它的机器级基类以外是不确定的
  * 值的类型可能是无法计算或者计算出来是矛盾的
  * 引用值的类型，就是她的源码级类（加上其他离散值的指示，比如空）
* 由于给每个节点都定义一个类型有一些用处，可能存在让所有节点（包括控制流和内存效果节点）有一个可赋值的类型的需求。
### 控制流
* 节点的 __延续（ continuation ）__ 是接下来执行程序哪个部分的选择。
* 在 Java 的场景中 continuation 可能是正常也可能是 __异常（ exceptional ）__。
* 在乐观优化和慢速路径中， continuation 可能是正常也可能是 __不常见（ uncommon ）__ 的。
* 只有 continuation 和/或效果的节点可以看作有一个“空（ void ）”值，数学上是一个单元（ unit ）。
* 节点可能有一个 __空（ empty ）__ continuation ，可能存在一个错误或者退出程序的停机
* 依赖空（ empty ） continuation 的节点不可达，可以从图中安全的删除
* 与节点`A`的延续直接相关的节点`B`是`A`的后继，`A`是`B`的前驱（节点不是必须有显式的前驱或后继）。
* __浮动节点（ floating node ）__ 没有显式的前驱或者后缀，但是通过检查它的其他依赖调度它。
* __pinned 节点（ pinned node ）__ 是哪些被显式包含在一个关联的控制流结构的节点。在生成的原生码中， pinned 节点会和它的控制流结构在同一个基本块中。
* 控制可以分叉和结合（分割和合并）（ fork and join(split and merge) ）。能表达这个的 IR 会方便。
  * 如果 IR 有显式控制流结合（合并），它们会被表示为节点，比如 C2 的 [ RegionNodes ](http://hg.openjdk.java.net/jdk9/jdk9/hotspot/file/tip/src/share/vm/opto/cfgnode.hpp#**l61**)
### effects
* 节点的 effects 就是描述了在节点执行后哪个内存位置会被修改
* 效果系统（ effects system ）是程序在执行期间可能创建或者修改的可能的内存位置的形式化模式
* continuation 和 effects 都可以看作值，如果当这个很方便的时候
* 在上面的场景中，效果系统可以是类型系统的一部分
### profiles
* profiles 是节点上的一个重要装饰
* profile 表示了一组对节点（值或者其他行为）的 __断言（ assertions ）__ 
* profile 数据收集自这个节点之前实例额执行，或者可能来自于其它分析
* profile 数据可能包含一个节点和/或它的延续被执行的可能性估计
* profile 数据可能包含节点值的类型的估计
### containment
* 节点可能有会存在多对一的边关系到一个“容器”节点以表达程序的局部性。
* 容器表示方法，作用域，循环，基本块，或者放置（ placement ）的其它单元。
* 容器是特殊目的的节点，但是，如果 containment 是组合的，它们可以看作和其他节点一样
* 另外， containment 可以用装饰以及可能的多个（不连通的）子图表达

### 实现
* 在设计和工程中，边和装饰可以直接或者隐含的表示
* 每个节点的直接边或者装饰是独立确定的
* 隐式的边或者装饰是根据某些规则从节点的邻居和装饰推导的
* 典型的 containment ， continuation 以及 effect 都是隐式的，部分原因是为了减少边复杂度
* 值通常不是隐式的，但是在面向栈（ stack-oriented ）符号中可以是隐式的，在这个里面，值可以通过一个一个 LIFO 栈隐式的被操作使用（例如字节码`iadd`）
### CFG vs PDG
* 图最终要被 __调度（ scheduled ）__，它必须被赋予基本块分配（ basic block assignments ）并有一个和他因果约束（ causality constraints ）一致的全序（ total order ）（因为机器指令必须发生在基本块内，并且在其中有一个全序）。
* IR 的 __CFG （ control flow graph 控制流图）__ 版本是节点固定到（ pinned ）一个基本块并且（通常）在它的基本块内调度。
* 假设没有节点被固定（ pinned ）到不一致的基本块， CFG IR 总可以很容易地调度
* 传统 CFG 中，控制放置（ placement ）被特殊表示：将每个节点包含在一个序列，这个序列表示一个公共基本块的所有指令。
* __PDG （ program dependence graph 程序依赖图）__ 使用显式的边表示所有控制
* 在 PDG 中，一个典型节点的正常状态相对于它的控制边浮动（ the normal state of a typical node is to float relative to its control edges ）。
* 处理 PDG 的过程中，可能会构造临时的 CFG （例如循环转换）作为一个临时的附属结构，而不是这个 IR 图的内在关系（ a relation intrinsic to the IR graph ）。
* 从一个全序的表示（例如一个 AST 或者字节码）中解析 IR ， __CFG__ 的放置（ placement ）可以被高效的确定。这种情况我们可以说节点是 __预调度的（ pre-scheduled ）__。
* 即使对放置（ placement ）最简单的修改，在 CFG 中都要求编辑 passes （ editing passes ）和对边的临时重定义。因此，应该在解析时间（ 或者其他图的创建时间 ）选出好的放置（ placement ）。这通常能很好的工作，因为源代码的遇见顺序（ encounter order ）基本就是好的调度。
* PDG 中的显式边比 CFG 的隐式边消耗更多的工作存储，这有待商榷。在 PDG 场景中，内存中的节点顺序不重要通常认为是“浪费的”信息。另一方面，内存顺序（如果重要）是一个僵化的关系，很容易超过真实，基本的约束而过度指定顺序（ over-specifies order ），使得它很难执行重排序转换。
* 两个方式出现 bug 的地方不同：
  * 在 PDG 中，错误编辑的边会导致在下一个调度中出错，这可能在距离错误的修改很远
  * 在 CFG 中，由于节点之间过多的（隐式）连接，被错误放置的节点通过对照它的领居（也许）可能很容易被检查到。
  * 但是，在 CFG 中，由于来自源代码的原始表示，节点放置（ placement ）可能会“意外正确”（ correct by accident ），而这会因为不相关的转换导致低频的 bug ，这很难诊断。
* CFG 基本块的顺序表示很容易阅读，但是在没有辅助的情况下阅读 PDG 图很难；这影响调试速度（这也是无论 IR 细节是什么，检视很重要）。
* 在 PDG 中，重点是自由但局部的关系。对于整个程序语义来说，每个边都是必须且充足的。当这个成真时，就可以最大化局部分析和编辑的便捷性和健壮性，这虽然不是整个优化流程但是时很大的一部分。
* 在 PDG 中显式控制边的存储开销可能本质上并不重要，通过工程技巧可以控制（例如 Graal 的注解）。
* 即使在 PDG 中，调试表示可以很轻易的包含实验调度，从而可以和 CFG 表示竞争。
* PDG 格式总是和早期或者更高层级的表示相关，这个表示最终会低化（ lowered ）为 CFG ，作为机器代码生成过程的一部分。