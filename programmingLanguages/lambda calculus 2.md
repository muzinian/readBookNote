## lambda演算-2
__本文主要内容都脱胎于[这里](https://opendsa.cs.vt.edu/ODSA/Books/PL/html/index.html#lambda-calculus)的第三章的第5，6和7节。如果有什么错误都是我没有理解到位。__
### 替换算法
前文描述了 lambda 表达式的三种类型，自由变量和绑定变量的含义，以及$\alpha$-变换，通过这三个工具，我们可以解释在 lambda 演算中函数调用的含义了。由于 lambda 演算中唯一的实体是函数，所以解释（interpreting）一个 lambda 演算程序归根结底就是执行一个函数调用。

考虑这个函数调用`f(8)`，其中`f`的定义是：
```Javascript
var f = function (x){return 2 * x - 5;}
```
我们计算`f(8)`的方式是，用`8`替换`f`函数体中的`x`为`2*8-5`然后计算它的值为`11`。这种估值函数调用的方式引入了 _基于替换的解释模型(substitution-based model of interpretation)_。

由于一个函数的函数体和一个函数调用的实参可以是任意的 lambda 表达式，我们需要一个算法可以用任意的 lambda 表达式`a`（实参）替换 lambda 表达式`b`（函数体）的变量`p`（函数的形参）。作为函数调用的一个组件，我们忽略对于`a`，`p`和`b`的解释，先整体的描述整个算法。记用`a`替换`b`中的`p`为`subst(a,p,b)`，这里，`a`和`b`是任意 lambda 表达式而`p`是任意变量。

由于我们是用`a`替换`b`中的`p`而`b`是任意的 lambda 表达式，参看 lambda 表达式的 BNF 语法可知`b`可能有三种情况，分别是：一个变量、一个 lambda 抽象和一个应用表达式。

__情况1：__ 如果`b`是变量，设是`x`，那么`subst(a,p,b)`就是`subst(a,p,x)`。考虑`p`和`x`是一般变量，我们需要区分两种情况。首先，如果`p`和`x`是同一个变量，设为`v`，那么`subst(a,p,b)`就是`subst(a,v,v)`，它的值就是`a`，因为我们正是要用`a`替换`v`（原文这样解释可以清楚的表现出替换的过程，简单的说就是如果`p`和`b`相等，替换结果就是`a`），这是 __情况1a__。否则，`subst(a,p,x)`就是`x`，这是因为`p`没有出现在`x`中，所以就不需要替换，也不可能替换，这是 __情况1b__。例如，`subst(λx.x,u,v)`这个替换，由于`u`和`v`不是同一个变量，所以符合 __情况1b__`subst(λx.x,u,v)`就是`v`。而`subst(λy.(y z),u,u)`是符合 __情况1a__ ，因为这里的`p`和`b`相等，结果就是`λy.(y z)`。

__情况2：__ 如果`b`是抽象，即用`a`替换`λx.E`中的`p`，那么需要区分三种情况：
  * __情况2a：__`p`和`x`是同一个变量，设为`v`，那么 `subst(a,v,λv.E)`，返回`λv.E`。例如，`subst(λx.x,z,λx.x)`就返回`λx.x`。
  * __情况2b：__`p`和`x`不是同一个变量， 且`x`在`a`中没有出现自由（occur free），那么`subst(a,p,λx.E)`就返回`λx.subst(a,p,E)`。例如，`subst((w z),y,λx.y)`的结果是`λx.(w z)`。
  * __情况2c：__`p`和`x`不是同一个变量， 且`x`在`a`中出现了自由（occur free），那么 `λx.E`需要执行一个 alpha-变换，然后就可以应用情况2b。例如，`subst((w x),y,λx.x)`需要执行一个 alpha-变换，选择`a`作为替换变量，然后应用情况2b，返回的结果是`λa.a`。

__情况3：__ 如果`b`是应用，设为`(e1 e2)`，其中`e1`和`e2`是任意的 lambda 表达式，那么`subst(a,p,b)`就是`subst(a,p,(e1 e2))`，进而需要转换为`(subst(a,p,e1) subst(a,p,e2))`，也就是说，分别对开始的应用表达式递归地用`a`替换`p`。例如，`subst(λy.(y z),u,(λv.u u))`就是`(subst(λy.(y z),u,λv.u) subst(λy.(y z),u,u))`，也即`(λv.(λy.(y z)) λy.(y z))`。

### Beta-规约 (Beta-Reduction)
上面定义了替换算法，我们可以定义 _估值函数应用_ 的规则，这是 λ 演算解释器的主要操作。这个规则叫做 $\beta$-规约（_$\beta$-reduction_）。可以应用这个规则的表达式叫做 _$\beta$-redex_（$\beta$-规约表达式）。$\beta$-redex 的形式化定义是：它是一个特定形式的 λ 表达式，本身是一个应用表达式且第一个元素是一个函数抽象。举个例子，`(λx.(x z) (z (v u)))`是一个 $\beta$-redex，因为`(λx.(x z)`是一个函数抽象。而`((λx.(x v) y) (z (v u)))`不是一个 $\beta$-redex，因为`((λx.(x v) y)`不是一个函数抽象。不过，`((λx.(x v) y)`是一个 $\beta$-redex，所以，一个表达式自身不是 $\beta$-redex，但是它包含的子表达式可能是。分析任意语言是如何估值函数调用的一个关键部分是从$\beta$-规约的角度检查它的语义。

如果我们有形如`(λx.E E')`的 $\beta$-redex，那么 $\beta$-规约这个表达式意味着依据上面的替换规则用`E'`替换`E`中的`x`。即，估值形如`(λx.E E')`的 $\beta$-redex，就是执行`subst(E',x,E)`这个替换。可以观察到，$\beta$-规约的结果就是先移除掉 λ-抽象的绑定出现（binding occurrence）仅保留它的函数体，然后用`E'`替换这个函数体内的`x`。
### 规约策略
`(λx.m(λx.(x x)λx.(x x)))`中有两个 $\beta$-redex，取决于你选择先规约哪一个 $\beta$-redex，你可能得到的结果是`m`或者你会得到和开始时同样的表达式，也就是说这个 $\beta$-规约等价于一个无限循环。在 λ 演算中， 表达式的估值本质上就是 $\beta$-规约，可以很简单的用替换定义为$(\lambda p.b\;a) \equiv subst(a,p,b)$。这里，还需要考虑，在前面的 $\beta$-redex 中，`a`和`b`自己可能会包含 $\beta$-redex。我们需要递归的规约他们，这就会导致如下问题：
1. 我们需要先规约哪一个 redex？是顶层的 redex 还是 嵌套的？
2. 规约的的顺序有没有影响？两个策略的后续影响是什么？
3. 不同的规约策略导致不同的结果么？

上面问题2和3的部分答案的一个关键是 __Church-Rosser 定理 （Church-Rosser Theorem）__。这个定理表明，_如果两个不同的规约策略都产生一个答案，那么他们会得到相同的答案_。因此，2和3的答案为否的前提是采用的可以得到一个答案的任意策略可以都得到相同的答案。这里，关键在于一个策略是否会得到一个答案，而 Church-Rosser 定理既没有保证策略会终止也不保证如果答案存在这个答案可以得到。如果执行规约策略之后得到的答案无法被进一步规约，我们说这个表达式是 __$\beta$-normal形式__（$\beta$-normal form）。
#### 应用序规约（applicative order reduction）
 __应用序规约（applicative order reduction）__，以`f(arg1,arg2,arg3,...)`为例，这个策略的估值方式是：
1. 从左到右估值每一个子表达式，如果`f`需要估值，那么也会对它进行估值
2. 对除了最左边以外的所有子表达式，应用最左边的结果（它应该是一个函数）
这个策略的特点是，从左到右，先估值最里面的子表达式。也就是，我们只会在所有子表达式都已经被规约并且除了最顶层的应用以外没有 redex 时才会执行一个应用。考虑：
`(λx.((x y) (y x) (λw.(w w) z))`
这个策略会先估值`(λw.(w w) z)`，得到`(z z)`，然后，这个结果会用来替换`((x y) (y x))`中的`x`，返回`(((z z) y) (y (z z)))`，这就是最后的结果。注意，如果用这个策略规约本节开始的例子，就会得到无限循环的结果。

#### 正规序规约（Normal Order reduction）
 __正规序规约（Normal Order reduction）__，先规约最左边的 $\beta$-redex，然后再规约它内部的子表达式以及它后面的表达式。这个策略会先应用这个函数，然后再估值它的子表达式。换句话说，正规序规约总是搜索最左最外的规约，而应用序总是搜索最左侧最内层的规约。由于正规序规约推迟估值一个函数的实参，对于本节开头的例子，他会得到`m`。当使用正规序规约`(λx.((x y) (y x) (λw.(w w) z))`时，它会使用`(λw.(w w) z)`替换`((x y) (y x))`中的`x`，因此，它会对`(λw.(w w) z)`估值 __两次__ 才能得到答案`(((z z) y) (y (z z)))`。