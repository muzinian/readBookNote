__类型的作用__
1. 类型告诉软件在给定的上下文中应该如何解释给定的位序列，使得存储的数据有切实的意义。
2. 类型限制了变量可取值的集合。可以将类型看作是可取值的集合。

__类型__:类型是对数据的一种分类，它定义了数据的意义，对数据可以执行的操作，以及数据接受的值的集合。编译器以及runtime会检查类型，确保数据的完整性，访问控制以及按照开发人员的意图解释数据。
__类型系统__:类型系统是一组规则，为编程语言的元素分配和实施类型。这些元素可以是变量，函数或者其他高级结构。类型系统通过两种方式分配类型：开发者在代码中书写的类型和编译器通过上下文隐式推断元素的类型。类型系统允许类型之间进行某些转换，限制其他类型的转换。

__类型检查__:类型检查确保程序遵守类型系统的规则。编译器在编译代码的时候进行类型检查。runtime在执行代码的时候进行类型检查。编译器中负责实施类型规则的组件叫做类型检查器。如果检查失败，意味着程序没有遵守类型系统的规则，要么编译失败，要么发生运行时错误。

类型系统的背后是形式化理论。__curry-howard对应表明：可以将类型是为一个逻辑命题，将从一个类型转换为另一个类型的函数视为逻辑蕴含__。类型的一个值相当于证明命题为真的一个证据。逻辑和类型系统的密切关系说明了，遵循类型系统规则的程序相当于一个逻辑证明。类型系统是一个语言，我们用它写出这些证明。

类型提供了5个主要优点：__正确性，不可变性，封装，可组合和可读性__。这些优点可以防止系统出现混乱和无序。

正确性：通过利用类型系统，可以把运行时错误转换为编译期错误，并修复它。当程序进入到坏状态时，就会发生错误。坏状态是指当前所有活跃变量的组合变得无效。消除坏状态的一种方法时限制变量能够取到的值的数量，从而减少状态空间。可以将运行中程序的状态空间定义为全部活跃变量所有可能值的组合，即所有变量的类型的笛卡尔积。注意，类型被定位为一个变量可取的值的集合。两个集合的笛卡尔积由这两个集合的所有有序对构成一个集合

不变性：__可以将运行中的系统看作正在穿过状态空间，而不变性于这种看法关系紧密，当我们的系统正处于一个好的状态时，如果能保持该状态不变，或者部分不变，就减少了出错的概率__。例如：
```ts
function safeDivide():number{
    let x:number = 42;
    if(x == 0) throw new Error("x should not be zero");//对x进行合法性检查
    x = x-42;//却由于别的并发线程/其他函数调用修改
             //(我觉得这个例子不好，x是函数的局部变量，不会被别的值修改)
    return 42/x;
}
```
```ts
function safeDivide():number{
    const x:number = 42;
    if(x == 0) throw new Error("x should not be zero");//对x进行合法性检查
    x = x-42;//x是const，编译不通过
             //(我觉得这个例子不好，x是函数的局部变量，不会被别的线程/函数修改)
    return 42/x;
}
```
这里，`x`无论可不可变在内存中都没有区别，常量性只对编译器有用，它和类型系统启用的一个属性。__在涉及到并发时，不变性特别的重要，如果数据不可变，就不会发生数据竞争__。同时，如果是不可变的，编译器还可以做出很多激进的优化，比如内联，常量折叠等等。很多函数式编程语言都要求数据不可变，这样它们接受一些数据作为函数输入，返回其他数据，但是不修改输入，好处是这些输入在整个声明周期不会变化，在经过检验后，会一直处于好的状态，但是坏处时会有冗余的数据复制。

封装：封装是指隐藏代码内部机制的能力，代码可以是函数，类或者模块。封装可以减少复杂度，将代码拆分为更小的组件，只暴露必要的API，隐藏实现细节。
```ts
class safeDivisor{
    divisor:number = 1;
    setDivisor(value:number){
        if(value == 0) throw new Error("value should not be zero");
        this.divisor = value;
    }
    divide(x:number):number {
        return x /this.divisor;
    }

}
function exploit():number{
    led sd = new safeDivisor();
    sd.divisor=0;//由于没有封装divisor，所以可以在外部修改它
    return sd.divide(42);//除零错误
}
```
通过将divisor封装起来，保证不能直接修改，我们避免绕过对0的检查。
```ts
class safeDivisor{
    divisor:number = 1;
    setDivisor(value:number){
        if(value == 0) throw new Error("value should not be zero");
        this.divisor = value;
    }
    divide(x:number):number {
        return x /this.divisor;
    }

}
function exploit():number{
    led sd = new safeDivisor();
    sd.divisor=0;//由于没有封装divisor，所以可以在外部修改它
    return sd.divide(42);//除零错误
}
```
同样，无论标识为什么可见性，在内存中，都是一样的，无法编译的原因是因为我们提供的类型表示以及对此的操作不符合类型系统和编译器的要求。这些可见性，都是包含在它们类型的属性中(意思是safeDivisor的类型信息包含了这些属性的可见性，这是附加在类型信息上的)。

封装或者信息隐藏能够让我们将逻辑和数据拆分到公有 接口和非公有实现中。大型系统中，这种拆分非常有用，使用接口(或者抽象)使得理解一段特定代码的作用变得简单。我们只需要理解组件的接口而不必理解所有实现细节。封装也有助于将非公有信息限制在一个边界内，并保证外部代码不能修改这些信息--因为它们根本访问不到这些信息。

可组合性：如果代码本身是不可组合的，那么针对每一种数据类型，每个数据结构和每个条件都需要使用不同的函数来完成本质上是相同抽象的功能。通过抽象，混合搭配组件，可以减少大量的模板代码。泛型类型是我们可以表达这种抽象。

将独立的组件组合起来，能够得到模块化系统，并减少需要维护的代码。随着代码规模和组件数量增加，可组合性会日益重要。在可组合系统中，不同部分是松散耦合的，同时，每个子系统的代码不会重复。要处理新的需求，通常只需要通过更新单个组件来完成，而不必在整个系统中大范围修改，同时，这样做，理解这些系统也会变得简单，我们可以独立思考系统的各个部分。

可读性：类型可以清晰的表面函数期望的参数，泛型算法的先决条件，类实现的接口，这些信息很重要，通过这些，我们可以单独思考可读的代码，通过定义就可以理解代码的行为而不需要取源码中查看调用关系。合理的命名和注释对于可读性很有用，但是类型增加了另外的信息，__因为它允许我们指定约束__(我理解的是，通过类型信息可以明确知道方法/函数接受的参数，而不用取代码中看这个string是干嘛的，那个string是干嘛的)。
```ts
declare function find(range:any,pred:any):any;
```
```ts
declare function find(range:T[],p:(elem:T)=>boolean):T|undefined;
```
对比两个声明，你会发现，第一个`find`你无法通过声明看出来任何东西，你需要深入源码才能知道`range`和`pred`需要什么类型的值，而第二个则不一样，你可以直接知道需要提供什么参数，以及函数的返回值是什么。__明确的指定类型比注释更有帮助，因为编译器会确保类型正确__。

__类型系统的分类__：
静态类型是在编译期检查类型，当编译完成，运行期间值一直有正确的类型，动态类型将类型检查推迟到运行时，因此，如果类型不匹配，就会出现运行时错误。

强类型系统只会做(甚至是不做)少量隐式类型转换，而弱类型系统允许更多的隐式类型转换。

__动态类型与静态类型__
Javascript时动态类型，而TypeScript是静态类型。动态类型不会在编译时施加任何类型约束。有时候也会称动态类型叫做"鸭子类型"(duck typing)。ts中，关键字any可以模拟动态类型，因为any关键字允许未指定类型的变量(注：据我所知，C#中的dynamic关键字也是这样的效果。而Java中，截止到java17，在java语法上暂不支持这个关键字。但是在字节码层面上从java7开始引入了`invokedynamic`)。
而静态类型在编译期检查类型，如果类型不符合，会导致编译错误。书中使用ts举了一个例子：
```ts
//此函数接受一个any类型的实参，所以会绕开编译时类型检查
function quacker(duck:any){
    duck.quack();
}
//我传入一个有quack()方法的对象，所以可以输出
quacker({quack:function{}{console.log("quack");}});
//这里TypeError，因为42没有quack这个方法
quacker(42);
```
在ts中，可以声明一个`Duck`接口，并正确设置函数实参类型。在ts中，如果一个类型提供了接口(`Duck`)定义的方法(`quack()`)，就认为实现了接口(`Duck`)。其它语言中，需要显式声明类型实现了接口。
```ts
interface Duck{
    quack():void;
}
//此时函数接受一个Duck类型的实参
function quacker(duck:Duck){
    duck.quack();
}
//可以正常编译
quacker({quack:function{}{console.log("quack");}});
//会出现编译错误，42不是一个Duck类型
quacker(42);
```

__弱类型和强类型__
类型系统的强度描述了系统在实施类型约束时的严格程度，弱类型系统会隐式的尝试将值从实际类型转换为是要那个该值时期望的类型。

js是弱类型的，它在运行时处理类型，举了个例子，js提供了两个相等运算符`==`和`===`，两者都会检查值是否相等，而后者，还会检查类型是否相同(注：js中`==`会进行隐式转换，转换规则参见[相等](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality)，而`===`则不会，参见[严格相等](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Strict_equality))。

ts是强类型的，以`==`和`===`来说，如果操作符两边的数据类型不一致，ts会编译不通过。强类型长期来看收益更好。注意，一个类型系统要么是动态类型，要么是静态类型，但是类型系统的强度是一个范围：执行的隐式转换越多，该类型系统越弱。大部分类型系统，包括强类型系统，会对其认为安全的转换执行隐式转换。例如`number`转换为`boolean`，以及数字的拓宽转换。

类型推断：编译器可以根据规则在某些场景下推断出变量/函数的类型。注意，这不是动态类型，而是编译器进行了推断，他仍在编译期判断并检查类型，我们只是没有显式提供类型，而不是像动态类型那样延迟到运行时再检查。如果无法推断类型，编译器会给出错误，要求明确类型。
```ts
//在ts中，如果函数的所有返回语句返回的值类型都一样，那么函数定义中就不需要显示指定返回类型
function add(x:number,y:number){
    return x+y;
}
//根据上下文，可以知道a必然是一个number类型，因此编译器可以推断出来
let a = add(40,2);
```