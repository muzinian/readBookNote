## 堆
本章，我们讨论对极其有用的优先队列(priority Queue)数据结构的实现。这两个结构都是一种特殊的二叉树，叫做 _堆(heap)_，意思是"无组织的放在一起的东西(a disorganized pile)"。这个二叉搜索树是相反的，后者可以看作是高度组织的东西。

第一个堆实现使用数组模拟一个完全二叉树。这个非常快(注：指的是这个实现提供了高效的操作，不是说这个数据结构实现的快)的实现是一个已知是最快的排序算法，叫做堆排序(heapsort)，的基础。第二个实现基于一个更灵活的二叉树。它支持一个`meld(h)`的操作，允许这个优先队列合并另一个优先队列`h`的元素。

### 10.1 `BinaryHeap`：一个隐含二叉树
我们对(优先)队列的第一个实现是基于一个超过了四百年的技术。_Eytzinger's方法(Eytzinger's method)_ 允许我们通过把一个完全二叉树的节点按照广度优先顺序(6.1.2节 )放到数组中而使用一个数组表示一个完全二叉树。使用这种方式，根存放在位置0处，根的左孩子存放在位置1处，根的右孩子存放在位置2处，根的左孩子的左孩子放在位置3，一次类推。参见图10.1。

![figure10.1.png "Eytzinger's方法用数组表示一个完全二叉树"](figure10.1.png "Eytzinger's方法用数组表示一个完全二叉树")

如果我们对足够大的树使用Eytzinger's方法，可以看到某些模式。位于索引`i`处节点的左孩子位于索引$left(i) = 2i+1$处，位于索引`i`处节点的右孩子位于索引$right(i) = 2i+2$。位于索引`i`处节点的父节点位于索引$parent(i) = (i-1)/2$处。
```Java
int left(int i ){
    return 2*i+1;
}
int right(int i){
    return 2*i+2;
}
int parent(int i){
    return (i-1)/2;
}
```
`BinaryHeap`使用这个技术隐含表达一个元素节点是 _堆有序的(heap-ordered)_ 完全二叉树：存放在任意索引`i`处的值都不会比存放在索引`parent(i)`的值小，除了根值$i=0$处。它遵循在优先队列中最小的的值存放在位置0处(根)。

在`BinaryHeap`中，`n`个元素存放在数组`a`中：
```Java
T[] a;
int n;
```
`add(x)`操作的实现相当直接。因为都是基于数组的数据结构，我们首先检查`a`是否满了(通过检查`a.length==n`)，如果满了，我们增长`a`。下一步，我们在位置`a[n]`放置`x`并增加`n`。此时，我们剩下的就是维护堆属性。我们通过重复交换`x`和它的父节点直到`x`不在小于它的父节点完成维护。参见图10.2。

![figure10.2.png "在BinaryHeap中添加值6"](figure10.2.png "在BinaryHeap中添加值6")

```Java
boolean add(T x){
    if(n+1>a.length)resize();
    a[n++] = x;
    bubbleUp(n-1);
    return true;
}
void bubbleUp(int i){
    int p = parent(i);
    while(i>0&&compare(a[i],a[p])<0){
        swap(i,p);
        i = p;
        p = parent(i);
    }
}
```
`remove()`操作的实现，也就是从堆中删除最小的元素，就有点麻烦了。我们知道最小的值在哪里(位于根)，但是我们需要在删除后替换它并确保我们维护了堆属性。

完成这个最简单的方式使用值`a[n-1]`替换根，然后删除这个值，最后降低`n`。不幸的是，新的根元素现在可能不是最小的元素，所以他需要向后移动。我们重复的比较这个元素和它的两个孩子。如果它是三者最小的一个我们就完成了。否则，我们交换这个元素和最小的孩子然后继续。
```Java
T remove(){
    T x = a[0];
    a[0] = a[--n];
    trickleDown(0);
    if(3*n<a.length) resize();
    return x;
}
void trickleDown(int i){
    do{
        int j = -1;
        int r = right(i);
        if(r<n&&compare(a[r],a[i])<0){
            int l = left(i);
            if(compare(a[i],a[r])<0){
                j = l;
            }else{
                j = r;
            }
        }else{
            int l = left(i);
            if(l<n&&compare(a[l],a[i])<0){
                j = l;
            }
        }
        if(j>=0)swap(i,j);
        i = j;
    }while(i>=0);
}
```
![figure10.3.png "从BinaryHeap中删除最小值4"](figure10.3.png "从BinaryHeap中删除最小值4")

就像其他基于数组的结构，我们会忽略调用`resize()`的时间开销，因为它们可以通过引理2.1的摊还讨论计算。`add(x)`和`remove()`的运行时间依赖于背后的二叉树的高度。幸运的的是，这是一个完全二叉树；除了最后一层每一层都由最大的可能节点数。因此，如果树的高度是`h`，那么至少有$2^h$个节点。换句话说
$$n\ge 2^h$$
等式两边取对数，就得到：
$$h\le \log n$$
因此，`add(x)`和`remove()`操作就运行在$O(\log n)$时间。
#### 10.1.1 总结
如下定理总结了`BinaryHeap`的性能：
__定理10.1__ `BinaryHeap`实现了(优先)队列接口。忽略了`resize()`调用开销，`BinaryHeap`支持$O(\log n)$的`add(x)`和`remove()`操作。

进一步的，从一个空的`BinaryHeap`开始，任意`m`个`add(x)`和`remove()`操作序列会导致在所有`resize()`一共花费$O(m)$的时间开销。

### 10.2 `MeldableHeap`：随机可以混合的堆
