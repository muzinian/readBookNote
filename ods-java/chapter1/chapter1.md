### 1.2 接口
在讨论数据结构时，理解数据结构接口和实现的区别很重要。接口描述了数据结构做什么，而实现表述了数据结构怎么完成它。

接口，有时候也叫做抽象数据类型，定义了由数据结构支持的操作集合和这些操作的语义或者意义(semantics,or meaning)。接口不会告诉我们数据结构是怎么实现这些功能的。他只提供支持的操作列表以及每个操作接受的参数类型规范和返回值。

另一方面，数据结构的实现，包括数据结构的内部表示和数据结构所支持操作的算法实现的定义。因此，单个接口可以有多个实现。例如，在第二章，我们会看到使用数组实现`List`接口，以及在第三章我们会看到使用基于指针的数据结构实现了`List`实现。每个都以不同的方式实现了同样的接口，`List`。

#### 1.2.1 队列(Queue)，栈(Stack)，双端队列(Deque)接口
`Queue`接口表示了一个我们可以添加元素和删除下一个元素的元素集合。更具体的说，`Queue`支持的操作有：
* `add(x)`：向`Queue`中加入元素
* `remove()`：从`Queue`中删除下一个(之前添加的)元素，`y`并返回`y`。

注意到`remove()`操作没有参数。`Queue`的排队原则(queueing discipline)决定了要删除哪个元素。有很多可能的排队原则(queueing discipline)，最常见的包括FIFO，优先级，LIFO。

FIFO(first-in-first-out先进先出)队列，如图1.1，按照元素添加的顺序删除元素。和在杂货铺收银台排队结账的情况很像。这事最常见的一种队列，所以通常会胜率FIFO描述符。在其他文章中，对一个FIFO队列执行`add(x)`和`remove()`操作也叫做`enqueue(x)`和`dequeue()`。

![figure1.1.png "FIFO队列"](figure1.1.png "FIFO队列")

优先队列，如图1.2，总是从队列中删除最小的元素。这类似与医院急诊科对待病人的方式。当病人就诊时，他们会被评估病情并安排在等待室。当有医生有空的时候，他/她首先治疗伤势最重的患者。在其他书籍中，对优先队列的`remove()`操作通常也叫做`deleteMin()`。

![figure1.2.png "优先队列"](figure1.2.png "优先队列")

一个很常见的排队原则是LIFO(last-in-first-out后入先出)原则，如图1.3。在LIFO队列中，最后添加的元素是下一个被删除的。最好的展示效果就是摞在一起的盘子栈；被放置在栈顶的盘子也会从栈顶上删除。这个结构是如此的有名以至于他有自己的名字：栈(Stack)。通常，在讨论一个栈时，`add(x)`和`remove()`的名字改成了`push(x)`和`pop()`；这是为了避免弄混LIFO和FIFO原则。

![figure1.3.png "栈"](figure1.3.png "栈")

Deque是FIFO和LIFO队列(Stack)的泛化。Deque表示为一系列元素，包含一个front和一个back。元素可以在添加在序列的front上或者back上。Deque操作的名字是自解释的：`addFirst(x)`，`removeFirst()`，`addLast(x)`和`removeLast()`。有一点值得注意，栈可以只用`addFirst(x)`和`removeFirst()`实现，而FIFO队列可以只用`addLast(x)`和`removeFirst()`实现。

#### 1.2.2 List接口：线性序列
本书将不会过多讨论FIFO队列，栈或者双端队列接口。这是因为这些接口都包含在了List接口中。链表，如图1.4，表示了值为$X_0,...,X_{n-1}$的序列。

![figure1.4.png "一个链表表示一个由0,1,2,....,n-1索引的序列。在这个链表中，调用get(2)会返回值c"](figure1.4.png "一个链表表示一个由0,1,2,....,n-1索引的序列。在这个链表中，调用get(2)会返回值c")

List接口包括如下操作：
1. `size()`:返回链表的长度n。
2. `get(i)`:返回值$x_{i}$
3. `set(i,x)`:让$x_{i}$的值等于x
4. `add(i,x)`:在位置$i$处插入$x$，移动$x_{i},....,x_{n-1}$；对于所有的$j\in\{n-1,...,i\}$，设置$x_{j+1}=x_{j}$，$n$加一,并设置$x_{i}=x$
5. `remove(i)`:删除值$x_{i}$，移动$x_{i+1},....,x_{n-1}$；对于所有的$j\in\{1,...,n-2\}$，设置$x_{j}=x_{j+1}$，$n$减一

注意这些操作很容易满足实现双端队列实现：

$addFisrt(x) \implies add(0,x)$
$removeFisrt(x) \implies remove(0)$
$addLast(x) \implies add(size(),x)$
$removeLast(x) \implies remove(size()-1)$

尽管我们在后续章节不会正式的讨论栈，双端队列和FIFO队列接口，词语Stack或者Deque有时候也会用来描述那些实现了List接口的数据结构。当出现这种情况时，它突出了那些数据结构可以高效实现栈或者双端队列这一事实。例如，`ArrayDeque`类是List接口的一个实现，它可以以常量时间实现所有Deque操作。

#### 1.2.3 `USet`接口：无序集合(Unordered Sets)
`USet`接口表示一个无序集合，集合内的元素都是不同的，它模拟了一个数学上的$set$。一个`USet`包含了$n$个 _不同的_ 元素；没有元素会出现超过一次；这些元素没有特定顺序。一个`USet`支持如下操作：
1. `size()`:集合中的元素个数
2. `add(x)`:如果集合中没有元素x，就加入到集合中；添加$x$到给定集合中，这个集合中没有元素$y$满足$x$等于$y$。如果$x$被加入到了集合中就返回`true`，如果没有就返回`false`。
3. `remove(x)`:从集合中删除`x`；在集合中找到一个元素$y$，满足$x$等于$y$并删除$y$。返回$y$或者`null`如果集合中没有这样一个元素。
4. `find(x)`:在集合中找到元素`x`，如果它存在；在集合中找到一个元素$y$满足$y$等于$x$。返回$y$，如果这个元素不存在，就返回`null`。

这个定义对于区分`x`(我们正在删除或者查找的元素)和`y`(我们要删除或者查找的元素)有点模糊。这是因为`x`和`y`可能实际是不同的对象但却可能被当成相等(在Java中，这个可以通过重载类的`equals(y)`和`hashCode()`方法实现)。这样的区别是有用的，因为它允许创建 _字典(dictionaries)_ 或者 _映射(map)_ ，它们可以把键映射到值。

为了创建字典/映射，我们组合了复合对象叫做`Pairs`，这个对象包含一个`key`和一个`value`。两个`Pairs`当它们`key`相等时被看作是相当的。如果我们在`USet`中存储了某个`pair(k,v)`，稍后通过使用`pair x=(k,null)`调用`find(x)`方法结果就是`y=(k,v)`。换句话说，只要提供了唯一的键`k`，就有可能覆盖值`v`。
#### 1.2.3 `SSet`接口：排序集合(Sorted Sets)
`SSet`接口表示排序了的元素集合。一个`SSet`按照某种全序方式(total order)存放元素，这样，任意两个元素`x`和`y`可以比较。用代码距离，这会通过`compare(x,y)`方法完成：

$$compare(x,y)\begin{cases}<0&if&x<y\\>0&if&x>y\\=0&if&x=y\end{cases}$$

`SSet`的`size()`，`add(x)`和`remove(x)`方法和`USet`接口有着完全一致的语义。`USet`和`SSet`的不同在于`find(x)`方法：
4. `find(x)`:在排序集合中定位`x`；在集合中查找满足$y>x$的最小元素，返回`y`或者如果不存在这样的元素，就返回`null`。

这种类型的`find(x)`操作有时候也叫做 _后继搜索(successor search)_。它和`USet.find(x)`有本质上的区别，因为即使在集合中没有元素等于`x`它依旧会返回一个有意义的结果。

在`USet`和`SSet`之间的`find(x)`操作很重要但经常被忽略。`SSet`提供的额外功能通常伴随着开销，包括更大的运行时间和更高的实现复杂度。例如，对于本书讨论过的大多数`SSet`实现，`find(x)`操作的运行时间都是集合大小的对数。另一方面，`USet`的实现，例如在第5章的`ChainedHashTable`，`find(x)`操作的运行时间是常量期望时间。当在考虑使用哪种结构时，我们应该始终使用`USet`，除非`SSet`提供的额外功能是真的必须。

### 1.3 数学背景
在本节，我们回顾一些贯穿本书使用的数学符号和工具，包括对数，大O记号，和概率论。这个回顾会很简洁并且不打算作为一个介绍。我们鼓励对这些背景不理解的读者去阅读《计算机科学中的数学》这一个十分好的免费课本中对应的章节并做相应联系。

#### 1.3.1 指数和对数
表达式$b^x$表示$b$的$x$次方。如果$x$是一个整数，就是b乘以自身$x-1$次：
$$b^x=\underbrace{b\times b\times\cdots\times b}_{x}\;.$$

当$x$是负整数，$b^x=1/b^{-x}$。当$x=0,$$b^x=1$。当$b$不是整数，我们依旧可以使用指数函数$e^x$定义指数，而它又是由指数序列定义的，不过这个最好留给微积分书籍来讲解。

在这个书中，表达式$\log_bx$表示$k$基于$b$的对数。也就是说，唯一的值$x$满足:
$$b^x=k\;.$$
本书中大多数对数是基于2(2元对数)。因此，我们忽略了基，这样$\log k$就是$\log_2k$的简写。

一个非正式但是有用的方法考虑对数就是考虑$log_bk$就是我们为了让b除k的结果小于等于1要执行的次数。例如，当我们执行一次二叉搜索，每次比较都把可能的结果减半。这个一直重复知道最多只有一个可能答案。因此，初始最多有$n+1$个可能答案的二叉搜索比较次数最多是$\lceil\log_2(n+1)\rceil$

本书另一个出现过几次的对数是 _自然对数_。我们使用标记$\ln k$表示$\log_ek$，这里$e$--欧拉常数--有下面等式给出：
$$e=\lim_{n\to\infty}(1+\frac{1}{n})^n\approx 2.71828\;.$$

自然对数常见的原因是它是一个特别常见的积分结果：
$$\int_1^k 1/x\;dx=\ln k\;.$$
对数有两个常见的运算，还原：
$$b^{\log_bk}=k$$
和变基：
$$\log_bk=\frac{\log_ak}{log_ab}\;.$$
例如，我们可以使用这两个操作比骄傲自然对数和二元对数：
$$\ln k=\frac{\log k}{\log e}=\frac{\log k}{(\ln e)/(ln 2)}=(\ln 2)(\log k)\approx0.693147\log_k\;.$$
#### 1.3.2 阶乘
本书有一两处使用了阶乘函数。对于一个非负整数$n$，标记$n!$(读作"n的阶乘")定义为
$$n!=1\cdot 2\cdot 3\cdot\cdots\cdot n\;.$$
出现阶乘是因为$n!$统计了不同排列的个数，例如，排序$n$个不同元素。对于特定的$n=0$，$0!$定义为1。

$n!$的结果可以用 _Stirling's近似法_ 渐进表示：
$$n!=\sqrt{2\pi n}\left(\frac{n}{e}\right)^ne^{\alpha(n)}\;.$$
这里
$$\frac{1}{12n+1}<\alpha(n)<\frac{1}{12n}\;.$$
Stirling's近似法同样可以渐进表示$\ln (n!)$:
$$\ln (n!)=n\ln n-n+\frac{1}{2}\ln (2\pi n)+\alpha(n)$$
(事实上，Stirling's近似法很容易通过使用积分$\int_1^n\ln ndn=n\ln n-n+1$逼近$\ln (n!)=\ln 1+\ln 2+\cdots+\ln n$来证明)
和阶乘相关的是二项式系数(binomial coefficients)。对于一个非负整数$n$和整数$k\in \{0,\dots,n\}$，标记$n\choose k$表示：
$$\binom{n}{k} = \frac{n!}{k!(n-k)!}\;.$$
二项式系数$n\choose k$(读作"从n中选择k个")统计了$n$个元素集合子集大小为$k$的个数，例如，从集合$\{1,\dots,n\}$中选择$k$个不同整数的方法个数。
#### 1.3.3 渐进符号
