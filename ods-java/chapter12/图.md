## 图
本章，我们研究图的两种表示以及使用这些表示的基本算法。

数学上的，一个 _(有向)图((directed)graph)_ 是一个对$G=(V,E)$，这里$V$是 _顶点(vertices)_ 的集合而$E$是被称作 _边(edges)_ 的有序顶点对的集合($E$ is a set of ordered pairs of vertices called _edges_.)。一个边$(i,j)$的 _方向(directed)_ 是从$i$到$j$；$i$叫做边的 _源(source)_ 而$j$叫做 _目标(target)_。$G$中的 _路径(path)_ 是一个向量序列$v_0,\ldots,v_k$满足对于任意$i\in\{1,\ldots,k\}$，边$(v_{i-1},v_i)$在$E$中。一个路径$v_0,\ldots,v_k$如果额外有$(v_k,v_0)$在$E$中，这个路径就是一个 _环(cycle)_。一个路径(或者环)是 _简单的(simple)_ 如果他所有的顶点都是唯一的。如果从某个顶点$v_i$到某个顶点$v_j$存在一个路径，那么我们就说从$v_i$到$v_j$是可达的。图12.1展示了一个图的例子。

![figure12.1.png "一个包含了12个顶点的图。顶点用有数字的圈，边使用有指向的曲线(从源指向目标)表示"](figure12.1.png "一个包含了12个顶点的图。顶点用有数字的圈，边使用有指向的曲线(从源指向目标)表示")

由于图有能力模型化很多现象，他有着大量的应用。存在很多显然的例子。计算机网络可以被模型化为图，其中顶点对应计算机而边对应这些计算机之间的(有向)通信链接。城市街道可以模型化为图，其中顶点表示十字路口而边表示为连接连续不断的十字路口的街道。

不太明显的例子也存在，只要我们意识到图可以模型化一个集合内任意成对的关系(any pairwise relationships within a set)。例如，在大学设置中我们可能会有一个时间表 _冲突图(conflict graph)_，其中顶点表示这所大学提供的课程而边$(i,j)$表示当且仅当至少有一个学生都上了课程$i$和课程$j$。因此，一个边就表示了课程$i$的考试不应该与课程$j$的考试安排在同一个时间。

贯穿本节，我们使用$n$表示$G$顶点的个数，$m$表示$G$边的个数。也就是说，$n=|V|$而$m=|E|$。进一步的，我们会假设$V=\{0,\ldots,n-1\}$。任何其它我们想要和$V$中元素关联的数据我们都可以存放到一个长度为$n$的数组中。

对图某些典型的操作有：
* `addEdge(i,j)`：增加一个边$edge(i,j)$到$E$中。
* `removeEdge(i,j)`：从$E$中删除一个边$edge(i,j)$。
* `hasEdge(i,j)`：检测是否$edge(i,j)\in E$。
* `outEdges(i)`：返回所有满足$(i,j)\in E$的整数$j$列表。
* `inEdges(i)`：返回所有满足$(j,i)\in E$的整数$j$列表。

注意到这些操作的高效实现不难实现。例如，头三个操作可以使用`USet`实现，这样就可以使用第五章描述的哈希表以常量期望时间实现它们。后两个操作可以通过存储每个顶点的邻接顶点列表以常量时间实现。

然而，图的不同应用对这些操作有着不同的性能要求，并且，理想情况下，我们可以使用最简单的实现满足所有这些应用的要求。针对这个原因，我们将讨论两类图的表示。

### 12.1 `AdjacencyMatrix`：使用矩阵表示一个图
_邻接矩阵(adjacency matrix)_ 是通过使用一个$n\times n$的矩阵(每个元素是一个布尔值)表示一个包含了$n$个顶点的图的$G=(V,E)$方式。
```Java
int n;
boolean[][] a;
AdjacencyMatrix(int n0){
    n = n0;
    a = new boolean[n][n];
}
```
