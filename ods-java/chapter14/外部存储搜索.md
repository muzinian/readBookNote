## 外部存储搜索
遍及本书，我们使用的都是1.4节介绍的`w`bit字RAM计算模型。这个模型的一个隐含假设是我们的计算机有足够大的随机访问内存可以存储数据结构中的所有数据。在某些情况下，这个假设是不存在的。存在特别大的数据集合以至于没有计算机有足够内存可以容纳它们。在这些情况中，应用必须要重新排序数据从而存储在某些外部存储介质例如硬盘，固态硬盘甚至是网络文件服务(他有自己的外部存储)。

从外部存储中访问一个元素是十分慢的。编写本书使用的计算机挂载的硬盘平均访问时间是19ms，这个计算机挂载的固态硬盘平均访问时间是0.3ms。相对的，这个计算机的随机访问内存的平均访问时间少于0.000113ms。访问RAM要比访问固态硬盘快不止2500倍，比硬盘要快不止160000倍。

这些速度相当典型：访问RAM的一个随机字节要比访问硬盘或者固态硬盘一个随机字节快数千倍。然而，访问时间并没有告诉我们整个事情。当我们从硬盘或者固态硬盘中访问一个字节时，硬盘的整个 _块(block)_ 都被读取了。这个计算机挂载的每个硬盘驱动块大小都是4096(个字节)；每次我们读取一个字节，驱动就给我们一个包含4096个字节的块。如果我们仔细组织我们的数据结构，这意味着每次硬盘访问都可以产生4096字节，这对完成我们正在做的操作(无论什么操作)很有帮助。

这就是计算的 _外部存储模型(external memory model)_ 背后的概念，图14.1介绍了这个概念。在这个模型中，计算机已经访问了它所有数据存在的大外部存储。这个存储被分为多个存储 _块(block)_，每个块包含$B$个字。这个计算机还有有限的内部存储，它可以执行计算。在内部存储和外部存储之间传输一个块的时间是固定的。在内部存储中执行计算是 _免费的_，他不花费任何时间。内部存储计算是免费的这一事实看起来有一点奇怪，但是它简单的强调了外部存储比RAM慢很多这一事实。

![figure14.1.png "在外部内存模型中，访问一个独立条目x，在外部存储中要求访问包含了x的整个块到RAM中"](figure14.1.png "在外部内存模型中，访问一个独立条目x，在外部存储中要求访问包含了x的整个块到RAM中")

在一个成熟的外部存储模型中，内部存储的大小也是一个参数。然而，对于本章描述的数据结构，内部存储大小是$O(B+\log_B n)$就足够了。也就是说，内存需要可以容纳常量数量的块以及高度为$O(\log_B n)$d的递归栈。在大多数情况中，$O(B)$部分决定了内存需求。例如，尽管有着相对较小的值$B=32$，对于所有$n\le 2^{160}$的$n$来说，$B\ge \log_B n$。对于十进制来说，$B\ge \log_B n$对于任意:
$$n\le 1461501637330902918203684832716283019655932542976$$

### 14.1 块存储
外部存储的概念包括了大量各种设备，它们都有自己的块大小并且我们要使用它们自己拥有的系统调用集合才能访问。为了简化本章的概述关注于共通的想法，我们使用一个叫做`BlockStore`的对象封装了外部存储设备。`BlockStore`存放了外部存储块的集合，每个块大小是$B$。每个块通过它的整数索引被唯一标识。`BlockStore`支持这些操作：
1. `readBlock(i)`：返回索引`i`的块内容；
2. `writeBlock(i,b)`：写入内容`b`到索引是`i`的块中；
3. `placeBlock(b)`：返回一个新的索引并在这个索引处存放`b`的内容；
4. `freeBlock(i)`：释放索引是`i`的块。这意味着这个块的内容不再使用，分配给这个块的外部存储可以被重用。

想象`BlockStore`最简单的方式是想象是存在硬盘上的一个文件，被分为了几个块，每个块包含$B$个字节。按照这种方式，`readBlock(i)`和`writeBlock(i,b)`就是简单的读和写这个文件的$iB,\ldots,(i+1)B-1$字节。另外，一个简单的`BlockStore`可以保持一个可用块的 _空闲列表(free list)_。通过`freeBlock(i)`释放的块被添加到空闲列表中。按照这种方式，`plackBlock(b)`可以从空闲列表中使用一个块，后者，如果没有可用的，就在文件结尾追加一个新块。

### 14.2 B-Trees
本节，我们讨论了二叉树的一个泛化版本，叫做B树，在外部存储模型中十分高效。换一种方式，B树可以看作是9.1节描述的2-4树的自然泛化(2-4树是B树的一个特别例子，当我们设置$B=2$时可以得到)。

对于任意整数$B\le 2$，_B树_ 是一个树，它的所有叶子都有同样的深度并且所有非根内部节点`u`至少$B$个孩子至多$2B$个孩子。`u`的孩子存储在一个数组中，`u.children`。根节点对孩子个数的要求被放宽了，范围可以是2到$2B$中的任意一个。

如果B树的高度是$h$，跟着它的在B树内的叶子数量$\ell$满足：
$$2B^{h-1}\le \ell \le 2(2B)^{h-1}$$
对第一个不等式取对数并重新排列式子产生：
$$\begin{aligned}
    h&\le \frac{\log \ell -1}{\log B}+1\\
    &\le \frac{\log \ell}{\log B}+1 \\
    &=\log_B\ell+1
\end{aligned}$$
也就是说，B树的高度正比于以$B$为底叶子个数的对数。

B树中每个节点`u`存储了键$u.keys[0],\ldots,u.keys[2B-1]$的数组。如果`u`是一个有着$k$个孩子的内部节点，那么在`u`存储的键个数就是精确的$k-1$，分别存放在$u.keys[0],\ldots,u.keys[k-2]$中。$u.keys$中剩下$2B-k+1$个数组条目都设置为`null`。如果`u`不是根的叶子节点，那么`u`包含的键个数范围是$B-1$到$2B-1$。B树中键遵从类似二叉搜索树中键的顺序。对任意节点`u`，他存储$k-1$个键，
$$u.keys[0]\lt u.keys[1]\lt \cdots \lt u.keys[k-2]$$
如果`u`是一个内部节点，那么对于每个$i\in\{0,\ldots,k-2\}$，$u.keys[i]$比存储在以$u.children[i]$为根的子树的所有键都要大，但是比存储在以$u.children[i+1]$为根的子树中所有键都小。非正式的说：
$$u.children[i]\prec u.keys[i] \prec u.children[i+1]$$

图14.2中展示了$B=2$的B树例子。

![figure14.2.png "B=2的B树例子"](figure14.2.png "B=2的B树例子")

注意存在B树节点中的数据大小$O(B)$。因此，在一个外部存储设置中，B树中$B$值的选择满足一个节点可以填入到单个外部存储块中。使用这种方式，在外部存储模型中执行B树操作花费的时间正比于这个操作正在访问(读或者写)的节点数量。

举个例子，如果键是一个4字节的整数并且这个节点的索引也是4个字节，那么设置$B=256$意味着每个节点存储
$$(4+4)\times 2B = 8\times 512 = 4096$$
个字节数据。对于本章前面讨论过的硬盘或者固态硬盘来说，这个$B$值是一个完美的值，因为它们的块大小是4096个字节。

`BTree`类实现了B树，存储了一个`BlockStore`，`bs`，后者存放了`BTree`节点以及根节点的索引`ri`。和平常一样，整数`n`用来跟踪这个数据结构中数据的个数：
```Java
int n;
BlockStore<Node> bs;
int ri;
```
