## 红黑树
本章，我们呈现红黑树，一个对数(logarithmic)高度的二叉搜索树版本。红黑树是使用最广泛的一个数据结构。它们在很多库实现中作为主要的搜索结构出现，包括了Java集合框架和C++STL(Standard Template Library)的几种实现。它们也用在了Linux操作系统内核中。红黑树的流行有几个原因：
1. 存储了`n`个值的红黑树高度最多是$2\log n$。
2. 红黑树的`add(x)`和`remove(x)`操作 _最差(worst-case)_ 运行时间是$O(\log n)$。
3. 在执行`add(x)`和`remove(x)`操作期间执行旋转的摊还数量是常量。
这些属性的前两个已经让红黑树排在了跳表，替罪羊树和treaps前了。跳表和treaps依赖于随机性并且它们的`O(\log n)`运行时间只是期望的。替罪羊树对它的高度有一个保证的界限，但是`add(x)`和`remove(x)`只是运行在$O(\log n)$的摊还时间。第三个属性是锦上添花。它告诉我们添加或者删除一个元素`x`所需的时间相比于找到`x`需要的时间要小很多。[<sup id="content1">1</sup>](#1)

然而，红黑树漂亮的属性是由代价的：实现复杂度。维护界限为$2\log n$的高度很不容易。他要求仔细的分析几种情况。我们必须保证这个实现在每种情况下都做正确的事情。一次错误放置的旋转或者颜色改变产生的bug难以理解并解决。

相比直接陷入到红黑树的实现中，我们先提供一个相关数据结构的一些背景：2-4树。对于红黑树是怎么被发现以及为什么高效维护它们是可能的，这个结构会给出一些提示。

### 9.1 2-4树
2-4树是一个有根树，有如下属性：
__属性9.1__(高度)。所有叶子都有一样的深度。
__属性9.2__(度)。每个节点包含2，3或者4个孩子。

图9.1中显示2-4树的例子。2-4树的属性意味着它的高度是叶子个数的对数(The properties of 2-4 trees imply that their height is logarithmic in the number of leaves)：

![figure9.1.png ""](figure9.1.png "高度为3的2-4树")

__引理9.1.__ `n`个叶子节点的2-4树高度最多是$\log n$。
__证明__ 一个内部节点孩子个数的下界为2意味着如果一个2-4树高度是$h$，那么他至少有$2^h$个叶子。换句话说，
$$n\ge 2^h$$
对不等式两边取对数得到$h\le \log n$。

#### 9.1.1 添加一个叶子
在2-4树中添加一个页子节点很容易(参见图9.2)。如果我们想要添加一个叶子节点`u`给某个节点`w`作为孩子节点，那么我们简单的把`u`变成`w`的孩子节点就可以了。这肯定维护了高度的属性，但是可能会违反度(degree)的属性；如果在添加`u`前`w`已经有了4个孩子，那么`w`现在就有了5个孩子了。此时，我们把`w`分成两个节点，`w`和`w'`，分别有两个和三个孩子。但是现在`w'`没有父节点，所以我们递归地让`w`的父节点做为`w'`的父节点。再一次，这可能会导致`w`的父节点有太多的孩子，此时我们就要分裂它。这个过程会一直持续下去直到我们到达某个节点的孩子少于4个，或者我们分裂了根节点`r`为两个节点`r`和`r'`。在后一种情况中，我们创建一个新的节点作为根，同时`r`和`r'`作为它的孩子。这同时增加了所有叶节点的深度因此维护了高度属性。

由于2-4树的高度从不会超过$\log n$，添加一个叶子的过程最多在$\log n$步后结束。

![figure9.2.png "2-4树增加一个叶子节点。这个过程会在某一分裂后停止，因为在添加前w.parent的度小于4"](figure9.2.png "2-4树增加一个叶子节点。这个过程会在某一分裂后停止，因为在添加前w.parent的度小于4")

#### 9.1.2 删除一个叶子
从2-4树中删除一个叶子节点就稍微麻烦了些(参见图9.3)。为了从节点`u`的父节点`w`中删除节点`u`，我们直接删除。如果`w`在执行对`u`删除操作前只有两个孩子，那么`w`在删除操作后只留下一个孩子从而违反了度属性。

为了修正这个，我们看下`w`的兄弟节点`w'`。节点`w'`肯定存在，因为`w`的父节点至少有两个孩子。如果`w'`有三个或者四个孩子，我们从`w'`的这些孩子中拿出一个给`w`。现在`w`有两个孩子，而`w'`有两个或者三个节点，我们的工作做完了。

另一方面，如果`w'`只有两个孩子，那么我们 _合并_ `w`和`w'`为单个节点，`w`，这就有三个孩子。下一步我们递归地从`w'`的父节点中删除`w'`。当我们到达一个节点`u`，`u`或者它的兄弟节点超过2个孩子，又或者当我们到达了根节点时，这个过程才结束。在后一个例子中，如果根剩下一个孩子，那么我们删除根节点并让他的孩子为新的节点。再一次，这同时降低了所有叶子节点的高度从而维护了高度属性。

再一次，因为树的高度从没有超过$\log n$，删除一个叶子的过程最多在`\log n`步后结束。

![figure9.3.png "从2-4树中删除一个节点。这个过程会一直走到根节点因为u的所有先祖以及它的兄弟都只有两个孩子"](figure9.3.png "从2-4树中删除一个节点。这个过程会一直走到根节点因为u的所有先祖以及它的兄弟都只有两个孩子")

### 9.2 RedBlackTree:一个模拟2-4树
红黑树是一个二叉搜索树其中每个节点`u`都有一个 _颜色(colour)_：要么是 _红(red)_ 或者是 _黑(black)_。值0表示红色而值1表示黑。
```Java
class Node<T> extends BSTNode<Node<T>,T>{
    byte colour;
}
```
在红黑树任何操作前后，下面的两个属性都会被满足。每个属性都是按照颜色红和黑以及数值0和1定义的。

__属性9.3__(黑色高度(black-height)) 从根到每个叶子的路径上黑色节点个数是一样的。(任意一个从根到叶子路径颜色的和是一样的。)
__属性9.4__(没有的红色边(no-red-edge)) 不存在两个相邻的红色节点。(对于任何一个节点`u`，除了根节点，$\text{u.colour+u.parent.colour}\ge 1$)

注意我们可以总是对红黑树的根节点`r`着黑色而不违反这两个属性，所以我们将假设根是黑色的，而更新红黑树的算法会维护整个假设。另一个简化红黑树的技巧是把外部节点(通过`nil`表示)看作是黑色的。使用这种方式，红黑树的每个真实节点`u`都精确的拥有两个孩子，每个孩子的颜色都是定义好的。图9.4显示了一个红黑树的例子。

![figure9.4.png "黑色高度为3的红黑树例子。外部节点(nil)用黑色方块表示"](figure9.4.png "黑色高度为3的红黑树例子。外部节点(nil)用黑色方块表示")

#### 9.2.1 红黑树和2-4树
刚开始看到红黑树可以高效的更新并维护黑色高度以及没有红色边属性可能会让你惊讶，并且甚至也不容易看出来这些性质是有用的。然而，红黑树是按照以二叉树的方法高效模拟2-4树而设计的。

参考图9.5。考虑任意一个红黑树`T`，包含`n`个节点并执行如下转换：删除每一个红色几点`u`并把`u`的两个孩子节点直接连到`u`的(黑色)父节点。转换后剩下的树`T'`就只有黑色节点。

![figure9.5.png "每个红黑树都与之对应的2-4树"]

`T'`中每个内部节点都由2，3或者4个孩子：开始有两个黑色节点孩子的黑色节点在转换后依旧只有两个黑色孩子。开始有一个黑色节点孩子和红色节点孩子的黑色节点在转换后就有三个孩子了。有两个红色节点孩子的黑色节点在转换后就有4个孩子了。进一步的，黑色高度属性现在保证了`T'`中所有从根到叶的路径长度都一样。换句话说，`T'`是一个2-4树！

2-4树`T'`中$n+1$($n$是红黑树real nodes的个数)个叶子，对应到红黑树中$n+1$(红黑树是二叉树，二叉树的属性有一个就是，$n$个real nodes包含$n+1$个external nodes)个外部节点。因此，这个树的高度最多是$\log(n+1)$。现在，2-4树每条从根到叶子的路径都对应到红黑树中一条从根到外部节点的路径。在这个路径上第一个和最后一个节点是黑色的并且每两个内部节点中最多有一个是红色的，因此这个路径上最多有$\log(n+1)$个黑色节点以及最多有$\log(n+1)-1$个红色节点。因此，`T`中从根到任意 _内部节点(internal node)_ 最长路径满足对于任意$n\ge 1$最多是：
$$2\log(n+1)-2\le 2\log n$$
这证明了红黑树最重要的属性：
__引理9.2.__ `n`个节点的红黑树高度最多是$2\log n$

现在我们看到了2-4树和红黑树的关系，就不难相信我们可以在添加和删除元素过程中高效的维护红黑树。

我们已经看到了在`BinarySearchTree`中添加一个元素可以通过添加一个新的叶子节点完成。因此，为了实现红黑树中的`add(x)`我们需要一个方法模拟2-4树中分裂一个有5个孩子的节点。一个2-4树中有5个孩子的节点被表示为一个有者两个红色节点孩子的黑色节点，这两个红色节点孩子其中还有一个有红色孩子。我们可以通过把这个节点染成红色并把它的两个孩子染成黑色来"分裂"这个节点。图9.6展示了这个例子。

![figure9.6.png "在红黑树中执行添加操作时模拟2-4树分裂操作(这模拟了图9.2中展示的2-4树添加操作)"](figure9.6.png "在红黑树中执行添加操作时模拟2-4树分裂操作(这模拟了图9.2中展示的2-4树添加操作)")

类似的，实现`remove(x)`需要一个方法合并两个节点并从兄弟节点借一个孩子。合并两个节点是分裂的相反操作(图9.6展示的)，并且设计到对两个)(黑色)兄弟节点染成红色并对他们的父节点(红色)染成黑色。从兄弟节点借用节点是车个过程最复杂的部分并且设计到旋转和重新着色节点。

当然，在所有这些操作期间我们必须要一直维护没有红色边属性和黑色节点高度属性。尽管我们不会惊讶这可以办到，但是如果我们尝试通过红黑树直接模拟2-4树依旧有大量的边界情况必须要考虑。在某些时刻，忽略底层的2-4树直接维护红黑树的特性会让这些变得简单些。

#### 9.2.2 左倾向的红黑树(Left-Leaning Red-Black Trees)
不存在单一的红黑树定义。相反，有一个家族的结构在`add(x)`和`remove(x)`操作过程中管理维护黑色高度和没有红色边的属性。不同的结构使用不同的方式。这里，我们实现了一个我们成为`RedBlackTree`的数据结构。这个结构实现了一个红黑树的特别变体，满足了额外的属性：
__属性9.5.__(左倾向) 对于任意节点`u`，如果`u.left`是黑色的，那么`u.right`也是黑色的

注意图9.4展示的红黑树是不满足左倾向属性的；在她最右边的路径上红色节点的父节点违反了这个属性。

维护左倾向属性的原因是它减少了在`add(x)`和`remove(x)`操作期间会遇到的情况。用2-4树来说，它意味着每个2-4树只有唯一的表示：度为2的节点变成一个有着两个黑色节点孩子的黑色节点。一个度为3的节点变为一个左孩子是红色右孩子是黑色的黑色节点。度为4的节点变成一个有两个红色孩子节点的黑色节点。

在我们详细描述`add(x)`和`remove(x)`实现前，我们现在图9.7中展示这些方法会使用到的几个简单例程。开始的两个例程是用来操作颜色从而保护黑色高度属性。`pushBlack(u)`方法用一个有着两个红色孩子节点的黑色节点`u`作为入参，然后将`u`着红色，将它的两个孩子着黑色。`pullBlack(u)`是这个操作的反操作：

![figure9.7.png "翻转，拉和退"](figure9.7.png "翻转，拉和退")

```Java
void pushBlack(Node<T> u){
    u.colour--;
    u.left.colour++;
    u.right.colour++;
}
void pullBlack(Node<T> u){
    u.colour++;
    u.left.colour--;
    u.right.colour--;
}
```
`flipLeft(u)`方法会交换`u`和`u.right`的颜色，然后在`u`处执行一次左旋转。这个方法反转了这两个节点的颜色以及父子关系：
```Java
void flipLeft(u){
    swapColors(u,u.right);
    rotateLeft(u);
}
```
`flipLeft(u)`操作在恢复违反了左倾向属性的节点`u`时很有用(因为`u.left`是黑色而`u.right`是红色)。在这种特定情况下，我们可以确信这个操作保护了黑色高度和无红色边属性。`flipRight(u)`操作和`flipLeft(u)`是对称的，当左和有的角色调整时：
```Java
void flipRight(u){
    swapColors(u,u.left);
    rotateRight(u);
}
```
```Java
protected void swapColors(Node<T> u, Node<T> w) {
	byte tmp = u.colour;
	u.colour = w.colour;
	w.colour = tmp;
}
```
#### 9.2.3 添加
为了实现`RedBlackTree`的`add(x)`操作，我们执行标准的`BinarySearchTree`插入操作新增一个叶子节点`u`，有`u.x = x`并设置`u.colour=red`。注意到这不会修改任意节点的黑色高度，所以它不会违反黑色高度属性。然而， 他可能左倾向属性(如果`u`它父节点的右孩子)，并且它也可能违反无红色边属性(如果`u`的父节点是`red`)。为了恢复这些属性，我们可以调用方法`addFixup(u)`。
```Java
boolean add(T x){
    Node<T> u = newNode(x);
    u.colour = red;
    boolean  added = add(u);
    if(added)addFixup(u);
    return added;
}
```
正如图9.8展示的，`addFixup(u)`接受一个颜色是`red`节点`u`的作为参数，他可能违反了无红色边属性且/或左倾向属性。如果没有参考图9.8或者重新在一页纸上绘制，下面的讨论大概率无法被理解。事实上，我们希望读者在继续前先学习这个图片。

![figure9.8.png "在一次插入后为了修复属性2执行的过程中一轮"](figure9.8.png "在一次插入后为了修复属性2执行的过程中一轮")

如果`u`是树的根，那么我们可以把`u`着成黑色从而恢复所有属性。如果`u`的兄弟也是红的，那么`u`的父节点就必定是黑色的，因此所有属性都已经保持了。

否则，我们先判断`u`的父节点`w`是否违反了左倾向属性，如果是，就执行一次`flipLeft(w)`操作然后设置`u = w`。这样执行后我们就得到一个良好定义的状态了：`u`是它父节点`w`的左孩子，并且`w`现在满足左倾向属性。剩下的就是保证`u`节点的没有红色边属性。我们唯一需要担心的就是`w`是红色这种情况，否则`u`已经满足了非红色边属性。

因为我们还没有完成`u`是红色且`w`是红色的情况。没有红色边属性(这意味着`u`违反了但是`w`没有违反)意味着`u`的祖父节点`g`存在并且是黑色的。如果`g`的右孩子是红色的，那么左倾向属性保证了`g`的两个孩子都是红色的，因此调用`pushBack(g)`让`g`边红而让`w`边黑。这在节点`u`处恢复了没有红色边属性，但是可能会导致在`g`处违反，因此，整个过程重新以`u=g`开始。()

如果`g`的右孩子是黑色，那么调用`flipRight(g)`让`w`成为`g`的(黑色)父节点并设置`u`和`g`为它的两个红色儿子。这保证了`u`满足非红色边属性并且`g`满足左倾向属性。在这种情况下我们可以停止了。
```Java
void addFixup(Node<T> u){
    while(u.colour == red){
        if(u == r){//u是根节点--结束
            u.colour = black;
            return;
        }
        Node<T> w = u.parent;
        if(w.left.colour == black){//保证左倾向
            flipLeft(w);
            u = w;
            w = u.parent;
        }
        if(w.colour == black)return//没有红色边 -- 完成
        Node<T> g = w.parent;//u的祖父节点
        if(g.right.colour == black){
            flipRight(g);
            return;
        }else{
            pushBlack(g);
            u=g;
        }
    }
}
```
`addFixup(u)`方法每次迭代会花费常量的时间而且每次迭代要么结束，要么将`u`进一步的移动到根。因此，`addFixup(u)`方法在$O(\log n)$次迭代后结束花费$O(\log n)$的时间。

#### 9.2.4 删除操作
`RedBlackTree`的`remove(x)`操作实现起来最复杂，这对于所有红黑树变体都一样。就像`BinarySearchTree`中的`remove(x)`操作那样，这个操作归根到底就是找到只有一个孩子节点`u`的节点`w`，然后把`w`从树中分离出来并让`w.parent`领养`u`。

这样做的问题是，如果`w`是黑色，那么黑色高度属性就会在`w.parent`上被违反。我们可以通过将`w.colour`加到`u.colour`上解决临时的这个问题。当然，这引入了其它两个问题：(1)如果`u`和`w`本身都是黑色，那么`u.colour+w.colour=2`(双黑色)，这个颜色无效。如果`w`是红色，那么它可以被一个黑色节点`u`替换，但是可能会在`u.parent`上违反左倾向属性。这些问题都可以通过调用`removeFixup(u)`方法解决。
```Java
boolean remove(T x){
    Node<T> u = findLast(x);
    if(u==nil||compare(u.x,x)！=0) return false;
    Node<T> w = u.right;
    if(w == nil){
        w = u;
        u = w.left;
    }else{
        ////查询比u大的最小节点，这里隐含了一个条件，就是这个节点必然最多只有一个右孩子
        while(w.left != nil){
            w = w.left;
        }
        u.x = w.x;
        u = w.right;
    }
    splice(w);
    //这里不对u进行判空操作的原因是RedBlackTree的初始化会给每个节点的左右孩子设置为一个nil的空节点并设置颜色为黑色
    u.colour += w.colour;
    u.parent = w.parent;
    removeFixup(u);
    return true;
}
```
`removeFixup(u)`方法接受一个节点颜色是黑色(1)或者双黑色(double-black)(2)作为参数。如果`u`是双黑色，那么`removeFixup(u)`会执行一系列的旋转与重着色操作向上移动双黑色节点知道可以消除它。在这个过程期间，节点`u`会一直改变，在过程结束时，`u`涉及到到子树的根都被修改了。这个子树的根可能会改变颜色了。具体地说，他可能从红变成黑色，这样`removeFixup(u)`方法最后结束前检查`u`的父节点是否违反了左倾向属性，如果违反了，就修复它。
```Java
void removeFixup(Node<T> u){
    while(u.colour > black){
        if(u == r){
            u.colour = black;
        }else if(u.parent.left.colour == red){
            u = removeFixupCase1(u);
        }else if(u == u.parent.left){
            u = removeFixupCase2(u);
        }else{
            u = removeFixupCase3(u);
        }
    }
    if(u != r){//如果必要，恢复左倾向属性
        Node<T> w = u.parent;
        if(w.right.colour == red&&w.left.colour == black){
            flipLeft(w);
        }
    }
}
```
![figure9.9.png "一次删除后消除双黑色节点过程中的一轮"](figure9.9.png "一次删除后消除双黑色节点过程中的一轮")

图9.9展示了`removeFixup(u)`方法。再一次，如果不引用图9.9，下面的讨论，即使不是不可能，也是非常难于理解的。在`removeFixup(u)`过程中循环的每一次迭代，双黑色节点`u`都处于四种情况中的一个：
情况0：`u`是根节点。这种情况最容易处理。我们重新对`u`着黑色(这不会违反任何红黑树性质)。
情况1：`u`的兄弟`v`是红色。在这种情况下，`u`的兄弟是它父节点`w`的左孩子(根据左倾向性质)。我们在`w`处执行一次右翻转然后进行到下一次迭代中。注意到这个操作会导致`w`的父节点违反左倾向属性并且`u`的深度也会增加。然而，它也意味着会变成情况3(因为`w`是红色的)。下面讨论情况3的时候，我们会看到这个过程会在下一次迭代时结束。
```Java
Node<T> removeFixupCase1(Node<T> u){
    flipRight(u.parent);
    return u;
}
```
情况2：`u`的兄弟`v`是黑色，并且`u`是父节点`w`的左孩子。在这种情况下，我们可以执行`pullBlack(w)`，让`u`变成黑色(注：`u`是double-black，`pullBlack(w)`会对`w`的颜色加一，`u`和`v`的颜色减一。这样，`u`就是1，`v`是0，`w`可能是1，可能是2)，`v`是红色，把`w`的颜色改成黑色或者双黑色。此时，`w`就不满足左倾向属性了，因此，我们调用`flipLeft(w)`修复它。

修复后，此时，`w`是红色，而`v`是我们开始的子树的根。我们需要检测`w`是否会违反没有红色边属性。我们通过检测`w`的右孩子`q`来判断。如果`q`是黑色，那么`w`满足没有红色边属性，进而我们携着`u=v`进入下一次迭代。

否则(`q`是红色)，那么`q`和`w`分别违反了没有红色边属性和左倾向属性。通过调用`rotateLeft(w)`可以恢复左倾向属性，但是没有红色边属性还是违反了。此时，`q`是`v`的左孩子，`w`是`q`的左孩子，`q`和`w`都是红色，而`v`黑色或者双黑色。`flipRight(v)`让`q`成为`v`和`w`的父节点。继续通过调用一次`pushBlack(q)`让`v`和`w`都变成黑色并设置`q`的颜色变成`w`原来的颜色。

此时，双黑色节点被消除了，并且没有红色边和黑色高度属性也被重建了。只留下一个可能的问题：`v`的右孩子可能是红色的，此时违反了左倾向原则。我们会检测这个，如果需要，执行一次`flipLeft(v)`纠正它。
```Java
Node<T> removeFixupCase2(Node<T> u){
    Node<T> w = u.parent;
    Node<T> v = w.right;
    pullBlack(w);//w.left
    flipLeft(w);//w现在是红色的
    Node<T> q = w.right;
    if(q.colour == red){//q-w 是红-红
        rotateLeft(w);
        flipRight(v);
        pushBlack(q);
        if(v.right.colour == red){
            flipLeft(v);
        }
        return q;
    }else{
        return v;
    }
}
```
情况3：`u`的兄弟是黑色的，且`u`是它父节点`w`的右孩子。它和情况2是对称的并且处理方式几乎是一样的。唯一不同之处来自于这个事实：左倾向属性是不对称的(asymmetric)，所以它修稿不同的处理方式。

就像前面那样，我们以调用`pullBlack(w)`开始，这会让`v`变红`u`变黑。调用`flipRight(w)`会提升`v`为这个子树的根。此时，`w`是红色的，代码会根据`w`左孩子`q`的颜色进行不同的处理。

如果`q`是红色的， 那么代码就和情况2的结束方式完全一样，甚至更简单，因为没有`v`不满足左倾向属性的危险。

当`q`是黑色的时候，情况更复杂。在这种情况下，我们检查`v`的左孩子的颜色。如果它是红色的，那么`v`有两个红色孩子，而它的额外的黑色可以通过`pushBlack(v)`下推下去。此时，`v`现在的颜色是`w`开始的颜色，我们的操作就完成了。

如果`v`的左孩子是黑色的，那么`v`违反了左倾向属性，我们通过调用`flipLeft(v)`会这个。然后我们返回节点`v`，这样`removeFixup(u)`下一次就会以`u=v`继续。
```Java
Node<T> removeFixupCase3(Node<T> u){
    Node<T> w = u.parent;
    Node<T> v = w.left;
    pullBlack(w);
    flipRight(w);//w 现在是红色
    Node<T> q = w.left;
    if(q.colour == red){//q-w 是红-红
        rotateRight(w);
        flipLeft(v);
        pushBlack(q);
        return q;
    }else{
        if(v.left.colour == red){
            pushBlack(v);//v的两个孩子都是红色的
            return v;
        }else{//保证左倾向
            flipLeft(v);
            return w;
        }
    }
}
```
`removeFixup(u)`的每次迭代花费的都是常量时间。情况2和3要么结束要么让`u`更接近树的根。情况0(`u`是根)总是会结束而情况1会立即变成情况3，这也会结束。因此树的高度最多是$2\log n$，我们可以推导出`removeFixup(u)`的迭代次数最多是$O(\log n)$，因此，`removeFixup(u)`运行时间是$O(\log n)$。

### 9.3 总结
如下定理总结了`RedBlackTree`数据结构的性能：
__定理9.1__ `RedBlackTree`实现了`SSet`接口并支持最差情况$O(\log n)$的`add(x)`，`remove(x)`和`find(x)`操作。

没有包含在上述定理内还有如下额外红利：
__定理9.2__ 从一个空的`RedBlackTree`开始，任意`m`个序列`add(x)`和`remove(x)`操作会一共花费$O(m)$的时间用于所有`addFixup(u)`和`removeFixup(u)`调用的开销。

我们仅仅简略描述一下定理9.2的证明。通过比较在2-4树中添加/删除一个叶节点算法中的`addFixup(u)`和`removeFixup(u)`，可以方便我们讨论这个从2-4树中继承的属性。具体地说，如果我们可以证明在2-4树中花费在分裂，合并和借用的总时间是$O(m)$，那么就推出来了定理9.2。

对于2-4树这个定理的证明使用了摊还分析的势能方法。[<sup id="content2">2</sup>](#2)定义2-4树一个内部节点`u`的势能为：
$$\Phi(u)=\begin{cases}
    &1\text{ 如果u有2个孩子}\\
    &0\text{ 如果u有3个孩子}\\
    &3\text{ 如果u有4个孩子}\\
\end{cases}$$
而2-4树的势能是它的节点势能之和。当发生一次分裂，是因为一个包含4个孩子的节点变为两个节点，分别有两个和三个孩子。这意味着整个的势能降低了$3-1-0=2$。当发生了合并，两个之前有两个孩子的节点被一个有三个孩子的节点替换了。结果就是势能的下降了是$2-0=2$。因此，对于每个分裂或者合并，势能减少了2个。

下一个注意到的，如果我们忽略节点的分裂和合并，只有常量数量的节点由于增加或者删除一个叶子改变了孩子个数。当添加一个节点，一个节点的孩子个数就加一，势能最多增加3。在删除一个叶子节点过程中，节点的孩子个数减一，势能最多增加1，而在借用操作中会涉及到两个节点，它们的势能和最多增加1。

总结一下，每次合并和分裂导致势能减少至少2。忽略合并和分类，每个增加或者删除导致势能最多增加3，因此势能总是非负的。因此，对一个初始为空树进行`m`次增加或删除导致的分裂合并个数最多是$3m/2$。定理9.2是这个分析的推论，并且在2-4树和红黑树中是一致的。

### 9.4 讨论和联系
红黑树最开始是由Guibas和Sedgewick引入的。尽管它们的实现复杂度很高，但是它们在最常使用的库和应用中被使用了。大多数算法和数据结构书籍都讨论某种红黑树的变体。

Andersson描述平衡树的一个做倾向版本，它类似与红黑树但是有额外的约束，即每个节点最多有一个红色孩子。这意味着模拟的是2-3树而不是2-4树。它们显然比本章中的`RedBlackTree`更简单。

Sedgewick描述了两种左倾向的红黑树版本。它们使用了递归和对2-4树中从顶到底分裂和合并的模拟。这两个技术的结合是的代码简短优雅。

一个相关但是更老的数据结构是 _AVL树_。AVL树是 _高度平衡的(height-balanced)_：对于每个节点`u`，以`u.left`为根的子树高度和以`u.right`为根的子树高度差别最多是1。立即可以得到的是，如果$F(h)$是高度为$h$的树中最小的叶数量(if $F(h)$ is the minimum number of leaves in a tree of height $h$)，那么$F(h)$遵循斐波那契循环：
$$F(h)=F(h-1)+F(h-2)$$
基本情况是$F(0)=1$且$F(1)=1$。这意味着$F(h)$约等于$\varphi^h/\sqrt{5}$，其中$\varphi=(1+\sqrt{5})/2\approx 1.61803399$是 _黄金分割率(golden ratio)_。(更精确的说，$|\varphi^h/\sqrt{5}-F(h)|\le 1/2$。)由引理9.1知道，这意味着：
$$h\le \log_{\varphi}n\approx 1.440420088\log n$$
因此，AVL树的高度比红黑树小。在`add(x)`和`remove(x)`操作期间通过反向沿着路径向上走到根并对每个左右子树高度差为2的节点`u`执行冲平衡操作而维护高度平衡属性。参见图9.10。

Andersson的红黑树变体，Sedgewick的红黑树变体以及AVL树都比这里定义的`RedBlackTree`结构容易实现。不幸的是，它们都无法保证花费每次更新时在重平衡上的摊还时间开销是$O(1)$的。具体地说，这些结构没有定理9.2的类似等价物。

[<sup id="1">1</sup>](#content1) 注意跳表和treaps在期望意义下也有这个属性。参见练习4.6和练习7.5。
[<sup id="2">2</sup>](#content2) 参考引理2.2和3.1对势能方法其他应用的证明。