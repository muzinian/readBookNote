## 插曲：文件和目录
到目前位置，我们看到了两个关键的操作系统抽象：进程--对CPU的虚拟化；地址空间--对内存的虚拟化。这两个抽象一起允许程序可以运行，好像是在自己私有，隔离的世界；好像它自己有一个处理器(或多个处理器)；好像它有自己的内存。这种幻想让针对系统编程变得更容易因此它不仅仅普遍存在于桌面和服务器端，在所有可编程平台，包括移动手机等等，都快速增长。

在这个部分，我们又增加了一个虚拟化问题的关键点：__持久化存储(persistent storage)__。一个持久化存储设备，例如典型的 __硬盘驱动器(hard disk drive)__ 或者更现代的 __固态存储设备(solid-state storage device)__，永久化的存放信息(或者至少，很长一段时间)。不想内存那样，内存的内容在掉电后就会丢失，一个持久化存储设备会保持数据完整无损。因次，OS必须额外仔细对待这种设备：这里是用户存放他们所关心数据的地方。
>#### 症结：如何管理持久化设备
>OS如何管理持久化设备？API是什么？实现上重要的方面是什么？

因此，在接下来的几个章节中，我们会考察那些管理持久化数据的关键技术，关注于提升性能和可靠性的方法上。然而，我们先以对API的概览做开始：这些接口是你在与类UNIX系统交互时想要看到的。

### 39.1 文件和目录
随着时间的推移，在对存储设备的虚拟化中开发出了两种关键抽象。第一个是 __文件(file)__。一个文件就是一个线性的字节数组，每个字节你都可以读写。每个文件都由某种 __底层名字(low-level name)__，通常是某种数字；通常，用户不会意识到这个名字(我们将看到)。由于历史原因，一个文件的底层名字叫做它的 __inode号(inode number)__。在后面的章节，我们将学习更多关于inodes的知识；现在，我们就假设每个文件都一个inode号和它关联。

在大多数系统中，OS对文件的结构知道的不多(例如，他是不是一个图片，后者文本或者C代码)；相反，文件系统的责任就是简单的在硬盘上持久化这些数据并确保当我们再次请求数据时，你就取到了你第一次放到哪里的数据。做这些并没有看起来这么简单。

第二个抽象是 __目录(directory)__。一个目录，就想一个文件，也有一个底层名字(例如，一个inode号)，但是它的内容有点特殊：它包含了(用户可读名字，底层名字)对的链表(list of (user-readable name,low-level name)pairs)。例如，假设有一个文件，它的底层名字是"10"，它通过"foo"这个用户可读的名字来引用。那么"foo"存在的目录就有一个条目("foo","10")，用来做用户可读名字到底层名字映射。目录的每个条目要么是文件要么是子目录。通过把目录放入到其它目录中，用户可以构建一个任意的 __目录树(directory tree)__(或者 __目录层级(directory hierarchy)__)，所有文件和目录都存放在这之下。

目录层级从一个 __根目录(root directory)__ 开始(在基于UNIX的系统中，根目录通常用`/`表示)并使用某种 __分隔符(separator)__ 命名后续的 __子目录(sub-directories)__ 知道所需的文件或者目录被命名了。例如，如果一个用户在根目录下`/`创建了一个目录`foo`，然后创建在目录`foo`中了一个文件`bar.txt`，我们可以通过文件的 __绝对路径(absolute pathname)__ 引用这个文件，在这个例子中，就是`/foo/bar.txt`。图39_1是一个更复杂的目录树；在这个例子中，有效的目录是`/`,`/foo`,`/bar`,`/bar/bar`,`/bar/foo`，有效的文件是`/foo/bar.txt`和`/bar/foo/bar.txt`。

![figure39_1.png "一个目录树的例子"](figure39_1.png "一个目录树的例子")

>#### tip：仔细考虑命名
>在计算机科学中，命名是很重要的。在UNIX系统中，几乎所有你可以想到的事情都通过文件系统命名了。除了文件，设备，管道(pipe)甚至是进程都看起来可以在某些老的文件系统中找到(can be found in what looks like a plain old file system)。统一的命名可以让你的系统概念模型简单，让你的系统更加简单更加模块化。因此，当你创建一个系统或者接口时，袭击考虑你要用的名字。

目录和文件可以有相同的名字，只要它们在文件系统树中不同的位置(例如，在上图中有两个文件叫做`bar.txt`，`/foo/bar.txt`和`/bar/foo/bar.txt`)。

你可能还注意到了在这个例子中文件名通常由两部分:`bar`和`txt`，通过句点分割。开头部分是任意名字，而文件名的第二个部分通常用来指示文件的 __类型(type)__，例如，是不是C代码(例如`.c`)，或者是一个图像(`.jpg`)或者是一个音乐文件(`.mp3`)。然而，这通常只是一个 __约定(convention)__：他没有强制要求包含在文件名是`main.c`的数据确实是C代码。

因此，我们可以看到文件系统提供的一个伟大的东西：一个便捷的方式可以命名所有我们关心的文件。在系统中，名字是很重要的，它是访问任何可以通过名字关联资源的第一步。在UNIX系统中，文件系统提供了统一的方式访问硬盘上的文件，USB，CD-ROM和其它设备，事实上很多其他东西，都在单个文件树上。

### 39.2 文件系统接口
让我们跟深入的讨论一下文件系统接口。我们先以基本的创建，访问和删除文件开始。你可能认为这些很直接，但直到我们发现用来删除文件的神秘调用`unlike()`。希望，在本章结束，这个对你来说不会太神秘。

### 39.3 创建文件
我们先以最基本的操作开始：创建文件。这个可以通过`open`系统调用完成；通过调用`open()`并传入`O_CREAT`标志，一个程序可以创建新的文件。这里有一个在当前工作目录创建"foo"文件的示例代码。
```c
int fd = open("foo", O_CREAT|O_WRONLY|O_TRUNC,S_IRUSR|S_IWUSR);
```
`open()`例程可以接受几个不同的标志。在这个例子中，如果文件不存在，第二个参数就创建一个(`O_CREAT`)，保证那个文件只可以被写入(`O_WRONLY`)，然后，如果文件存在，截断文件到只有零字节从而删除了所有文件内容(`O_TRUNC`)。第三个参数指定了权限，在这个例子中让文件拥有者对文件可读可写。

`open()`有一个很重要的方面是它的返回值：一个 __文件描述符(file descriptor)__。一个文件描述符就只是一个整数，每个进程私有的，它被用来在UNIX系统中访问文件；因此，一旦文件被打开，你可以使用文件描述符读写这个文件(假设你有权限这么做)。按照这种方式，文件描述符是一个 __能力(capability)__，例如，一个不透明的handle，给你执行某种操作的能力。看待文件描述符的另一种方式是：它是一个指向类型是文件的对象的指针；一旦你拥有了这么一个对象，你可以调用其它“方法”访问文件，例如`read()`和`write()`(在下面你可以看到要怎么做)。

就想上面说过那样，文件描述符被操作系统在每进程底层(per-process basis)上管理。这意味着在UNIX系统上某种简单的结构被保存在`proc`结构上(例如，一个数组)。这里有xv6 kernel的例子：
```c
struct proc {
    // other filed
    struct file *ofile[NOFILE];//Open files
    // other filed
}
```
一个简单的数据(最大可以有`NOFILE`个打开文件)跟踪在每个进程底层打开了多少个文件。数组的每个条目实际上是一个指向`struct file`的指针，用来跟踪被读写文件的信息；我们将在下面讨论。
>#### tip:使用`STRACE`(和简单的工具)
>`strace`工具提供了极好的方式查看程序使用了什么。通过运行它，你可以跟踪系统使用了哪些系统调用，查看参数和返回值，然后对事情将会怎么发展有好的理解。
>这个工具接收几个很有用的参数。例如，`-f`也跟随所有fork的子进程；`-t`汇报每个调用的当日时间；`-e trace=open,close,read,write`只跟踪这些系统调用并忽略其他的调用。还有其它标志，阅读手册并找到驾驭这个工具的方式。
### 39.4 读写文件