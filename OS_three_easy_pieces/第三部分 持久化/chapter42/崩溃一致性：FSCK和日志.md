## 崩溃一致性：FSCK和日志(Crash Consistency:FSCK and Journaling)
目前为止我们看到，文件系统通过管理一系列数据结构实现期望的抽象：文件，目录以及其它所有为了支撑这些我们希望从文件系统得到的基本抽象所必须的元数据。不想大多数数据结构(例如，那些在一个运行中程序内存中找到的)，文件系统数据结构必须是 __持久化的(persist)__，例如，它们必须可以在长途运输中存活，存储在那些掉电时也可以保存数据(例如硬盘或者基于闪存的SSDs)。

文件系统面临的一个主要挑战是如何在 __存在掉电__ 或者 __系统崩溃__ 的情况下更新持久化数据结构。具体的说，如果，在更新硬盘结构的过程中，某人被电源线绊倒导致机器掉电或者操作系统遇到了bug崩溃了会发生什么？由于掉电或者崩溃，更新一个持久化数据结构可能会很麻烦，从而导致在文件系统实现中出现了新的有意思的问题，也就是 __崩溃一致性问题(crash-consistency problem)__？

这个问题很容易理解。考虑为了完成一个特定操作，你要更新两个硬盘数据结构，A和B。因为一次只能服务一个请求，这些请求中会有一个先到达服务器(不是A就是B)。如果在一个写操作完成后系统崩溃或者掉电，硬盘数据结构就会出现 __不一致(inconsistent)__ 的状态。因此，我们这就有了一个文件系统必须要解决的问题：
>#### 症结：如何更新硬盘无视崩溃
>在任意写操作之间系统可能会崩溃或者掉电，从而硬盘状态可能只有部分被更新。崩溃之后，系统启动，想要再次挂载文件系统(为了访问文件等等)。由于崩溃可能发生在任意时刻，我们要怎么确保文件系统保持硬盘影像(image)是一个合理状态？

本章，我们会详细的描述这个问题，然后学些文件系统解决这个问题的方法。我们首先从旧文件系统采用的方式开始，即 __fsck__ 或者 __文件系统检查(file system checker)__。然后我们把注意力转向到其它方式，也就是 __日志(journaling)__(也叫 __先写日志(write-ahead logging)__)，这是一个对每次写操作会稍微增加一点负载，但可以快速从崩溃或者掉电中恢复的技术。我们还会讨论日志的基本机制，包括Linux ext3(一个相对现代的日志文件系统)一些小小的不同倾向的实现。

### 42.1 一个更细节的例子
先放下对日志的研究，我们看一个例子。我们需要使用一个以某种方式更新硬盘数据结构的 __工作集__。假设这里的工作集很简单：对一个存在文件追加单个数据block。完成这个任务包括打开文件，调用`lseek()`移动文件偏移量到文件末尾然后发起一个4KB写操作到文件，最后关闭这个文件。

让我们假设我们在硬盘上使用标准的简单文件系统结构，类似我们之间看到过的文件系统。这个小例子包括一个 __inode位图(8bit，每个inode一个)__，一个__data位图__(8bit，每个数据block一个)，以及数据block(8个，序号从0到7)。