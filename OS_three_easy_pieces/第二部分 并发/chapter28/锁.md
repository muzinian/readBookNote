##锁
从并并发介绍里面，我看到了在并发编程中一个本质问题：我们想要原子性的执行一系列操作，但是由于在单处理器上中断的存在(或者在多个给处理器上并发执行的多个线程)，我们做不到。本章，我们将直接痛击这个问题，通过对 __锁__ 的介绍。程序员使用锁注解代码，把它们放到关键区周围确保任意这样的关键区执行的像是单一原子指令。
###28.1 锁：基本理念
作为一个例子，假设我们的关键区如下，一个典型的更新共享变量操作：
```c
balance = balance + 1;
```
当然，其它类型的关键区也可能，例如给单链表增加一个元素锁着其它对共享数据结构更复杂的更新操作，但是我们现在就保持例子的简单。为了使用锁，我们在关键区附近增加如下代码：
```c
lock_t mutex; // some globally-allocated lock ’mutex’
...
lock(&mutex);
balance = balance + 1;
unlock(&mutex);
```
一个锁就是一个变量，为了使用一个锁，你必须要声明一个某种类型(例如，上面那种`mutex`)的 __锁变量(lock variable)__。这个锁变量(简称"锁")在任何时刻都控制着锁的状态。它要么是 __可用的(available)__(或者是 __未被锁(unlocked)__ 或者 __空闲的(free)__)因此就没有线程持有锁，或者是 __已获得的(acquired)__(或者是 __锁住的(locked)__ 或者是 __被持有的(held)__)，也即确定一个线程持有了锁并且大概率正在关键区里。我们还可以在这个数据类型中存放其它信息，例如什么线程正在持有锁，或者一个有序的锁获取队列(a queue for ordering lock acquisition 意思是这个队列存放了那些要请求锁的线程)，但是这些信息是对锁的使用者隐藏的。

`lock()`和`unlock()`例程的语义很简单。调用`lock()`例程试图请求锁；如果没有其它线程持有锁(例如，锁是空闲的)，线程将会获取到锁然后进入关键区；这个线程有时候也叫做所得 __拥有者__。如果另外的线程接下来对 同一个锁变量(本例中就是`mutex`)调用`lock()`，在锁被其他线程持有的时间内它将不会返回；以这种方式，其他线程就被阻止进入关键区了，当第一个线程通过持有锁进入关键区时。

一旦锁的拥有者调用了`unlock()`，锁就再次可用了(空闲了)。如果没有其它线程在等待锁(例如，没有其它线程之间调用过`lock()`并卡在其中)，锁的状态就简单的改为空闲。如果有等待的线程(卡在`lock()`中)，它们中的一个将(最终会)注意到(或者被通知到)锁状态的改变，然后请求锁，进入关键区。

锁提供了一些对调度最小化控制权给程序员。总的来说，我们把线程看作由程序员创建但是由OS调度的实体，调度的方式都是由OS选择的。锁让出了某些控制权回来给程序员；通过把锁放到代码段的周围，程序员可以保证不会超过一个线程能够在这段代码内部活动。因此，锁帮助把传统OS调度的混乱状态转换为更可控的活动。