## 信号量
我们现在知道了，我们需要锁和条件变量一起解决很大范围内相关有趣的并发问题。早年间最开始意识到这个的那些人之一是Edsger Dijkstra(尽管很难知道确切的历史)，他以很多其他事情著名，例如图理论中他的著名最短路径算法，名为"goto被认为是有害的"(多么伟大的标题)一篇关于结构化编程的早期论战文章，以及，这里我们将要学习的理论，一个被叫做 __信号量(semaphore)__ 同步原语介绍。事实上，Dijkstra 和其同事发明的信号量是作为与并发相关的唯一原语；正如你将看到的，我们可以把信号量既用作锁也用作条件变量。
>####症结：如何使用信号量
>我们要怎么使用信号量而不是锁和条件变量？信号量的定义是什么？什么是二元信号量？使用锁和条件变量直接构造信号量可行么？使用信号量构造锁和条件变量呢？
###31.1 信号量：定义
信号量是一个对象它包含一个整数值我们可以使用两个例程维护这个整数值；在POSIX标准里，这些例程是`sem_wait()`和`sem_post()`[<sub id="content1">1</sub>](#1)。因为信号量的初始值决定了它的行为，我们必须首先以某个值初始化它，正如代码片段31.1那样。
```c
#include <semaphore.h>
sem_t s;
sem_init(&s, 0, 1);
```
__代码片段31.1初始化信号量__

在上面的代码中，我们声明了一个信号量并初始化它的值为1，通过在第三个实参传入1实现。`sem_init()`第二个参数在我们将看到的所有例子里都被设置为0；它表示在同一个进程里面信号量在线程中是共享的。关于信号量的其它使用细节参见man手册(即，信号量是如何跨进程使用来同步访问)，这就需要在第二个参数传入不同的值。

信号量初始化之后，我们可以调用`sem_wait()`和`sem_post()`函数与之交互。它们的行为如代码片段31.2所示：
```c
int sem_wait(sem_t *s)
{
    decrement the value of semaphore s by one
        wait if value of semaphore s is negative
}

int sem_post(sem_t *s)
{
    increment the value of semaphore s by one if there are one or more threads waiting, wake one
}
```
__代码31.2 信号量：Wait和Post定义__

现在，我们不关心这些例程的实现，当然显然还是需要一些关心，在使用多线程调用`sem_wait()`和`sem_post()`时，为了管理关键区那有显著的要求。我们现在将只关心如何使用这些原语，稍后我们将会讨论如何构建它们。

这里我们应该讨论这两个接口几个显著的方面。首先，我们可以看到`sem_wait()`要么会立刻返回(因为在我们调用时信号量的值是1或者比1更大)，或者它会导致调用者暂停执行等待后续的post。当然，多个调用线程可能会都会调用`sem_wait()`，所以都需要入队等待被唤醒。

第二，我们可以看到`sem_post()`没有像`sem_wait()`那样等待去持有某些特定条件(这句话的意思是不像`sem_wait()`那样需要判断信号量的值是不是大于0)。相反，他就是简单的增加信号量的值然后如果有线程等待被唤醒，就唤醒其中一个。

第三，信号量的值，当变成负数时，就和等待线程个数相等。尽管这个值通常不会被信号量的使用者看到，这个不变量是值得了解并且可能帮助你记住信号量的工作方式。

(目前)不用担心可能会在信号量内部发生的竟态条件；先假设他们执行的操作是原子的。我们将很快使用锁和条件变量来完成这些。

###31.2 二元信号量(锁)
我们先准备使用信号量。我们首先用于一个我们熟悉的情况：使用信号量实现锁。参见代码片段31.3，在里面你可以看到我们就是在关键区周围使用`sem_wait()`/`sem_post()`对。让这个工作的关键点就是信号量`m`的初始值(代码中被初始化为X)这个X应该是多少？
```c
sem_t m;
sem_init(&m, 0, X); // initialize to X; what should X be?
sem_wait(&m);
// critical section here
sem_post(&m);
```
__代码片段31.3 二元信号量(也就是锁)__

回头看一下`sem_wait()`和`sem_post()`例程的定义，我们可以看到这个初始值应该设置为1。

为了讲的更明白些，让我们想象一个有着两个线程的场景。第一个线程(线程0)调用`sem_wait()`；它首先会对信号量的值减一，改成0。然后，如果值小于0，线程0就会一直等待。因为值为0，`sem_wait()`就会返回然后调用线程将会继续(注：这里这句话应该是对上面小于等于0线程等待的解释)；线程0现在就可以自由的进入关键区。如果在线程0位于关键区的时候没有其它线程试图获取锁，当线程0调用`sem_post()`，它会简单的把信号量的值恢复为1(并且没有唤醒一个等待线程，因为没有等待线程)。图31_4显示了这个场景的跟踪过程。

![图31_4.png "线程跟踪：单个线程使用信号量"](#figure31_4.png "线程跟踪：单个线程使用信号量")

更有趣的情况发生在当线程0"持有锁"(例如，它调用了`sem_wait()`但是还没有调用`sem_post()`)，另一个线程(线程1)(通过调用`sem_wait()`)试图进入关键区。在这种场景下，线程1将会把信号量的值减为-1，因此会等待(让自己睡眠然后放弃(relinquish放弃，尤指不情愿的)处理器)。当线程0再次运行，他最终将会调用`sem_post()`，增加信号量的值回到0，然后唤醒等待中的线程(线程1)，这个线程可以获取到锁。当线程1结束，他将会再一次的对信号量的值加一，再一次的恢复为1。

图31_5显示了这个例子的跟踪情况。除了线程动作以外，这个图还显示了每个线程的 __调度器状态(scheduler state)__：运行(这个线程在运行)，准备(线程可以运行带没有运行)和睡眠(线程被阻塞)。注意线程1在试图获取已经被持有的锁的时候进入睡眠状态；只有当线程0再次运行线程1才能被唤醒然后有再次运行的可能。

![图31_5.png "线程跟踪：两个线程使用一个信号量"](#figure31_5.png "线程跟踪：两个线程使用一个信号量")

如果你想要在你的例子里让它工作，试着在多个线程排队等待锁的场景下使用。在这样的追踪路径下信号量的值是如何变化的？

到此我们就可以使用信号量作为锁了。因为锁只有两个状态(被持有和没有被持有)，我们有时候把用作锁的信号量称为 __二元信号量(binary semaphore)__。注意如果你只按照这个二元方式使用信号量，它可以用一种比这里呈现的泛化版本信号量更简单的方法实现信号量。

###31.3 用于排序的信号量
信号量对于在并发编程中排序事件很有用。例如，一个线程可能希望等待一个列表变为非空，从而它可以从中删除一个元素。在这种使用模式里面，我们通常找到一个线程 _等待_ 某个事情发生，然后另一个线程让这些事发生然后 _发信号signaling_ 事情发生了，从而唤醒等待的线程。从而我们就在使用信号量作为 __排序(ordering)__ 原语(类似于我们之前对 __条件变量__ 的使用)。

一个简单的例子如下。想象有一个线程创建另一个线程然后想要等待它完成执行(代码片段31_6)。
```c
sem_t s;

void *child(void *arg)
{
    printf("child\n");
    sem_post(&s); // signal here: child is done
    return NULL;
}

int main(int argc, char *argv[])
{
    sem_init(&s, 0, X); // what should X be?
    printf("parent: begin\n");
    pthread_t c;
    Pthread_create(&c, NULL, child, NULL);
    sem_wait(&s); // wait here for child
    printf("parent: end\n");
    return 0;
}
```
__代码片段：父线程等待子线程__

当程序运行，我们可以看到如下执行结果：
```console
parent: begin
child
parent: end
```

这里问题是如果使用信号量达到这个效果：事实证明，答案相对容易理解。正如你可以从代码中看到，父线程简单的调用`sem_wait()`而子线程`sem_post()`等待子线程结束执行这一条件变为真。然而，这引发了一个问题：信号量的初始值应该是多少？

答案当然就是信号量的值被设置为0。这里要考虑两种情况。首先，让我们假设父线程创建子线程后子线程还没有运行(例如，它处于准备队列中但是没有运行)。在这种情况下(图31_7)，父线程将会在子线程调用`sem_post()`之前调用`sem_wait()`；我们想要父线程等待子线程运行。这种情况发生的问题方式就是信号量的值小于0；因此，0就是初始值。父线程运行，对信号量减一(变为-1)，然后等待(睡眠)。当子线程最终运行，它会调用`sem_post()`，对信号量的值加一变成0，然后唤醒父线程，然后父线程从`sem_wait()`中返回结束程序。

![图31_7 "线程追踪：父线程等待子线程(情况1)"](#figure31_7 "线程追踪：父线程等待子线程(情况1)")

第二种情况(图31_8)发生在子线程在父线程有机会调用`sem_wait()`前完成。在这种情况下，子线程将会先调用`sem_post()`，因此信号量的值从0变成了1。当父线程有机会运行，它会调用`sem_wait()`然后发现信号量的值是1，然后父线程将会对值减一(变为0)然后不用等待就从`sem_wait()`返回，然后达成所要的效果。
>####附注：设置信号量的值
>现在我们已经看到了两个初始化信号量的值。在第一个情况，我们这是信号量的值为一从而把信号量当作锁；在第二个场景里，设置值为0，从而用信号量来排序。所以，初始化信号量的通用规则是什么呢？
>
>思考这个问题有一个简单的方式，多亏Perry Kivokowitz，就是考虑你在你初始化后立即要暴露出来(give away)的资源数量。对于锁，它是1，因为你将要在初始化之后立即有一个锁可以被锁(被暴露)。对于排序的情况，它是0，因为在开始的时候没有只要被暴露出来；只有当子线程完成时，资源才被创建，在这个时刻，值被加一。在未来思考信号量问题的时候请尝试这个方式，你可看看有没有帮助。
###31.4 生产者/消费者(有界buffer)问题
本章下一个我们要解决的问题是所谓的 __生产者/消费者问题__，有时候也叫做 __有界buffer(bounded buffer)__ 问题。这个问题在前面的条件变量的章节有详细描述；看那里了解细节。
####第一次 尝试
我们第一次尝试解决这个问题引入两个信号量，`emtry`和`full`，线程使用它们分别标识一个buffer条目是空的还是被填充了。put和get例程在代码片段31_9，我们尝试解决生产者消费者问题的代码在代码片段31_10。
```c
int buffer[MAX];
int fill = 0;
int use = 0;

void put(int value)
{
    buffer[fill] = value;    // Line F1
    fill = (fill + 1) % MAX; // Line F2
}

int get()
{
    int tmp = buffer[use]; // Line G1
    use = (use + 1) % MAX; // Line G2
    return tmp;
}
```
__代码片段31_9：Put和Get例程__

```c
sem_t empty;
sem_t full;

void *producer(void *arg)
{
    int i;
    for (i = 0; i < loops; i++)
    {
        sem_wait(&empty); // Line P1
        put(i);           // Line P2
        sem_post(&full);  // Line P3
    }
}

void *consumer(void *arg)
{
    int i, tmp = 0;
    while (tmp != -1)
    {
        sem_wait(&full);  // Line C1
        tmp = get();      // Line C2
        sem_post(&empty); // Line C3
        printf("%d\n", tmp);
    }
}

int main(int argc, char *argv[])
{
    // ...
    sem_init(&empty, 0, MAX); // MAX are empty
    sem_init(&full, 0, 0);    // 0 are full
    // ...
}
```
__代码片段31_10：增加满和空条件__
在这个例子里，生产者首先等待buffer变空从而把数据放到里面，然后消费者类似的在使用buffer的数据前等待buffer变满。让我们先想象`MAX=1`(数组里面只有一个buffer)，看看它是否可以工作。

然后在想象有两个线程，一个生产者一个消费者。让我们检查一个在单CPU上特殊的场景。假设消费者先运行。这样，消费者将会命中代码片段的C1行，调用`sem_wait(&full)`。因为`full`的初始化值是0，这个调用会对`full`减一(变成-1)，阻塞消费者，然后等待另外的线程在`full`调用`sem_post()`，就想想要的那样。

假设生产者然后运行。它会命中行P1，然后调用`sem_wait(&empty)`例程。不像消费者，生产者将会继续通过这一行，因为`empty`被初始化为值`MAX`(在这个情况下是1)。因此，`empty`将会减一变成0然后生产者建辉把一个数据放入到buffer的第一个条目里(P2行)。然后消费者会继续到P3然后调用`sem_post(&full)`，把`full`信号量的值从-1改为0然后唤醒消费者(例如，把它从阻塞移动到准备)。

在这个例子里，会发生两种情况中的一种。如果消费者继续运行，它会循环然后再次命中P1行。然而，这一次它会阻塞，因为`empty`信号量的值是0。如果消费者被中断了，消费者开始运行，它会从`sem_wait(&full)`返回(C1行)，发现buffer是满的，然后消费它。在这任意一种情况，我们都达到了想要的效果。

你可以用更多的线程试试这个例子(例如多个生产者和多个消费者)。他应该依旧可以工作。

[<sub id="1">content1</sub>](#content1) 历史上，Dijkstra称`sem_wait()`为`P()`称`sem_post()`为`V()`。这些简写来自于荷兰语；有趣的是，据传是他们继承的荷兰词汇随着时间在改变。最开始`P()`来自'passering'(传给)，`V()`来自'vrijgave'(释放)；后来，Dijkstra写的`P()`来自"prolaag",是"probeer"(尝试)和"verlaag"(减一)的组合词，`V()`来自"verhoog"，这个词意味着"加一"。有时候，人们也叫他们上下。使用荷兰版本取震惊你的朋友，或者迷惑它们。