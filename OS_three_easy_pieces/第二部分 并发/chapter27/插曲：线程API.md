##插曲：线程API
本章简单的覆盖了线程API主要部分。每个部分将会在后续的章节被进一步介绍，因此我们展示如何使用这个API。更多细节可以在各种书和在线资源看到。我们应该注意到后续章节通过很多例子慢慢介绍锁和条件变量的概念，本章最好被用来作为一个引用。
>### 症结：如何创建和控制线程
>OS为了线程创建和控制应该呈现什么接口？这些接口应该被怎么设计从而确保易用和实用？
###27.1 线程创建
在编写多线程程序第一个要做的事就是创建新线程，所以必须要存在某种创建线程的接口，在POSIX中，很简单：
```c
#include <pthread.h>
int pthread_create(pthread_t *thread,
                   const pthread_attr_t *attr,
                   void *(*start_routine)(void *),
                   void *arg);
```
这个声明看起来有点复杂(特别是如果你没有使用过C语言的函数指针)，但是实际上没有那么糟糕。这里有四个参数，`thread`，`attr`，`start_routine`和`arg`。第一个形参，`thread`，是指向`pthread_t`类型结构的一个指针。我们使用这个结构与线程交互，所以我们需要传递给`pthread_create()`从而初始化它。

第二个形参，`attr`，用来指定这个线程可能拥有的任何attributes。有些例子包括栈大小或者关于这个线程调度优先级的信息。attribute的初始化是在`pthread_attr_init()`单独调用的，查看手册了解跟多细节。然而，在大多数情况中，默认值就工作的很好了；这种情况下，我们就只用传入`NULL`值。

第三个形参是最复杂的，但它只是再问：这个线程应该从哪个函数开始执行？在C中，我们称这个是 __函数指针(funciton pointer)__，这个参数告诉我们参数应该满足：一个名字叫做`(start_routine)`，它只接受一个类型是`void *`的参数(由在`start_routine`后的小括号表示)，并返回一个`void *`类型的值(例如，一个 __void指针(void pointer)__)。

如果这个例程有要求一个整型参数而不是一个void指针，声明可能是如下：
```c
int pthread_create(..., // first two args are the same
                   void *(*start_routine)(int),
                   int arg);
```
如果这个例程接收一个void指针做形参，但是返回一个整型，声明可能如下：
```c
int pthread_create(..., // first two args are the same
                   int (*start_routine)(void *),
                   void *arg);
```
最后，第四个形参，`arg`，就是线程在开始传递给将要执行的那个函数的实参。你可能会问，为什么我们需要这是void指针？答案很简单：使用void指针做`start_routine`函数的形参让我们可以传递 _任意_ 类型的参数；让void指针做返回值允许线程返回 _任意_ 类型做为结果。

让我们看一个例子。这里我们创建了一个接受两个参数的线程，这两个参数被打包到我们为自己定义的一个类型(`myarg_t`)。这个线程，一旦被创建，可以简单的把参数转换为它期待的类型然后按照需要解压这些参数。

这就是了！一旦你创建一个线程，你就拥有了另一个活跃的执行实体，拥有自己的调用栈，和这个程序中所有的当前已存在线程运行在 _同一个_ 地址空间。