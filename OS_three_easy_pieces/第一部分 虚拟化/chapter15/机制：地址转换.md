## 机制：地址转换
在开发CPU虚拟化的过程中，沃恩专注于一个通用机制：__受限直接执行(limited direct execution LDE)__。LDE背后的理念很简单：在大多数时候，让程序直接运行在硬件上；然而，在某些关键时刻(例如当一个进程发起一个系统调用，或者定时器中断发生)重新分配资源以让OS被调用并确保"正确的"事情发生。因此，OS，通过硬件一点的帮助，尽它最大努力避开运行中程序的干扰，以提供高效的虚拟化；然而，通过及时在某些关键点介入，OS确保它维持对硬件的控制权。效率和控制权一起组成了任何一个现代操作系统的主要目标。

在内存虚拟化中，我们继续最求类似的策略，在提供所需虚拟化的同时，达到既有效率也有控制权。效率让我们利用硬件支持，在开始可能会很基本(例如，就是几个寄存器)但很快会增长的足够复杂(例如，TLB，页表支持等等)。控制权隐含着OS确保应用程序除了访问自已拥有的内存外不能访问其它内存；也即，确保进程之间，OS与进程之间相互安全，这里我们也需要硬件的帮助。最后，我们需要VM系统在提供多一点东西，就是灵活性；特别的，我们想要进程有能力以任何进程想要的方式使用它们自己的地址空间，这让系统对编程变得简单。我们到了精确的问题：
>### 症结：如何高效灵活的虚拟化内存
>我们如何构建一个高效的内存虚拟化？如何提供应用所需的灵活性？如何维持那些应用可以访问内存位置的控制权，以此确保应用程序内存访问是被正确限制的？我们如何高效的做到这些？

我们将要使用的通用技术被称为 __基于硬件的地址变换(hardware-based address translation)__，或者简称地址转换，你可以认为这是LDB这一通用方式的附加。有了地址转换，硬件转换每一次内存访问(例如，指令：取fetch，加载load，存储store)，修改由指令提供的虚拟地址为所需信息实际存放位置的物理地址。因此，对于每一个内存引用，硬件都会执行地址转换以重定位应用内存引用到在内存中的实际位置。
>TIP:介入是有力
>介入(interposition)是一个通用有力的技术，在计算机系统中经常被用来产生巨大的效果。在虚拟化内存过程中，硬件将会介入到每一次内存访问中，转换每一次由进程产生的虚拟地址到真实存放所需信息的实际物理地址。然而，关于介入这一通用技术有着更为宽广的应用场景；事实上，几乎任意一个良好定义的接口，在之上都可以介入，用来增加新的功能或者提示系统其它方面。这样做的一个有用的好处是透明性：介入常常不需要修改接口的客户端，也就不用通知客户端更改。

当然，只有硬件无法实现虚拟化内存，它只提供了底层机制为了高效实现。OS必须在关键环节被调用以设置硬件从而让正确的转换发生；OS必须要管理内存，保持追踪哪些位置是空闲的，哪些是使用中的，并明断的干预，以保持对内存如何使用的控制。

再一次，我们所有工作的目标就是为了创建一个美丽的幻象：那就是，每个程序都有自己的私有内存，那里贮存着程序自身的代码和数据。在这虚拟现实后面存在着丑陋的物理真相：那就是，在同一时刻，很多程序实际上在共享内存，随着CPU(或CPUs)在各个程序之间切换运行。通过虚拟化，OS(在硬件帮助下)把丑陋的机器实现转换为某些有用，强大并易于使用的抽象。

### 假设
我们对于虚拟化内存第一个尝试将非常简单，近乎可笑。继续笑吧，尽你所想的笑，很快，当你试着理解TLBs，多级页表和其他技术奇迹时，就将是OS嘲笑你了。

特别的，现在，我们假设用户地址空间必须在物理内存中是连续的。我们还要假设，为了简单，地址空间不是很大，特别的，它的大小要小于 _物理地址_。最后，我们还要假设每个地址空间大小都一样。别担心，如果这些假设听起来不现实，随着我们的继续，我们会放松这些假设，形成一个实际的内存虚拟化。

### 一个例子
为了更好理解为了实现地址转换我们需要做什么，以及我们为什么需要一个机制，让我们先看一个简单例子。想象有一个进程的地址空间如图15.1。我们要检查一段从内存加载值的代码序列，给值加三，然后把值存会内存。你可以想象C语言的表示如下：
```C
void func() {
int x;
x = x + 3; // this is the line of code we are interested in
```
编译器把代码转换为汇编，在x86汇编下可能如下(Linux使用`objdump`/Mac OS X使用`otool`)反汇编：
```asm
128: movl 0x0(%ebx), %eax ;load 0+ebx into eax
132: addl $0x03, %eax ;add 3 to eax register
135: movl %eax, 0x0(%ebx) ;store eax back to mem
```
这段代码相对直接；它假定`x`的地址被放置到`ebx`寄存器，然后使用`movl`指令(表示"longword" move长字移动)从那个地址加载值到通用目的寄存器`eax`。下一个指令把2加到`eax`，最后一个指令把`eax`的值存回内存到同一个地址。

在图15.1中，你可以看到进程代码和数据在地址空间的布局，三指令代码序列位于地址128处(靠近顶部的代码段中)，变量x的值位于地址15kb处(靠近底部的栈中)。在图中，x的初始值是3000，显示在栈中它的位置。
![进程和它的地址空间](Figure15_1_1.png "进程和它的地址空间")
![进程和它的地址空间](Figure15_1_2.png "进程和它的地址空间")

当这些指令运行时，从进程的观点看，会发生如下的内存访问：
* 在128处取指令
* 执行这个指令(从地址15KB加载值)
* 在地址132处取指令
* 执行这个指令(没有内存引用)
* 在地址135处取指令
* 执行这个指令(把值存到地址15KB)
从程序的角度看，地址空间从0开始，一直增长到16KB；它生成的所有内存引用都在这个范围内。然而，为了虚拟化内存，OS想要把这个进程放到物理内存的其它地方，而不必是从0开始。因此，我们有一个问题：我们如何一种对进程透明的方式重新安置(relocate)进程在内存的位置？我们如何提供一个虚拟地址开始于0处的幻象，当现实是，地址空间位于物理地址的其它位置？

一旦这个进程地址空间已经被放入到内存中，这个物理内存可能布局如图15.2。
![包含一个重新定位的进程的物理内存](Figure15_2.png "包含一个重新定位的进程的物理内存")
在这个图中，你可以看到OS为自己分配了物理内存第一个槽位，然后它重新安置了这个进程，从例子中看，这个槽位开始于物理地址的32KB处。另外的两个槽位是空闲的(16KB-32KB和48KB-64KB)



