## 机制：地址转换
在开发CPU虚拟化的过程中，沃恩专注于一个通用机制：__受限直接执行(limited direct execution LDE)__。LDE背后的理念很简单：在大多数时候，让程序直接运行在硬件上；然而，在某些关键时刻(例如当一个进程发起一个系统调用，或者定时器中断发生)重新分配资源以让OS被调用并确保"正确的"事情发生。因此，OS，通过硬件一点的帮助，尽它最大努力避开运行中程序的干扰，以提供高效的虚拟化；然而，通过及时在某些关键点介入，OS确保它维持对硬件的控制权。效率和控制权一起组成了任何一个现代操作系统的主要目标。

在内存虚拟化中，我们继续最求类似的策略，在提供所需虚拟化的同时，达到既有效率也有控制权。效率让我们利用硬件支持，在开始可能会很基本(例如，就是几个寄存器)但很快会增长的足够复杂(例如，TLB，页表支持等等)。控制权隐含着OS确保应用程序除了访问自已拥有的内存外不能访问其它内存；也即，确保进程之间，OS与进程之间相互安全，这里我们也需要硬件的帮助。最后，我们需要VM系统在提供多一点东西，就是灵活性；特别的，我们想要进程有能力以任何进程想要的方式使用它们自己的地址空间，这让系统对编程变得简单。我们到了精确的问题：
>### 症结：如何高效灵活的虚拟化内存
>我们如何构建一个高效的内存虚拟化？如何提供应用所需的灵活性？如何维持那些应用可以访问内存位置的控制权，以此确保应用程序内存访问是被正确限制的？我们如何高效的做到这些？

我们将要使用的通用技术被称为 __基于硬件的地址变换(hardware-based address translation)__，或者简称地址转换，你可以认为这是LDB这一通用方式的附加。有了地址转换，硬件转换每一次内存访问(例如，指令：取fetch，加载load，存储store)，修改由指令提供的虚拟地址为所需信息实际存放位置的物理地址。因此，对于每一个内存引用，硬件都会执行地址转换以重定位应用内存引用到在内存中的实际位置。

当然，只有硬件无法实现虚拟化内存，它只提供了底层机制为了高效实现。OS必须在关键环节被调用以设置硬件从而让正确的转换发生；OS必须要管理内存，保持追踪哪些位置是空闲的，哪些是使用中的，并明断的干预，以保持对内存如何使用的控制。

再一次，我们所有工作的目标就是为了创建一个美丽的幻象：那就是，每个程序都有自己的私有内存，那里贮存着程序自身的代码和数据。在这虚拟现实后面存在着丑陋的物理真相：那就是，在同一时刻，很多程序实际上在共享内存，随着CPU(或CPUs)在各个程序之间切换运行。通过虚拟化，OS(在硬件帮助下)把丑陋的机器实现转换为某些有用，强大并易于使用的抽象。
### 假设
我们对于虚拟化内存第一个尝试将非常简单，近乎可笑。继续笑吧，尽你所想的笑，很快，当你试着理解TLBs，多级页表和其他技术奇迹时，就将是OS嘲笑你了。

特别的，现在，我们假设用户地址空间必须在物理内存中是连续的。我们还要假设，为了简单，地址空间不是很大，特别的，它的大小要小于 _物理地址_。最后，我们还要假设每个地址空间大小都一样。别担心，如果这些假设听起来不现实，随着我们的继续，我们会放松这些假设，形成一个实际的内存虚拟化。

### 一个例子
为了更好理解为了实现地址转换我们需要做什么，以及我们为什么需要一个机制，让我们先看一个简单例子。想象有一个进程的地址空间如图15.1。我们要检查一段从内存加载值的代码序列，给值加三，然后把值存会内存。你可以想象C语言的表示如下：
```C
void func() {
int x;
x = x + 3; // this is the line of code we are interested in
```
编译器把代码转换为汇编，在x86汇编下可能如下(Linux使用`objdump`/Mac OS X使用`otool`)反汇编：
```asm
128: movl 0x0(%ebx), %eax ;load 0+ebx into eax
132: addl $0x03, %eax ;add 3 to eax register
135: movl %eax, 0x0(%ebx) ;store eax back to mem
```
这段代码相对直接；它假定`x`的地址被放置到`ebx`寄存器，然后使用`movl`指令(表示"longword" move长字移动)从那个地址加载值到通用目的寄存器`eax`。下一个指令把2加到`eax`，最后一个指令把`eax`的值存回内存到同一个地址。



