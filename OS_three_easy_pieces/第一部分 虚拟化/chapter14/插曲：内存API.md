## 插曲: 内存API
在这个插曲中，我们会讨论UNIX系统中的内存分配接口。这些接口实现都很简单，因此本章很短并直达关键[<sup id="coentent1">1</sup>](#1)。我们要解决的主要问题是：
>### 症结：如何分配和管理内存
>在UNIX/C程序中，在构建健壮和可靠软件的过程中理解如何分配和管理内存是很关键的。哪些接口是常用的？需要避免犯什么错？

###14.1 内存的类型
在运行C程序时，有两类内存被分配。第一类叫做 __栈__ 内存，这个内存的操作(分配和解除分配)由编译器隐式的为你(程序员)管理，由于这个原因，它有时也叫做自动内存。

在C语言中，在栈上生命内存很简单。例如，你需要在函数`func()`内为一个整数(假设为x)分配空间。为了分配这个内存，你需要如下做：
```C
void func() {
int x; // declares an integer on the stack
...
}
```
编译器会处理剩下的事，确保在你调用`func()`时在栈上分配空间。当你从这个函数返回时，编译器为你解除分配这块内存；也即，如果你要某些信息生存期长过方法调用，你最好不要把信息留在栈上。

需要长时间存活的內存的需求让我们有了第二种类型的内存，__堆__ 内存，对内存的分配和解除分配都显示有你，程序员，操作。这无疑是一个很艰巨的责任。某些时候这会导致很多bug。但是，如果你仔细且耐心，你可以正确的使用这些接口而没有太多麻烦。这里有一个例子，在堆上分配一个指向整数的指针：
```C
void func() {
int *x = (int *) malloc(sizeof(int));
...
}
```
对这个代码段有一些解释。第一，你可能注意到了，在这一行中，既有栈内存分配又有堆内存分配发生：首先，当编译器看到你声明了一个指针(`int *x`)时，他就知道要为一个指向整数的指针分配空间，接着，当程序调用了`malloc()`，它在堆上请求为一个整数分配空间；这个例程返回了一个整数的地址(如果分配成功，否则失败的话返回NULL)，这个地址将存在栈上以供程序使用。

由于这个显式的特点，以及更多的各种使用方式，堆内存对使用者个系统提出了更多的挑战。因此，接下来的讨论我们将专注于此。

###14.2 `malloc()`调用
`malloc()`调用很简单：你传递一个数字给他作为想要在堆上分配的内存大小，如果它分配成功，就返回给你一个指向新分配空间的指针，如果失败，就返回NULL[<sup id="content2">2</sup>](#2)。

man手册会告诉你在使用`malloc`时你要怎么做，在命令行输入`man malloc`你将看到：
```C
#include <stdlib.h>
...
void *malloc(size_t size);
```
从这里你可以看到，使用`malloc`你只需要包含`stdlib.h`这个头文件。甚至，你甚至不必真的这样做，作为一个C库，每个C程序都会默认链接它，它包含了`malloc()`所需的代码；添加这个头文件只是为了让编译器检查你调用`malloc()`的方法是否正确(例如，传递了正确的参数数字给它以及正确的类型)。

`malloc()`使用了`size_t`类型作为它唯一的参数的类型，这个参数只是用来描述你需要多少字节。然而， 大多数程序员不会直接传入一个数字(例如10)；事实上，直接传入数字被认为是糟糕的。相反，各种例程和宏被利用。举个例子，为了给一个双精度浮点数分配空间，你只需要这样做：
```C
double *d = (double *) malloc(sizeof(double));
```
>### TIP:有怀疑的话，就实际试一下吧
>如果你不确定你正在使用的某些例程或者操作符的行为，没有比尝试一下来确保它的行为和你希望的一致更简单的办法了。当然，阅读手册或者其它文档当然有用，在实践中它是如何工作的更需要关心。编写一些代码并测试吧！这无疑是确保你的代码行为和你希望的一致最好办法。真的，这正是我们在双重检查我们讲述关于`sizeof()`确实是真的的时候所作的！

哇哦，`double`做了好多事情！对于`malloc()`的调用使用了`sizeof()`操作符来获取正确的空间数量；在C中，这通常认为是一个编译时操作符，这意味着在编译器知道了实际的尺寸，这个数字(在这个例子里，对于`double`是8)被替换为`malloc()`的实参。因为这个原因，`sizeof()`被认为是一个操作符而不是一个函数调用(函数调用发生在运行时)。

你可能也会传递变量名称(而不是一个类型)给`sizeof()`，但是，在某些情况下，你可能不会得到期望的结果，所以，要小心。举个例子，看看如下代码片段:
```C
int *x = malloc(10 * sizeof(int));
printf("%d\n", sizeof(x));
```
在第一行，我们为一个包含了是个整数的数组声明了空间，这很好并且很高级。然而，当我们在下一行使用`sizeof()`时，他返回的是一个很小的值4(在32位机器)或者8(在64位机器)。在这个情况中，`sizeof()`认为我们只是想要知道一个指向整形的指针大小，而不是我们动态分配的内存大小。但是，有时候`sizeof()`的行为又和你希望的一致：
```C
int x[10];
printf("%d\n", sizeof(x));
```
在这种情况下，编译器有足够的静态信息知道有40字节被分配了。

另一个需要注意的地方是字符串。当为字符串声明空间时，使用这个惯用法:`malloc(strlen(s)+1)`，通过`strlen()`获取字符串的长度，然后加1，这是为了字符串结束标识符。在这使用`sizeof()`可能会导致问题。

你可能注意到了，`malloc()`返回的是`void`类型指针。这是C语言使用的方法，用来回传一个地址，让程序员决定如何处理它。程序员使用 __类型转换(cast)__ 来转换成需要的类型。在我们上面的例子，程序员把`malloc()`的返回类型转换为`double`类型指针。转换实际上没有完成任何事情，除了告诉编译器和其它需要阅读你代码的程序员：“是的，我知道我要做什么。”通过转换`malloc()`的结果，程序员可以有某种安慰，对于正确性来说，转换不是必须的。

### 14.3 `free()`调用
事实证明，分配内存只是等式中简单的一部分，知道何时，如何，甚至是否释放内存是困难的部分。为了释放不会在使用的堆内存，程序员只需要调用`free()`：
```C
int *x = malloc(10 * sizeof(int));
...
free(x);
```
### 14.4 常见错误
在使用`malloc()`和`free()`的过程中，有一系列常见错误发生。这些错误在编译和运行时，编译器没有发出任何声音；对于构建正确的C程序编译C程序很必要，但是这远远不够，正如你将学到的(常常是以一种困难的方式)。

正确的内存管理已经成为了一个严重问题，事实上，有很多新语言已经支持了 __自动内存管理(automatic memory management)__。在这些语言，当你调用某些类似与`malloc()`的来分配内存(通常是 __new__ 或者其它类似的分配新对象)，你永远不用调用什么东西来释放空间；相反，一个 __垃圾回收器(garbage collector)__ 运行并找到那些内存你不再有引用并为你释放这些内存。

#### 忘记分配内存
很多例程都希望你再调用它们之前已经分配好内存了。例如，`strcpy(dst,src)`例程，它从源指针复制一个字符串到目的指针。然而，如果你不够消息，你可能这样做：
```C
char *src = "hello";
char *dst; // oops! unallocated
strcpy(dst, src); // segfault and die
```
当你运行这段代码，它会导致段错误(segmentation fault)[<sup id="content3">3</sup>](#3)，这是 __你这个愚蠢的程序员你操作内存时做错事了我很生气__ 的高级说法。
>### TIP:编译成功或者运行了 ≠ 它是正确的
>仅仅因为程序编译成功甚至是正确的运行了几次并不意味着程序是正确的。很多事件可能会一起导致一种结果，你以为它工作了，但是如果某些事情改变了他就会停止。一个常见的反应是：“他之前可以正常工作！”然后怪罪到编译器，操作系统，硬件，甚至教授。但是问题通常发生在你的代码里。在你抱怨其它组件前，先回去工作并调试你的代码。

在这种情况下，正确的代码应该如下：
```C
char *src = "hello";
char *dst = (char *) malloc(strlen(src) + 1);
strcpy(dst, src); // work properly
```
可选的，你可以使用`strdup()`让你的生活更容易些，查看这个调用的手册获取更多信息.


[<sup id="1">1</sup>](#content1) 真的，我们希望所有的章节都是这样！我们认为但是这一章更进一步。

[<sup id="2">2</sup>](#content2) 记住，在C中NULL没有特别的意义，只是0这个值的一个宏。

[<sup id="3">3</sup>](#content3) 尽管听起来很神秘，你很快就会学到为什么这样的非法内存访问被叫做段错误；如果这不是继续读下去的动力，什么是的呢？