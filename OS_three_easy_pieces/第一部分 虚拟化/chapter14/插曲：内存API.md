## 插曲: 内存API
在这个插曲中，我们会讨论UNIX系统中的内存分配接口。这些接口实现都很简单，因此本章很短并直达关键[<sup id="coentent1">1</sup>](#1)。我们要解决的主要问题是：
>### 症结：如何分配和管理内存
>在UNIX/C程序中，在构建健壮和可靠软件的过程中理解如何分配和管理内存是很关键的。哪些接口是常用的？需要避免犯什么错？

###14.1 内存的类型
在运行C程序时，有两类内存被分配。第一类叫做 __栈__ 内存，这个内存的操作(分配和解除分配)由编译器隐式的为你(程序员)管理，由于这个原因，它有时也叫做自动内存。

在C语言中，在栈上生命内存很简单。例如，你需要在函数`func()`内为一个整数(假设为x)分配空间。为了分配这个内存，你需要如下做：
```C
void func() {
int x; // declares an integer on the stack
...
}
```
编译器会处理剩下的事，确保在你调用`func()`时在栈上分配空间。当你从这个函数返回时，编译器为你解除分配这块内存；也即，如果你要某些信息生存期长过方法调用，你最好不要把信息留在栈上。

需要长时间存活的內存的需求让我们有了第二种类型的内存，__堆__ 内存，对内存的分配和解除分配都显示有你，程序员，操作。这无疑是一个很艰巨的责任。某些时候这会导致很多bug。但是，如果你仔细且耐心，你可以正确的使用这些接口而没有太多麻烦。这里有一个例子，在堆上分配一个指向整数的指针：
```C
void func() {
int *x = (int *) malloc(sizeof(int));
...
}
```
对这个代码段有一些解释。第一，你可能注意到了，在这一行中，既有栈内存分配又有堆内存分配发生：首先，当编译器看到你声明了一个指针(`int *x`)时，他就知道要为一个指向整数的指针分配空间，接着，当程序调用了`malloc()`，它在堆上请求为一个整数分配空间；这个例程返回了一个整数的地址(如果分配成功，否则失败的话返回NULL)，这个地址将存在栈上以供程序使用。

由于这个显式的特点，以及更多的各种使用方式，堆内存对使用者个系统提出了更多的挑战。因此，接下来的讨论我们将专注于此。

###14.2 `malloc()`调用
`malloc()`调用很简单：你传递一个数字给他作为想要在堆上分配的内存大小，如果它分配成功，就返回给你一个指向新分配空间的指针，如果失败，就返回NULL[<sup id="content2">2</sup>](#2)。

man手册会告诉你在使用`malloc`时你要怎么做，在命令行输入`man malloc`你将看到：
```C
#include <stdlib.h>
...
void *malloc(size_t size);
```
从这里你可以看到，使用`malloc`你只需要包含`stdlib.h`这个头文件。甚至，你甚至不必真的这样做，作为一个C库，每个C程序都会默认链接它，它包含了`malloc()`所需的代码；添加这个头文件只是为了让编译器检查你调用`malloc()`的方法是否正确(例如，传递了正确的参数数字给它以及正确的类型)。

`malloc()`使用了`size_t`类型作为它唯一的参数的类型，这个参数只是用来描述你需要多少字节。然而， 大多数程序员不会直接传入一个数字(例如10)；事实上，直接传入数字被认为是糟糕的。相反，各种例程和宏被利用。举个例子，为了给一个双精度浮点数分配空间，你只需要这样做：
```C
double *d = (double *) malloc(sizeof(double));
```
>### TIP:有怀疑的话，就实际试一下吧
>如果你不确定你正在使用的某些例程或者操作符的行为，没有比尝试一下来确保它的行为和你希望的一致更简单的办法了。当然，阅读手册或者其它文档当然有用，在实践中它是如何工作的更需要关心。编写一些代码并测试吧！这无疑是确保你的代码行为和你希望的一致最好办法。真的，这正是我们在双重检查我们讲述关于`sizeof()`确实是真的的时候所作的！

哇哦，`double`做了好多事情！对于`malloc()`的调用使用了`sizeof()`操作符来获取正确的空间数量；在C中，这通常认为是一个编译时操作符，这意味着在编译器知道了实际的尺寸，这个数字(在这个例子里，对于`double`是8)被替换为`malloc()`的实参。因为这个原因，`sizeof()`被认为是一个操作符而不是一个函数调用(函数调用发生在运行时)。

你可能也会传递变量名称(而不是一个类型)给`sizeof()`，但是，在某些情况下，你可能不会得到期望的结果，所以，要小心。举个例子，看看如下代码片段:
```C
int *x = malloc(10 * sizeof(int));
printf("%d\n", sizeof(x));
```
在第一行，我们为一个包含了是个整数的数组声明了空间，这很好并且很高级。然而，当我们在下一行使用`sizeof()`时，他返回的是一个很小的值4(在32位机器)或者8(在64位机器)。在这个情况中，`sizeof()`认为我们只是想要知道一个指向整形的指针大小，而不是我们动态分配的内存大小。但是，有时候`sizeof()`的行为又和你希望的一致：
```C
int x[10];
printf("%d\n", sizeof(x));
```
在这种情况下，编译器有足够的静态信息知道有40字节被分配了。

另一个需要注意的地方是字符串。当为字符串声明空间时，使用这个惯用法:`malloc(strlen(s)+1)`，通过`strlen()`获取字符串的长度，然后加1，这是为了字符串结束标识符。在这使用`sizeof()`可能会导致问题。

你可能注意到了，`malloc()`返回的是`void`类型指针。这是C语言使用的方法，用来回传一个地址，让程序员决定如何处理它。程序员使用 __类型转换(cast)__ 来转换成需要的类型。在我们上面的例子，程序员把`malloc()`的返回类型转换为`double`类型指针。转换实际上没有完成任何事情，除了告诉编译器和其它需要阅读你代码的程序员：“是的，我知道我要做什么。”通过转换`malloc()`的结果，程序员可以有某种安慰，对于正确性来说，转换不是必须的。

### 14.3 `free()`调用
事实证明，分配内存只是等式中简单的一部分，知道何时，如何，甚至是否释放内存是困难的部分。为了释放不会在使用的堆内存，程序员只需要调用`free()`：
```C
int *x = malloc(10 * sizeof(int));
...
free(x);
```
### 14.4 常见错误
在使用`malloc()`和`free()`的过程中，有一系列常见错误发生。这些错误在编译和运行时，编译器没有发出任何声音；对于构建正确的C程序编译C程序很必要，但是这远远不够，正如你将学到的(常常是以一种困难的方式)。

正确的内存管理已经成为了一个严重问题，事实上，有很多新语言已经支持了 __自动内存管理(automatic memory management)__。在这些语言，当你调用某些类似与`malloc()`的来分配内存(通常是 __new__ 或者其它类似的分配新对象)，你永远不用调用什么东西来释放空间；相反，一个 __垃圾回收器(garbage collector)__ 运行并找到那些内存你不再有引用并为你释放这些内存。

#### 忘记分配内存
很多例程都希望你再调用它们之前已经分配好内存了。例如，`strcpy(dst,src)`例程，它从源指针复制一个字符串到目的指针。然而，如果你不够消息，你可能这样做：
```C
char *src = "hello";
char *dst; // oops! unallocated
strcpy(dst, src); // segfault and die
```
当你运行这段代码，它会导致段错误(segmentation fault)[<sup id="content3">3</sup>](#3)，这是 __你这个愚蠢的程序员你操作内存时做错事了我很生气__ 的高级说法。
>### TIP:编译成功或者运行了 ≠ 它是正确的
>仅仅因为程序编译成功甚至是正确的运行了几次并不意味着程序是正确的。很多事件可能会一起导致一种结果，你以为它工作了，但是如果某些事情改变了他就会停止。一个常见的反应是：“他之前可以正常工作！”然后怪罪到编译器，操作系统，硬件，甚至教授。但是问题通常发生在你的代码里。在你抱怨其它组件前，先回去工作并调试你的代码。

在这种情况下，正确的代码应该如下：
```C
char *src = "hello";
char *dst = (char *) malloc(strlen(src) + 1);
strcpy(dst, src); // work properly
```
可选的，你可以使用`strdup()`让你的生活更容易些，查看这个调用的手册获取更多信息
#### 没有分配足够的内存
另一个相关的错误是没有分配足够的内存，有时候也叫做 __缓冲区溢出(buffer overflow)__.在上面的例子，一个常见的错误是，没有给目标地址缓冲区分配足够的内存。
```C
char *src = "hello";
char *dst = (char *) malloc(strlen(src)); // too small!
strcpy(dst, src); // work properly
```
很奇怪，根据`malloc`如何实现以及其它细节，这个程序常常看起来运行的很正确。在某些情况下，当执行了字符串复制，它会在已分配空间后多写一个字节，但是在某些情况下，这是无害的，可能覆写了一个不会再使用的变量。在某些情况下，这种溢出可能很严重，事实上，这也是系统中很多安全漏洞的源头。在另外的情况下，malloc库无论如何都会多分配一些额外的空间，这样你的程序就不会改写其他变量的值并且工作的很好。在其它极端情况下，这个程序确实会发生错误并崩溃。因此，我们学到的另外一个课：尽管它可能成功的运行一次，并不意味着它是正确的。
#### 忘记初始化已分配内存
这个错误是指，你正确的调用了`malloc()`，但是忘记在你新分配的数据类型中填充值。不要这样做，如果你忘记了，你的程序最终会遇到一个 __未初始化读(uninitialized read)__，它会从堆上读取不知道值的数据。谁也不知道这里会发生什么，如果足够幸运，这些值可能会让程序依旧工作(例如，零)。如果你不是很幸运，会出现有害的随机值。
#### 忘记释放内存
另一个常见错误是 __内存泄漏(memory leak)__。当你忘记释放内存就出现了泄漏。在长时间运行的程序或者系统(例如OS本身)，这是一个大问题，因为缓慢的泄漏内存最终会导致内存用完，此时，就需要重启。总的来说，当你用完了一块内存，你应该确保释放它。记住，使用有垃圾收集的语言在这种情况下也不会有帮助：如果你一直保持着内存块的引用，没有垃圾收集器会释放它，因此，在很多现代语言中内存泄漏依旧是一个问题。

在某些情况下，不调用`free()`看起来是合理的。例如，你的程序存活期很短，会很快退出；在这种情况，当进程死掉，OS会清理掉所有分配给他的内存页，本身也就不会发生内存泄漏。当然，这确实可以“工作”(参看下面的边注)，但这这个编程习惯很坏，所以，谨慎的使用这个策略。在长期运行中，作为一个程序员，你的一个目标是养成好的编程习惯；其中之一就是理解你是如何管理内存的，同时(在像C这样的语言)，释放你分配的内存块。尽管你不养成这种习惯也可以，但是，养成释放每一个你显式分配的每一个字节这一习惯是好的。
#### 没有结束使用内存就释放
有时候，程序会在还没有结束使用内存就释放它；这个错误叫做 __悬垂指针(dangling pointer)__，你可以猜到，这也是一个坏事情。接下来最这个内存的使用会导致程序崩溃，或者覆写合法的内存(例如，你调用了`free()`，但是然后再次调用`malloc()`分配内存，这可能会重新使用这个已释放的内存)。
#### 重复释放内存
有时候，程序会多次释放同一块内存；这被叫做 __双释放(double free)__。这样做的结果是未定义的。你可以想象，内存分配库会受到干扰并做一系列奇怪的事情，通常会导致崩溃。
#### 不正确的调用`free`
我们要讨论的最后一个错误是不正确的调用`free()`。你只用传递给`free()`一个你从`malloc()`接收到的指针就可以了。当你传入了其它值，不好的事情就会发生。这种 __不合法释放(invalid frees)__ 很危险，应当避免。
>### 边注：为什么一旦你的进程退出了就不会内存泄漏了
>当你在编写生存周期很短的程序，你可能使用`malloc()`分配了某些空间。程序运行直到完成任务，这里，在程序退出之前，有必要调用几次`free()`么？看起来不调用是错的，但在任何意义上，都没有内存会“丢失”。原因很简单：在系统中，有内存管理其实有两级。第一级内存管理是由OS执行的，在进程运行时，它把内存交给进程，当进程退出时(或者死掉)，它取回内存。内存管理的第二级存在于每个进程中，例如，当你在调用`malloc()`和`free()`时，存在于堆中，当程序结束运行时，操作系统会回收这个进程的全部内存(包括为代码，栈，以及此处更相关的，堆分配的内存页)。无论在你的地址空间中堆的状态如何，OS会在进程死掉的时候回收全部的内存页，这确保了即使你没有释放内存，也没有任何内存丢失。<br/>
>因此，对于运行时间短的程序，泄漏内存通常不会造成任何操作问题(尽管这被认为是不好的形式)。当你编写一个长时间运行的server(例如web server或者数据库管理系统，这些永远不会退出)，泄漏的内存将是严重的问题，并最终在应用耗尽内存后导致应用崩溃。当然，内存泄漏放生在一个特别的程序：操作系统本身中，将会是更加严重的问题。这向我们再一次展示了：编写内核代码是所用工作中最难的。。。
#### 总结
正如你看到的，存在很多方式滥用内存。由于有在使用内存中会频繁出现错误，有一整个生态圈工具被开发出来帮你在代码中找到这些问题。包括了 __purify__ 和 __valgrind__；它们在定位内存相关问题的源头表现出色。一旦你习惯了这些工具，你就会怀疑没有它们你要如何工作。
### 14.5 底层OS支持
你可能注意到了，在讨论`malloc()`和`free()`时，我们一直没有谈到系统调用。这个原因很简单：它们不是系统调用，只是库调用。因此，内存分配库只管理存在于你的虚拟地址空间的空间，它们本身是构建在某些系统调用之上，这些系统调用进入到OS内请求内存或者释放内存回系统。

其中一个系统调用是`brk`，它用来改变程序的 __间隙(break)__：堆的结尾位置。它接受一个参数(新间隙的地址)，然后根据新的间隙是大于还是小于当前间隙来增加或减少堆的尺寸。另一个调用`sbrk`接受的参数是一个增量，目的和`brk`类似。

记住，你永远不应直接调用`brk`或者`sbrk`。它们应由内存分配库使用；如果你尝试使用它们，你很有可能让事情变得极其糟糕。应该只是用`malloc()`和`free()`。

最后，你可以通过`mmap()`调用从操作系统获取内存。通过传递正确的参数，`mmap()`可以在你的程序里创建一个匿名的内存区域--一个和其它任何特别的文件都无关只跟 __swap space__ 有关的区域，我们将会在虚拟内存中讨论这个细节。这个内存可以看成堆并按照堆来管理。阅读`mmap()`手册获取更多细节。
### 14.6 其它调用
内存分配库还有其它几个函数调用。例如，`calloc()`分配的内存会被初始化为零，这可以避免某些错误，当你假设内存已经被置为零却忘记初始化内存它们为零(参看上面的“未初始化读”)。例程`realloc()`也很有用，当你已经为某些东西(例如，一个数组)分配了空间，然后还需要在增加一些东西，`realloc()`可以创建一个新的更大的内存区域，把旧的内存区域复制进来，返回新区域的指针。
### 14.7 总结
我们介绍了处理内存分配的某些API。跟以往一样，我们只是介绍了基础；更细节的东西参考其它资料。


[<sup id="1">1</sup>](#content1) 真的，我们希望所有的章节都是这样！我们认为但是这一章更进一步。

[<sup id="2">2</sup>](#content2) 记住，在C中NULL没有特别的意义，只是0这个值的一个宏。

[<sup id="3">3</sup>](#content3) 尽管听起来很神秘，你很快就会学到为什么这样的非法内存访问被叫做段错误；如果这不是继续读下去的动力，什么是的呢？