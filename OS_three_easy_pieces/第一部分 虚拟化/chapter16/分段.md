## 分段机制
到目前为止我们都是把每个进程整个地址空间放入内存中。通过使用基址和边界寄存器，OS可以很容易的重定位进程到物理地址不同位置上去。然而，你可能已经注意到了某些和我们那些地址空间有关的有意思的事：在栈和堆中间，有一大块空闲空间。

正如从图16.1中你可以想象到，尽管在栈和堆之间的空间没有被进程使用，它依旧会占据物理地址，当我们重定位整个地址空间到物理内存某处时；因此，使用基址和边界寄存器对这一简单办法虚拟化内存是很浪费的。当整个地址空间无法放入内存中，它也使得运行一个程序变得困难；因此，基址和边界没有我们想要的那么灵活。
>### 症结：如何支持大地址空间
>我们要如何支持一个在栈和堆之间有着(潜在)大量空闲地址的大地址空间呢？在我们的例子中，使用小(假装)地址空间，浪费还不是很严重。然而，想象一下，在一个32地址空间(4GB大小)；一个典型的程序只用使用数MB内存，但依旧要把整个地址空间驻留到内存中。
###16.1 分段机制：泛化基址/边界
为了解决这个问题，__分段机制(segmentation)__ 这个理念诞生了。这是一个很老的想法，要追溯到二十世纪69年代的早期，想法很简单：为什么不是地址空间每个逻辑 __段(segment)__ 都拥有一对基址和边界寄存器，而不是在MMU中只有一对基址和边界寄存器？一个段只是地址空间中特定长度的连续部分，按照权威的地址空间，我们有三个逻辑不同的段：代码，栈和堆。段允许OS可以在物理内存的不同部分放置这些段，这就避免了用不会使用的虚拟地址空间填充物理内存。
![一个地址空间](Figure16_1.png "一个地址空间")
让我们看个例子。假设我们想要把如图16_1的地址空间放到物理内存存中。通过每个段一对基址和边界寄存器，我们可以把每个段 _独立_ 放入到物理内存中。举个例子，参看图16_2；在那你可以看到一个包含三个段的64KB物理内存(还保留了16KB给OS)。
![把段放到物理地址中](Figure16_2.png "把段放到物理地址中")
从图中你可以看到，code段被放置到物理地址32KB处大小是2KB，heap段被放置到34KB处大小也是2KB。

让我们做一个样例转换，使用图16_1的地址空间。假设有一个指向虚拟地址100的引用(位于code段)。当引用发生(例如，一个指令取)，硬件将会使用基址值加到到这个段里的 _偏移量_ 上(在这个例子中，偏移量是100)从而到达想要的物理地址：100+32KB 或者是 32868。然后它会检查这个地址是在边界内(100是小于2KB的)，发现是在边界内，然后发出这个引用到物理内存地址 32868。
>附注：__段错误(segmentation fault)__
>词语段错误或者段违法是由在基于段的机器上非法地址上内存访问引起的。好笑的是，这个词汇甚至存在于那些不支持段机制的机器上。或者不是很好笑的，如果你无法找出你代码一直错误的原因。

现在，让我们看看在堆上的地址，虚拟地址4200(再一次涉及到图16_1)。如果我们只是简单的把虚拟地址4200和堆的基址(34KB)简单的相加，我们就会得到39016这个物理地址，这个地址是不正确的。我们首先需要做的是，从堆中减掉这个偏移量，也就是在这个段中地址引用的字节。因为堆从虚拟地址4KB(4096)开始,4200的偏移量实际上是4200-4096，也就是104。然后我们用这个偏移量，把它与物理地址基址寄存器相加(34KB)得到想要的结果：34920。

如果我们试图引用一个非法地址，例如7KB这个超过了堆结尾的地址，会发生什么？你可以想象会发生什么：硬件检测到地址越过了边界，陷入到了OS，会导致越界进程的终止。现在你知道了那个令所有C程序员都学会了恐惧的名词：__段错误 或 对非法__ 的来源。

### 16.2 我们引用的是那个段？
硬件使用在地址转换的时候使用段寄存器。它是如何知道段中间的偏移量呢以及地址正在引用哪个段？

一个常见的方法，有时候也叫做显式方法，它是根据虚拟地址开头几个bit把地址分成若干段；这个技术用到了 __VAX/VAS__ 系统中了。在我们上面的例子中；我们有三个段；因此，我们需要两个bit才能完成我们的任务。如果我们使用14位虚拟地址的前两个字节来选择段，我们的虚拟地址就给下面一样：

![虚拟地址示意](show16_1.png "虚拟地址示意")

在我们的例子中，如果开头的两位是00硬件知道虚拟地址位于code段中，然后使用code基址边界寄存器对重新定位地址到正确的物理位置。如果开头的两位是01，硬件就知道这个地址是在堆中，
然后使用堆基址和边界寄存器。让我们用上面堆虚拟地址(4200)来转换以下，以确保这些讲清楚了。虚拟地址4200的二进制形式如下：
![4200的二进制](show16_2.png "4200的二进制")
从图中你可以看到，开头的两bit(01)告诉硬件我们正在引用段是哪个。后面的13位就是这个段内的偏移量：0000 0110 1000，或者16进制0x068，又或者十进制下的104。然后，硬件就简单的用前两个bit来决定使用哪个段寄存器，然后取后12bit作为段内的偏移量。通过把基址寄存器和偏移量相加，硬件到达了最终的物理地址。记住，偏移量是的边界检查也变得简单了：我们可以简单的通过校验偏移量是否小于边界来判断，如果不小于，那么地址就是非法的。也就是说，如果基址和边界是两个数组(每个段有一个元素)，硬件可能使用如下代码来取得想要的物理地址
```c
// get top 2 bits of 14-bit VA
Segment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT
// now get offset
Offset = VirtualAddress & OFFSET_MASK
if (Offset >= Bounds[Segment])
RaiseException(PROTECTION_FAULT)
else
PhysAddr = Base[Segment] + Offset
Register = AccessMemory(PhysAddr)
```
在我们运行中的例子里，我们可以用常量填充上面的值。具体的说，`SEG_MASK`会设置为`0x3000`，`SEG_SHIFT`设置为`12`，然后`OFFSET_MASK`被设置为`0xFFF`。

