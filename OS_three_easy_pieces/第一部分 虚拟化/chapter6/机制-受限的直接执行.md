##底层机制:有限直接执行(Limited Direct Execution)

为了虚拟化CPU,操作系统需要以某种方式无缝地在同一时刻多个运行的任务之间共享物理CPU。基本的想法很简单:一个进程运行很小一段时间,然后运行另外一个等等。通过这种方式来**时分(time sharing)** CPU(By time sharing the CPU in this manner),就可以完成虚拟化。

然而,在构建这样的虚拟化机制的过程中还有些挑战。第一个就是性能:如何在不给系统增加过多负载的情况下实现虚拟化?第二个是控制权:如何能在保留对CPU的控制权的同时还能有效地运行进程?对于OS来说,控制权特别重要,因为它负责管理资源;没有了控制权,一个进程可以一直运行下去并接管机器,或者访问那些他无权访问的信息。在构建一个操作系统的过程中,拥有高性能的同时还拥有控制权是几个主要的挑战中的一个。
>#### 问题的症结:<br />如何高效的虚拟化CPU并保留控制权
>OS必须使用高效的方式虚拟化CPU并保留对系统的控制权。为了达到这个要求,需要来自硬件和操作系统的支持。操作系统通常会使用明智硬件支持来高效的完成工作。

### 6.1 基本技术:受限直接执行(limited direct execution)
为了让程序运行的像期望那样快,OS开发人员提出了一个技术,我们称为**受限的直接执行(limited direct execution)**。这里,直接执行意思是:直接在CPU上运行程序。当OS想要运行一个程序,它会在它的进程列表(process list)中创建一个进程条目(process entry),给这个进程分配内存,从磁盘加载程序代码到内存,定位程序入口(`main()`例程或者其他类似的),跳转到这个入口处,然后开始执行用户代码。下图显示了基础的(没有任何限制的)直接执行协议,使用一个普通的调用和返回来跳转到程序的`main()`稍后又返回到内核。

![直接执行协议(没有限制)](Figure6_1.png "直接执行协议(没有限制)")

听起来很简单吧?但这个方法给我们在寻求虚拟化CPU的路上制造了些问题。第一个很简单:如果我们只运行一个程序,OS如何确保程序不会做那些我们不想它做的事,同时还能高效的运行程序?第二个问题:当我们运行一个进程,操作系统如何在它运行期间停止它并切换到另一个进程,也既实现我们要求的用来虚拟化CPU的时分(time sharing)?

在后文回答这些问题的过程中,我们会对虚拟化CPU需要什么有更好的理解。在研发那些技术的过程中,我们还会了解到本章题目中"限制"的意思;如果不对运行中的程序有所限制,OS将不能再控制任何事,这就沦为了"库"——对于操作系统来说是非常可悲的状态。

### 6.2 问题#1:限制的操作
直接执行对于可以快速运行有着显然的优势;程序原生地运行在硬件CPU上,可以像期望的那样快速的运行。但是在CPU上运行程序会导致一个问题:如果进程希望执行一些受限的操作,例如向磁盘发起一个I/O请求,或者获取更多了系统资源例如CPU或者内存?

>#### 问题的症结:如何执行受限的操作
>一个进程必须有能力执行I/O和其他受限的操,但是,如果不给这些进程完整地控制系统的权限,OS和硬件应该如何合作来完成这个任务?

>#### 提示:使用保护控制转移(protected control transfer先这样翻译吧)
>硬件通过提供不同的执行模式(mode)来帮助OS。在**用户模式/用户态(user mode)**,应用程序不能完全访问硬件资源。在**内核模式/内核态(kernel mode)**,OS可以访问机器的全部资源。硬件提供能够**陷入(trap)** 到内核和**从陷入返回(return-from-trap)** 到用户模式程序的特殊指令,这些指令允许OS告诉硬件**trap table** 驻留在内存哪里。

一种方法就是简单的让任何进程在处理I/O和其它相关操作时可以做任何事。然而,这样做会妨碍到那些所需的各种系统的构造。举个例子,如果我们希望构建一个在取得访问文件权限之前检查权限的文件系统,我们就不能简单地让任何用户进程向磁盘发起I/O;如果我们这样做了,进程就可以直接读写整个磁盘,从而整个保护措施都丢到了。

我们采取的措施是引入一个新的处理器模式,叫做 **用户模式(user mode)**;运行在用户模式的代码对于它们能做的事是受限的。举个例子,当运行在用户模式,一个进程不能发起I/O请求;这样做的结果会导致处理器发起一个异常,OS就会杀掉这些进程。

和用户模式相对的是**内核模式(kernel mode)**,OS(或者是内核)运行在这个模式。在这个模式里面,代码可以做任何它想做的事,包括高权限操作例如发起I/O请求和执行各种受限的指令(instructions)。

然而,我们依旧留着问题:当一个用户进程希望执行高权限操作(例如读盘)时,它应该怎么做?为了让这成为可能,事实上,所有现代的硬件都给用户程序提供了执行**系统调用(system call)** 的能力。系统调用出现于Atlas这种古老的机器,它允许内核可以向用户程序仔细的暴露某些关键的功能,例如访问文件系统,创建和销毁进程,与其他进程通信还有分配内存。大多数操作系统提供了数百个调用(详情看POSIX标准);早期的Unix系统暴露了一组更简洁的子集,大约20个调用。

一个程序需要执行特殊的**trap** 指令来执行系统调用。这个指令同时就调入到内核并把权限提升到内核模式;一旦进入了内核,系统就可以任何所需的高权限操作了(如果允许的话),接着就会做调用这个指令的进程所要求的工作。一旦完成,OS调用一个特殊的**return-from_trap** 指令,这个指令会如你所希望那样,返回到之前的调用trap指令的用户程序中,与此同时,把权限等级降回用户模式。

当执行一个trap指令时,硬件需要仔细一点,因为它必须要确保保存了足够多调用者的寄存器,这样是为了在OS发起一个return-from-trap指令时能够正确的返回。举个例子,在X86上,处理器将会把程序计数器,标志(flags)和其它一些寄存器压栈到每个进程的内核栈;而return-from-trap将会把这些出栈并恢复用户模式程序执行(参见Intel系统手册了解更多)。其它硬件系统使用不同的协议,但是基本概念是类似的。
>#### 附注:为何系统调用看起来想过程调用
>你可能会想,为何调用一个类似于`open()`或者`read()`的系统调用,看起来像是调用一个典型的C语言过程调用;换句话,如果他看起来像是一个过程调用,系统如何知道它是系统调用,然后正确执行呢?简单的回答:它们是过程调用,但隐藏在内部的就是著名的trap指令了。更进一步,举个例子,当你调用了`open()`,你在执行C库的一个过程调用。这那里面,提供了系统调用,库函数和内核使用一个规定的调用协定(library uses an agreed-upon calling convention with the kernel)来把打开文件所需的参数放到众所周知的地方(栈上,或者特定的寄存器上),把系统调用数(system-call number)也放到众所周知的地方(再一次,栈上或者一个寄存器),然后执行前文提到的trap指令。部分C库使用手写的汇编程序做系统调用,这样,它们就需要仔细地遵守协议开发,如此才能正确的处理参数和返回值,同时执行硬件特定的trap指令。现在你知道了为何你不需要写汇编来陷入OS了,有人已经帮你写了。

这里还有一个重要的细节:trap是如何知道需要运行OS中的那个代码?显然,调用trap的进程不能指定要跳转到的地址(就想是在处理过程调用时那样),这样允许程序可以在内核中随便跳转显然是一个坏主意(想象一下,跳转到访问文件的代码,但是就在许可检查后面,事实上,这样的能力就会让一个恶意的程序员获取内核来运行任意的代码序列)。因此,内核需要仔细的管控代码在trap之上执行的东西。

内核通过在启动时设定一个**trap表** 来解决这个问题。当机器启动时,它在内核模式中做这个事,这样,它就可以根据需要自由的设置机器硬件。在OS需要最先做的一些事中,就有一个是要告知硬件在某些异常发生时需要执行什么代码。例如,如果发生了硬盘中断,当发生了键盘中断,或者程序发起了系统调用,应该执行,要执行什么代码?OS通知硬件这些**trap handlers(trap句柄)** 的位置,通常包括某些特殊的指令。一旦硬件被通知到了,他就会记住这些句柄的地址直到机器下一次重启,这样,当系统调用和其它异常事件发生时应该做什么了(例如,需要跳转到哪些代码)。

最后,能够执行指令通知硬件trap表在哪里是一个非常强大的能力。因此,它本身也是一个高权限操作,如果你试图在用户模式执行这个指令,硬件是不会同意的,你大概也能猜到会发生什么(提示:祝你一路顺风,讨厌的程序)。一个思考题:如果你能加载你自己的trap表,你可以对系统做出多可怕的事?你可以控制机器么?

![直接执行协议(没有限制)](Figure6_2.png "直接执行协议(没有限制)")

上图的时间线(向下时时间增长的方向)总结了这个协议。我们假设每个进程都有一个内核栈,当从内核进出时,这个栈可以用来保存和恢复寄存器(包括通用目的寄存器和程序计数器)。

上图中显示了在LDE协议中有两个阶段。在第一个阶段(启动时间),内核初始化trap表,然后CPU为了后续的使用记录了它们的位置。内核代码通过高权限指令完成这项功能(所有的高权限指令都已粗体显示)。

在第二阶段(当运行一个进程),内核在使用return-from-trap指令来启动进程执行体前会先设置一些事情;这些操作会把CPU切换成用户模式然后开始运行进程。当进程希望发起一个系统调用,它重新trap回OS,OS处理完这些请求然后再一次通过return-from-trap返回控制权给进程。然后进程完成它的工作然后从`main()`返回,这通常返回到一些桩代码(stub code),这些桩代码能够正确的从程序中退出(也既,通过调用`exit()`系统调用,也会陷入(trap into)到OS中)。在这里,OS会做后面的清理工作然后我们的事也就完成了。

### 6.3 问题#2:在进程之间切换
直接执行(direct execution)下一个问题是完成进程间的切换。进程间切换应该很容易,不是吗?OS应该只用决定停止一个进程然后启动另一个。有什么难的?但是这里其实有点难度:特别的,如果一个进程正在CPU上运行,通过定义可知,这意味着OS没有运行。如果OS没有运行,它又能做什么呢?(提示:他不能做任何事)这听起来是有点哲学了,它是一个真实的问题:显然如果OS没有在CPU上运行,他不能采取任何操作。我们遇到了这个问题的关键处了。
>#### 症结:如何重新获取CPU的控制权
>操作系统如果能够重新获取CPU的控制权,这样它就可以切换进程了?

#### 协作方式(A Cooperative Approach):等待系统调用
在过去,有些系统(例如早期版本的Macintosh操作系统,或者Xerox Alto系统)采取了一个叫做协作(cooperative)的方式来完成这项工作。用这种方法,OS_信任_ 系统中的进程会议合理的方式运行。OS会假设那些长时间运行的进程会定期的放弃CPU这样OS就可以决定运行其它的任务。

你可能会问,在这个乌托邦的世界里,一个有好的进程是如何放弃CPU的?事实证明,大多数进程会频繁地通过发起系统调用转移CPU的控制权给OS,举个例子,打开文件并读取,想另一个机器发送消息,或者创建一个新的进程。像这样的系统通常会包括一个显式的**yield** 系统调用,它的作用就是转移控制权给OS,以便OS可以运行其它进程。

应用在做出非法的事情时也会转移控制权给OS。例如,如果一个应用做了除零操作,或者尝试访问它不应该能够访问的内存,这些操作会生成一个trap到OS。OS就会再一次获取到CPU的控制权(很可能终止那个讨厌的程序)。
>#### tips:处理应用的错误行为
>操作系统常常不得不处理有着错误行为的进程,那些进程要么是这样设计的(恶意程序),要么是意外(bugs)尝试做那些它们不应该做的事。在现代系统中,OS通过简单的终止这些程序来处理这些恶意操作。一旦犯错你就出局了!这或许野蛮,但操作系统在你尝试非法访问内存或者执行非法指令时还能做其他的么?

也既,在协作调度系统中,OS通过等待系统调用或者某种非法操作产生来重新获取CPU的控制权。你可能会想:这种被动的方式会不会不那么理想?举个例子,如果一个进程(无论是恶意或者满是bug)以一个无限循环结束而且永不发起系统调用会发生什么?这时OS能够做什么呢?
#### 非协作方式:OS取得控制权
事实证明,没有硬件的额外帮助,当一个进程拒绝通过发起系统调用(或者犯错)把控制权返还给OS时,OS对此也是无能为力。事实上,在协作的方式里,当一个进程陷入到了无限循环里面时,你唯一的追求就是诉诸于古老的在计算机系统中所有问题的解决方案:重启机器。在我们追求获取CPU的控制权的过程中,我们又一次遇到了一个子问题。
>#### 症结:如何在没有协作的情况下获取控制权
>OS如何在即使进程不是协作的情况下获取CPU的控制权?OS如何确保一个疯狂的进程无法控制机器?

答案很简单,多年前由一些构建计算机系统的人发现:**定时器中断(a timer interrupt)**。一个定时器可以被编程为每隔几微秒就发起一个中断;当中断发起了,当前运行的进程被暂停,在OS中的一个预先配置的中断处理程序(interrupte handler)运行。在此时,OS就重新获得了CPU的控制权,这样他就可以做它想做的了,停止当前进程,启动另外的一个。
>#### tips:使用定时器中断重新获取控制权
>定时器中断的添加给了OS即使进程运行在非协作的情况下也能重新在CPU上运行的能力。在帮助OS维护对机器的控制权上,这个硬件功能是必要的(essential)。

在我们之前讨论过的系统同调用说过,OS必须通知硬件当一个定时器中断发生时需要执行哪个代码;在启动时,OS也是这样做的。第二,也是在启动过程中,OS必须启动这个定时器,这当然是一个高权限操作。一旦定时器开始了,OS就会觉得安全了,因为控制权最后总是会返还给他,这样OS就可以自由的运行用户程序了。定时器也可以被关闭(当然这也是一个高权限操作)--当我们了解更能多的兵法细节后再来讨论这个问题。

注意,当一个中断发生时,硬件也有工作要做(这里用了responsibility,更多的意味着硬件也有事情要做)。特别地,当中断发生时,它们要保存正在运行的程序足够的状态,这样,后面的return-from-trap指令就能够正确地恢复这个运行的程序。这一系列的操作有点类似于当一个显式的系统调用陷入到内核中硬件的行为,伴随着各种寄存器被保存(例如,保存在内核栈上)同时也容易从return-from-trap指令中恢复。

#### 保存和恢复上下文(saving and restoring context)
现在,OS已经重新获得了控制权,无论是协作式的(通过一个系统调用),或者更加强力的(通过定时器中断),需要做出决断了:是继续执行当前运行的进程还是切换成别的。做出这个决定的是操作系统中被称为**调度器(scheduler)** 部分;我们将要在接下来的几章事无巨细地讨论调度协议。

如果决定切换进程,OS就会执行我们称之为**上下文切换(context switch)** 的低层(low-level)代码。上下文切换的概念很简单:OS所需要做的事就是为当前正在执行的进程保存几个寄存器的值(例如,保存在他自己的内核栈),恢复即将被执行的进程的寄存器值(从她的内核上)。通过这样做,OS就可以确保当最终执行了return-from-trap指令,系统恢复执行的是另外的进程而不是刚刚正在执行的程序。

为了保存当前正在运行的进程的上下文,操作系统需要执行一些底层汇编代码,来保存通用寄存器,PC(程序计数器)以及当前正在运行进程的内核栈指针,然后为了即将执行进程恢复它的上述通用寄存器,PC,并切换到它的内核栈。通过切换栈(内核栈)，内核在一个进程（被中断的进程）的上下文中调用切换代码，并返回到另一个进程的上下文中（即将执行的进程）。当最终OS执行了return-from-trap指令,即将执行的进程变成了当前运行的进程。这样,上下文切换完成了。

![直接执行协议(定时器中断)](Figure6_3.png "直接执行协议(定时器中断)")

上图展示了这个处理过程的时间线。在这个例子中,进程A正在运行,然后被定期中断给中断了。硬件保存了它的寄存器(在内核栈上)然后进入了内核(切换到了内核模式)。在定时器中断处理程序中,OS决定从A进程切换到B进程。在这时,他调用`switch()`例程,这个程序会小心的保存当前的寄存器值(保存到A的进程结构中)恢复B进程的寄存器(从它的进程结构条目(entry)),然后切换上下文--特别地,这一操作是通过改变栈指针来使用B的内核栈(而不是A的)完成。最后,OS return-from-trap,然后恢复B的寄存器并开始运行它。

注意,在这个协议发生过程中,这里有两类寄存器存取操作。第一类发生在定时器中断发生时,在这里,正在运行的进程的_用户寄存器(user registers)_ 隐式低由硬件通过使用这个进程的内核栈来保存。第二类发生在OS决定从A切换到B中,在这里,_内核寄存器(kernel registers)_ 通过软件(例如,OS) 显式的保存到内存中这个进程的进程结构体中。后一个操作改变了系统似乎是从A进程陷入内核的情况为好像是从B陷入到内核中的(The latter action moves the system from running as if it just trapped into the kernel from A to as if it just trapped into the kernel from B)。
```assembly
 # void swtch(struct context **old, struct context *new);
 #
 # Save current register context in old
 # and then load register context from new.
 .globl swtch
 swtch:
 # Save old registers
   movl 4(%esp), %eax # put old ptr into eax
   popl 0(%eax) # save the old IP
   movl %esp, 4(%eax) # and stack
   movl %ebx, 8(%eax) # and other registers
   movl %ecx, 12(%eax)
   movl %edx, 16(%eax)
   movl %esi, 20(%eax)
   movl %edi, 24(%eax)
   movl %ebp, 28(%eax)
  
   # Load new registers
   movl 4(%esp), %eax # put new ptr into eax
   movl 28(%eax), %ebp # restore other registers
   movl 24(%eax), %edi
   movl 20(%eax), %esi
   movl 16(%eax), %edx
   movl 12(%eax), %ecx
   movl 8(%eax), %ebx
   movl 4(%eax), %esp # stack is switched here
   pushl 0(%eax) # return addr put in place
   ret # finally return into new ctxt
```
为了让你更好的理解切换是如何发生的,上面的代码显示了xv6的上下文切换代码。看看你有没有理解一些了(你需要一些x86和xv6的知识)。`old`和`new`这两个`context`结构体分别都在旧的和新的进程的进程结构体找到了。
### 6.4 关心并发?
作为一个细心且善于思考的读者,你可能现在会想"嗯...如果在一个系统调用执行时发生了定时器中断,会怎么样?"或者"如果你正在处理一个中断时发生了另一个中断会怎样?在内核中,这样会不会让处理过程变得麻烦?"。好问题,现在我们真的对你有所期待了!

答案是肯定的,OS确实需要关注如果在中断或陷入处理(trap handling)期间另一个中断发生了会发生些什么。事实上,这是本书关于并发的整个第二部分的一个确切的主题,我们回到那时再详细讨论。

为了吊你的胃口,我们先只大概地描述一些基本的关于OS如何处理这些狡猾的场景。OS可能会做的一个简单的事情就是在中断处理过程中**禁用中断(diable interrupts)**;这样做可以确保当一个中断正在处理时,不会有另外一个中断提交给CPU。当然,OS必须要仔细做这件事;禁用中断太长时间可能会导致失去中断,这用技术术语来说,是不好的。

操作系统也开发了一些复杂的锁方案来保护并发访问neibushujujiegou。这确保了在内核中同时进行多项活动,对于多核处理器来说特别有用。正如我们将在本书关于并发的下一部分中所看到的,然而,这些锁机制可能会很复杂并导致各种有趣难以查找的bug。
>#### 附注:上下文切换会花费多长时间?
>你可能会有一个很自然的问题:上下文切换会花费多长时间?甚至是一个系统调用?对于那些有疑惑的人,有一个叫做Imbench的工具可以确切的测量这些事情,同时也有其他一些相关的性能测试工具。
>随着时间的推移,结果是一直有所改善,大致上是跟处理器性能相关联。举个例子,在1996年,运行在200-MHZ P6 CPU 的Linux 1.3.37的系统调用大概会花费4微秒,上下文切换大概是6微秒。现代操作系统基本上有数量级的提升,在2-或者3-GHZ的处理器上大概是半微秒。
>需要注意的是,并不是所有的操作系统操作都是跟随者CPU的性能(提升的)。正如Ousterhout所观察的,很多OS操作都是内存敏感的,同时内存带宽并没有想处理器那样随着时间有着大幅提升。也就是说,根据你的工作,可能买一个最新最好的处理器并不一定会如你所愿那样快速的提升你的OS速度。

### 6.5 总结
我们已经描绘了一些实现CPU虚拟化关键的底层机制,一组我们通称为**受限直接执行(limited direct execution)** 的技术。基本概念是很直接的:只运行你想要在CPU上运行的程序,但首先要确保要设置硬件,以便在没有OS的帮助下,限制进程可以做执行的操作。

通用的方法来自于真实的生活。举个例子,对于那些有孩子的人来说,或者至少,听过孩子的人,可能对婴儿安全房(指的是对婴儿安全房子)这个很熟悉:锁住那些放入了危险物品的橱柜,盖住所有的电插座。当一个房间是按照这样准备的,你就可以自由的让你的孩子在房间里自由的玩耍,确保在知识中房间里最危险的方面都收到了限制。

类似的方式,OS也对CPU采取了"婴儿验证"(上文的婴儿安全房原文是baby proof),首先(在启动的时候)设置了trap处理程序并启动了一个中断定时器,然后只在受限的模式下运行进程。通过这样做,OS可以相当确认进程可以高效的运行,只在到了需要执行高权限操作时或它们占领了CPU很长时间需要被切换时才请求OS介入。

我们已经有了将CPU虚拟化的基本机制了。但是还有一个主要的问题没有回答:在给定的时间,我们应该运行哪个进程?这个问题是调度器必须要回答的,在下一个主题里我们将要学习。
>#### tips:重启好使
>早些时候,我们注意到在协作式抢占(cooperative preemption)下解决无限循环(或者类似的行为)的唯一方法是重启机器。你可能会嘲笑这个技巧,研究者已经显示了重启(或者更一般的,启动软件的一部分)对于构建一个稳定(robust)系统来说是一个非常有用的工具。
>特别的,重启之所以有用,是因为它让软件重新回到了已知的且很可能也是测试过最多的一个状态。重启也回收了陈旧的或者泄露的资源(例如,内存),这些资源可能很难被处理(在没有重启时)。最后,重启很容易自动化。由于以上原因,在大规模互联网集群服务中,那些系统管理软件为了重新设定它们并获取上面列出的优点而定期的重启一部分机器并不是不常见。
>因此,下一次你重启,你并不是在执行某些丑陋的技巧。相反,你正在使用一个经历过时间测试的有效提升计算机系统行为的方法。做的好!