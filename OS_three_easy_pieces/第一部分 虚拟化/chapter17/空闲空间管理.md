##空闲空间管理
本章，我们先绕开关于虚拟化内存的讨论，讨论一下任意内存管理系统--无论它是一个内存分配库(管理一个级进程堆的页)--的一个基础方面。具体来说，我们将要讨论围绕着 __空闲内存管理(free-space management)__ 而产生的问题。

让我们让问题更具体些。管理空闲空间可以很容易，正如我们当我们讨论 __分页(paging)__ 这一概念时你将看到的。当你正在管理的空间被分割成固定大小单元时，内存管理是很容易的；在这种情况下，你只用保持这些固定大小单元的列表；当客户端请求其中一个，你就返回第一个条目。

让空闲空间管理变得更加困难(也跟有趣)的是，但你管理的空闲空间是由可变大小单元组成的；这发生在用户级内存分配库(如在`malloc()`和`free()`)以及使用 __分段机制__ 管理物理内存的OS中。在这两个例子中，会发生被叫做外部碎片化的问题：空闲空间被分割为少量不同尺寸从而造成碎片；接下来的请求可能会失败，因为没有单一连续空间可以满足要求，甚至即使空闲空间的总大小超过了请求所需大小。
![内存布局](show17_1.png "内存布局")
这个图显示了这个问题的一个例子。在这种情况下，空闲空间总数是20字节，不幸的是，他被分成了大小各10字节的两块。结果是，一个需要15字节的请求将会失败，即使有20字节空闲。因此，我们遇到了本章要解决的问题。

>症结：如何管理空闲空间
>空闲空间应该如何管理，当为了满足大小会变化的请求？可以采用哪些策略来最小化碎片？各个方法的时空开销是多少？

### 17.1 假设
我们假设一个基本接口，例如由`malloc()`和`free()`所提供的。具体来说，`void *malloc(size_t size)`使用一个参数`size`(它是应用请求的字节数量)并返回一个指针(没有特定的类型，用`C`的术语，就是 __空指针(void pointer)__)指向一个区域(大小等于或大于`size`)。另一个例程`void free(void *ptr)`使用一个参数然后释放相应块。记住这个接口隐含内容：用户，不需要通知库空间的尺寸，当它释放空间时；因此，库必须有能力算出内存块多大，当手中有的只是一个指向块的指针。我们将在本章稍后讨论做到这一点。

这个库所管理的空间历史上被叫做`heap`，在堆内用来管理内存的通用数据结构是某种 __空闲列表__。这个结构包含了在所管理内存区域中空间的所有空闲块。当然，这个数据结构本身并不比是一个列表，只用是某种用来跟踪自由空间的数据结构。

我们进一步假设我们主要关心外部碎片。分配器当然也会有内部碎片；如果分配器返回的内存块比所需的要大，在这样的块中，任何没有要求(也就不会使用)的空间被认为是内部碎片(因为浪费发生在已分配单元内部)并且这是空间浪费的另一个例子。然而，为了简单，同时也因为外部碎片化是两种碎片化类型中更有趣的一种，我们跟多关注外部碎片化。

我们也假设一旦内存交给了客户端，他就不会被重定位到内存其它地方了。举个例子，如果一个程序调用了`malloc()`并且提供了一个指向堆内部的某个地址，那么那个内存区本质上由这个程序所拥有(并且不能被库移动)知道程序通过相应`free()`调用返回了它。因此，__压缩compation__ 空闲空间(对于对抗碎片化是有用的)是不可能的。然而，压缩可以用在OS内，用来处理碎片化，当实现了分段机制(我们在分段中讨论过了)。

最后，我们假设分配器管理额连续的字节区域。在某些例子，一个分配器可以要求区域增长；例如，一个用户级内存分配库可能调用到内核来增长堆(通过系统调用，例如`sbrk`)当它用完了空间。然而，为了简单，问哦们假设内存区域在整个生命周期都是单一固定大小的。