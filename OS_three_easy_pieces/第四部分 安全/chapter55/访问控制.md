## 访问控制(access control)
本章由Peter Reiher(UCLA)撰写
### 55.1 介绍
所以我们知道了我们的安全目标是什么，我们对我们想要实施的安全策略至少有了大概的感觉，并且我们还有证据表明正在请求各种系统服务的人员可能(或者可能没有)违背我们的策略。现在我们需要拿着这些信息将它们转换为一些可执行的东西，一些可以为我们执行的软件片段。
这里有两个比较重要的步骤：
1. 判定这个请求是否适合我们的安全策略。
2. 如果是，执行操作。否则，确保请求不会被执行。
第一步通常叫做 __访问控制(access control)__。我们将判断什么组织能够以何种方式在哪种情况下可以访问哪个系统资源或者服务。基本上，它归结为另一个非常适合我们计算范式(computing paradigms)的二元决定：是或否。但是，如何制定这个决策呢?为了让问题更具体些，考虑这个例子。用户X希望读写文件`/var/foo`。在底层，这个例子可能意味着一个在用户X的标识下运行的进程发起了以类似如下的系统调用:
```c
open("/var/foo",O_RDWR);
```
这里注意，我们没有讨论Linux的`open()`系统调用，它是以一个特定方式处理访问控制的特定实现。我们讨论的是你可能能够访问控制一个文件打开系统调用的更一般的方式。所以为了提醒你使用了不同的字体。

系统应该如何处理来自进程的这个请求，从而确保在实施了的安全策略拒绝了这个请求时，文件不会被打开，但是同样还要确认如果策略允许了这个请求文件是被打开的?我们知道系统调用会陷入到内核，只给了内核机会可以做一些事情来决策。机械地说，这些"事情"应该是什么?
>#### 问题的症结：如何判断一个访问请求是否应该被授予?
>操作系统如何才能判断如果在某个给定的时刻属于由某个特定用户的特定进程发起的特定请求应该或者不应该被授予?会使用什么信息做出决策?我们要如何设置这个信息来编码我们想要为系统实施的安全策略呢?

### 55.2 访问控制的一个重要方面
和平常一样，系统会运行某种算法做出决策。它需要一些输入，然后做出一个二元决策，一个对授予访问 是-或-否 的决定。在高层，谈论访问控制通常会用到 __主体(subjects)__，__对象(objects)__ 和 __访问(access)__ 这些词汇。一个subject是想要执行访问的实体，可能是一个用户或者进程。一个object是subject想要访问的对象，可能是一个文件或者一个设备。access是处理这个object的一个特定模式(mode)，例如读取它或者修改它。因此一个访问控制决定就是关于是否允许某个特定subject对某个特定object执行一个特定access模式。我们有时候将判定是否允许某个特定subject对某个特定[<sup id="content1">1</sup>](#1)object执行一个access的特定形式的进程叫做 __授权(authorization)__。

一个相关的问题是，什么时候会做出访问控制的决定?无论系统使用的是什么算法，系统在每次做这种决定的时候都要运行它。实现了这个算法的的代码叫做 __引用监视器(reference monitor)__，这是一个明显的动机，保证算法的实现正确快速。如果不正确，你就做出了错误的访问决策-显然很糟。它的效率也很重要，因为只要使用它，他就会引入一些开销。可能我们希望通过不是在每一次可能的机会都检测访问控制来最小化这种开销。另一方面，回忆下我们在前面几章介绍的全面介入(complete mediation)的原则?这个原则说我们应该在每次有人请求资源的时候都要检查安全条件。

显然，我们需要平衡开销和安全收益。但是，如果我们可以找到某个有意义的特殊情况，在那种情况下，我们可以在不违背安全的情况下完成低开销，我们可能管理避免在二者之间做取舍，至少在那些情况下。

达成这个的一个方式是给予subject只属于它们的objects。如果object本质上是他们固有的，而且是不可改变的，那么系统就可以让subject（在操作系统的情况下，一个进程）自由地访问它[<sup id="content2">2</sup>](#2)。(If the object is inherently  theirs,by its vary nature and unchangeably so,the system can let the subject(a process,in the operating system case)access it freely)虚拟化允许我们创建这种类型的虚拟对象。虚拟内存是一个极好的例子。一个进程被允许自由的访问自己的虚拟内存，在进程尝试使用内存的时候，不需要特殊的操作系统访问控制检查。这是也是好事，因为不是这样的话我们需要对每个进程引用都运行我们的访问控制算法，这会导致荒谬的慢的系统。我们可以对外设使用类似的虚拟化技巧。如果一个进程被给予访问某个虚拟设备，而这个虚拟设备实际上是由OS控制的一个真实的物理设备支撑，如果没有其它进程被允许使用那个设备，操作系统不需要在每次进程想要使用它的时候检查访问控制。例如，基于初始访问控制决策，一个进程被授予对GPU的控制，那么后面这个进程可以写GPU的内存或者直接发送指令给GPU而不需要后续OS的介入。

当然，就像前面讨论的，虚拟化基本就是操作系统提供的一个幻象。进程共享内存，设备以及其它计算资源。看似属于他们自己的资源实际上是共享的，在幕后是操作系统在周围运行才能保持这个幻象持续，有时候还需要来自特殊硬件的帮助。这意味着操作系统没有直接的知识和参与应用使用这个虚拟资源，一就必须要确保只有合适的访问形式被允许。因此仅仅依靠虚拟化确保合适的访问仅仅是把问题下推到OS对虚拟化功能的保护。即使我们将这个问题放到一边，迟早我们不得不离开过去便宜的特殊情况并处理一般的问题。Subject X想要读写object `/tmp/foo`。肯能他被允许，可能不?现在要怎么样?

计算机科学家已经提出了两个基本方法解决这个问题，依靠不同的数据结构和不同的指定决策的方法。一个叫做 __访问控制列表(access controll list)__ 另一个叫做 __能力(capabilities)__。实际上说是计算机科学家提出了这些方式有些错误，因为它们已经在非计算机领域中使用了近千年。让我们在考虑操作系统实现前，用一个更普遍的观点看看它们。

让我们说我们想要开一个独有的夜店(可能，叫做 Chez Andrea[<sup id="content3">3</sup>](#3))，这个夜店只允许最好的操作系统研究员和开发人员进。我们不想让任何数据库或者编程语言的人偷偷进来，因此我们需要确保只有我们认可的客户可以通过大门。我们要怎么做?一个做法是雇佣一个让人畏惧的魁梧保镖，他有着被认可人员列表。当有人想要进入到俱乐部，它们会给保镖提供证件，保镖会看看它是否在列表上。如果是Linus Torvalds或Barbara Liskov，保镖就让它们进去，但是会拦着那些没有在操作系统中出类拔萃的一大波网络人士拒之门外。

另一个方式是在俱乐部大门上装一个巨大的锁，将钥匙送给我们的OS兄弟。如果Jerome Saltzer想要进到Chez Andrea中，它只需要拿出钥匙打开锁。如果某个没有OS经验的计算机架构师想要进去，由于没有钥匙就只有堵在门外。和其他方式相比较，我们省下了保镖的薪水，尽管我们需要购买锁和钥匙[<sup id="content4">4</sup>](#4)。随着在OS领域中出现我们想认可的新的杰出人物，我们需要新的钥匙，而一旦我们偶尔犯了错误，把钥匙递给了某个不应该有钥匙的人，又或者某个成员丢了一把钥匙，在这些情况下我们需要确保钥匙将不再可以打开俱乐部的门。

同样的想法可以用在计算机系统中。早先的计算机科学家决定称呼像锁和钥匙的那种方式叫做 __基于能力的系统(capability-based system)__，而基于保镖和列出了许可的表的方式叫做 __访问控制列表系统(access control list system)__。能力就类似于钥匙，电影票，地铁票。访问控制列表就类似于，emmm，列表。这个在操作系统中是怎么工作的呢?如果你使用能力，当一个属于用户X的进程想要读写文件`/tmp/foo`，它给这个系统提供了针对这个文件的特定能力。(你可能会问，在这个上下文中具体是哪个能力?好问题!我们会回答它。)如果你使用访问控制列表(简写 __ACLs__)，系统在一个和`/tmp/foo`相关的ACL上查找用户X，只有用户在ACL上才允许访问。在这两个情况中，这个检查会在需要访问(`open()`调用，在我们的例子中)的时候执行。这个检查会在陷入操作系统后，并在访问被实际允许前执行，如果访问控制检查失败就会尽快失败并返回错误码。

在一个高的层级，这两个选项可能听起来没有这么多差异，但是当你开始考虑你需要运行的算法，以及支撑这些算法要求的数据结构，你就会很快发现有主要的不同。让我们按顺序查看它们。

### 55.3 使用ACL做访问控制
如果按照英国老式俱乐部的传统，Chez Andrea除了提供图书馆、餐厅、台球厅和其他共享空间外，还为每个会员提供自己的私人房间，会是怎样的呢？在这种情况下，我们需要确保不仅仅只有成员可以进入到俱乐部中，还要防止Ken Thompson(以顽皮著称)偷偷溜进Whitfield Diffie的房间在床上恶作剧(short-sheet his bed)。我们可以有一个巨大的访问控制列表，指明了每个房间允许访问的人，但这会导致不可管理。相反，为什么不对俱乐部中每个房间都设置一个ACL呢?

对于依赖ACL做访问控制的典型操作系统，我们对文件使用了同样的方式。每个文件都有自己的访问控制列表，这导致了一个更简单，更短的列表以及更快速的访问控制检查。所以在一个ACL系统中我们的`open()`调用会检查`/tmp/foo`的列表，而不是一个编码了系统中每个文件的所有访问的ACL。

当系统调用陷入到操作系统中，OS检查运行进程的PCB判断谁拥有这个进程。这个数据结构标识了用户X拥有这个进程。系统必须要持有`/tmp/foo`的访问控制列表。这个ACL更多的是文件元数据，类似于我们在"文件与目录"那章讨论的。因此他很可能就和其它文件元数据存放在一起或者靠近它们。以某种方式，我们取得了从持久化存储中取得了这个列表。现在我们在列表中查找X。X要么在这要么不在。如果不在，X就不能访问。如果在，通常我们要进一步判断X的ACL条目是否允许请求的访问类型。在我们的例子中，X想要读写`/tmp/foo`。可能ACL允许X读但不允许X写。在这种情况下，系统会拒绝访问然后返回一个错误给进程。

原则上，这不复杂，但是想起来细节是魔鬼了么?这里也有。考虑某些细节。例如，ACL持久化存储的到底是什么?它必须对于大多数资源来说确实是真的要持久化，因为ACL高效的编码了我们选择的安全策略，它不太可能经常变化。因此它会存放在闪存或者硬盘中。除非它被缓存了，每次有人试图打开这个文件的时候，我们都需要从设备中把它读取出来。在大多数文件系统中，就像我们在讨论持久化中段落中说过那样，为了真正的从一个文件中获取信息，你本来就需要几次设备读取操作。我们还需要另一次读取操作来获取文件的ACL么?如果需要，我们在设备的哪个地方存放ACL才可以保证快速访问?如果它靠近，甚至是我们已经读取到的内容的一部分，就非常好了，这就提供了少量的几个可能位置以供选择：文件的目录条目，文件的inode，或者坑你是文件的第一个数据块。最少，我们希望ACL靠近这些位置中的一个，如果它就在这些地方中的一个，例如inode，那就更好了。

这导致了另一个让人烦恼的细节：这个列表要多大?如果我们做的是很直接的事情，创建一个实际用户ID和访问模式的列表，大体上这个列表可以变成任意尺寸，最多是系统已知的用户数量。对于某些系统，这可能就是数千个条目了。但是一个文件一般是属于一个用户，并且通常只对那个用户，可能还有几个朋友，可用。所以我们不想在每个ACL张都保留足够的空间以容纳所有可能被列入到其中的用户，因为大多数用户在大多数ACL中都不会出现。当然，还是有例外：大部分文件对所有用户在某些模式中(可能是读或者执行)应该是可用的。毕竟，常见的可执行命令(例如`ls`和`mv`)都存放在文件中，并且我们会对它们应用访问控制，就像其他文件一样。我们的用户可能会共享一样的字体文件，网络配置文件，等等。我们要允许所有用户访问这些文件否则他们在系统中就没法做太多事情了。


因此，直接的实现会保留一个大的每文件列表(per-file list)，对某些文件它会被填满，而对于其它文件几乎就是空的。这就很浪费了。对于几乎是满了的列表，这里还有另一个要担心的细节：每次我们想要检查列表中的访问控制，我们都需要搜索它。现代计算机可以很快的搜索完一个包含了一千个条目的列表，但是如果每次我们都要执行这样的搜索，我们会对我们的系统增加很多不需要的开销。我们可以通过可变大小的访问控制列表解决这个问题，对每个列表只分配需要的空间。花点时间想一下你会如何适配这样的元数据到我们已经学习过的文件系统类型中，以及它对性能的影响。

幸运的是，在大多数情况下我们可以从来自最初的贝尔实验室Unix系统传给我们的遗产中受益。回到最初那些计算机科学巨人还在地球(或者至少是新泽西的一部分)漫步的时候，持久化存储供应不足且价格昂贵。他们根本无法负担得起为每个文件存储巨大的ACL。事实上，当他们计算完，他们发现只能为每个文件的ACL负担得起9bit。9bit没有超出太多，但是幸运的是那些早期Unix设计者十分聪明可以弥补硬件的缺失。它们思考了问题并指出他们关心的实际上有三种访问模式(对于大多数文件而言，就是读，写和执行)，并且他们可以在每个访问控制列表上只用三个条目就处理大多数安全策略。当然，如果他们是以一个条目一个访问模式一个bit的方式使用，他们可能早就用完了9个bit，没有空间指明这个条目归属于谁。所以他们很聪明的对访问控制列表分为了三组。一个是文件的拥有者，他的标识符已经存放在了`inode`中了。一个是特定组或者用户们的成员；这个组ID也已经存放在了`inode`。最后一个是其它人，例如所有除了文件拥有者和拥有者所在组成员的人员。不需要任何bit存储这个信息，因为它就是用户和用户组的补集。

这个方案不仅仅解决了ACL对存储占用量的问题，还解决了访问和检查它们的开销问题。为了对文件执行任何操作，你已经需要读取这个文件的inode了，因此，如果ACL是嵌入在inode中的，就不需要额外的查找和读取了。而且，不需要搜索一个任意大小的列表，对少量bit的一点简单逻辑就可以回答访问控制问题了。并且这个逻辑在这些年一直在为那些使用Posix兼容文件系统的大多数系统提供了答案。当然，这个方式有自己的限制，因为他不能表达复杂的访问模式和共享关系。对于这个原因，某些现代系统(例如Windows)允许扩展，这个扩展许可了对更一般的ACL的使用，但是很多还是依赖经过考验的Unix式的9bit ACL[<sup id="content5">5</sup>]。

ACL有一些好的功能以及一些限制。先说好的。首先，假如你想要查找谁被允许访问一个资源?如果你正在使用ACL，这个答案很容易回答，因为你只用查看ACL自身。第二，如果如果你想要修改可以访问一个object的subjects集合，你仅仅需要修改ACL，因为没有别的可以给予用户访问。第三，因为ACL通常要么是和文件保存在一起，要么是靠近文件，如果你可以得到文件，你可以得到所有和访问控制相关的信息。这在分布式系统中特别重要，但是对所有系统来说也是一个很好的性能影响，只要你的设计保持ACL靠近文件或文件的inode。

现在说一下不可取的功能。首先，ACL要求你解决我们前面提到的问题：不得不将这个访问控制信息存储在靠经文件的地方，并且处理长列表潜在的昂贵搜索。我们已经描述了实际的解决方案可以在大多数系统中工作的很好，但是这些方案限制了ACL可以做的事情。第二，如果你想要知道某个principal(一个进程或者一个用户)是否对整个资源集合都有权访问呢?你需要检查系统中每个ACL，因为pincipal可以会访问它们中的任意一个。第三，在分布式的环境中，为了使ACL有效，你需要有一个横跨所有机器的共通的身份视图(a common view of identity across all the machines for ACLs to be effective)。如果一个在`cs.ucla.edu`的用户想要访问一个存放在`cs.wisconsin.edu`的文件，这个威斯康星机器会检测由UCLA提供的某个身份标识对比存在威斯康星的访问控制列表。位与UCLA的用户`remzi`确实和在威斯康星的用户`remzi`指向的是同一个principal么?如果不是，你可能允许一个远程用户访问了他不该访问的内容。但是尝试维护一个跨多个不同计算域的一致的用户名称空间很有挑战。

>>#### 附注：名称空间(name spaces)
>>我们刚刚遇到了在分布式系统中那些有趣且困难的问题中的一个：在不同的机器上，名字意味着什么?__名称空间(name space)__ 问题在单个计算机上面相对容易。如果为一个新事物选择了已经使用过的名字，计算机是不允许这种赋值的。因此，在那个系统上由任意用户或者进程发起的特定名称，它代表的是同一个事情。`/etc/password`对于你以及你电脑上的所有其他用户来说是同一个文件。
>>但是对于由多个计算机组成的分布式系统来说又是什么情况呢?如果你想要得到同样的保证:所有人都知道的唯一名称，你就需要确保某个人你在位与UCLA的机器上不会创建一个已经在威斯康星大学使用过的名字。怎么做到这个?不同的答案有不同的优缺点。一个方式是不要操心它并且理解名称空间是不同的--举个例子，这就是我们用进程ID所做的事情。另一个方式是请求一个授权批准名字选择--这或多或少就是AFS处理文件名创建的方式。另一个方式是给每个参与者都划分出一部分名字空间，每个参与者可以使用得到的名字空间中的任意值，但是不允许使用其他人的名字空间--这就是万维网(World Wide Web WWW)以及IPv4地址空间处理这个问题的方式。这些答案没有对错。针对你的需求设计名称空间，但是要理解相关的影响。

### 使用能力(capabilities)进行访问控制
访问控制列表在计算机系统内不是访问控制的唯一选项。差不多，但不全是。你还可以使用能力(capabilities)，这个选项更像钥匙或者门票。Chez Andrea可以把钥匙给他的成员允许入场。不同的房间有不同的钥匙，防止顽皮的成员在别人的房间留下小小的惊喜。每个成员有可能携带一个钥匙串，允许她/他进入到俱乐部他/她可以访问的特定区域。就像ACLs，能力(capabilities)在就算及系统中有很长的使用历史，Dennis和van Horn可能是最早的例子。Wulf及其合作人员描述了Hydra操作系统，使用能力作为基本的控制机制。Levy总结了能力(capabilities)在早期硬件和软件系统中的使用，有一本书的长度。在能力(capability)系统中，一个运行中的进程一些能力(capabilities)的集合指定了他的访问权限。如果你正在使用一个纯能力(capability)系统，就没有ACL，这个集合就是这个进程可以访问权限的整个编码。这不是Linux或者Windows工作方式，但是其他操作系统，例如Hydra，是检查整个方式处理访问控制。

在这种纯能力系统中我们要怎么执行`open()`调用呢？当调用了这个请求，要么你的应用将提供一个能力允许你的进程打开问题中的文件作为参数，或者操作系统将会为你找到一个能力。在这两个例子中，操作系统给都会检测是否允许你打开一个文件(例如`/tmp/foo`)执行读写操作。如果允许，OS就会为你打开它。否则，会给你的进程返回一个错误，指示说它试图打开一个它不具有打开能力的文件。(记住，我们这里没有在讨论Linux，Linux使用的是ACL，而不是能力，判断是否应该允许一个`open()`调用。)

这里有一些显然的问题。精确的说，什么是能力？显然我们讨论的不是金属钥匙或者纸质门票。同样，OS要怎么检测能力的有效性？以及，在最开始的时候，能力是从哪里来的？



[<sup id="1">1</sup>](#content1)喔。你知道将这么多"特定"二字排列成这样一句有多难么?这是"特定"的一行！可能，也没有特别有意思。
[<sup id="2">2</sup>](#content2)基本上。回忆下在页表中判断是否一个特殊页可以被读写执行的bits?但是这里不是操作系统做的运行时检查，它是虚拟内存硬件。
[<sup id="3">3</sup>](#content3)作者Arpaci-Dusseau希望备注是作者Reiher负责安全章节中名字的选择，并且没有强迫他在这个和其它例子种种那个使用他们的名字。现在我们让你返回正常的阅读...
[<sup id="4">4</sup>](#content4)注意，对于访问控制列表和能力，我们假设我们已经认证了试图进入俱乐部的人。如果某个小人物带了Linus Torvalds或者Barbara Liskov的面具骗过了我们的保镖，或者如果我们在给某个人钥匙前没有仔细的判断它是否是Jerome Saltzer，我们就没法把乌合之众排除在外。拒绝可爱的比喻，在真实的计算机系统中据对会有同样的问题，这也是为什么名字啊之前的文章中详细的讨论了认证。
[<sup id="5">5</sup>](#content5)这个历史比这个还要更复杂些。CTSS系统提供了一个比Unix更受限的简要ACL形式，而Multics系统在一个有用户和用户组字符串名字组成的更一般化的访问控制列表中包含了组的概念。因此，Unix方式是这些更早期系统的结合。