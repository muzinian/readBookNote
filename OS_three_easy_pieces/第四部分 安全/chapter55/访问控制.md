## 访问控制(access control)
本章由Peter Reiher(UCLA)撰写
### 55.1 介绍
所以我们知道了我们的安全目标是什么，我们对我们想要实施的安全策略至少有了大概的感觉，并且我们还有证据表明正在请求各种系统服务的人员可能(或者可能没有)违背我们的策略。现在我们需要拿着这些信息将它们转换为一些可执行的东西，一些可以为我们执行的软件片段。
这里有两个比较重要的步骤：
1. 判定这个请求是否适合我们的安全策略。
2. 如果是，执行操作。否则，确保请求不会被执行。
第一步通常叫做 __访问控制(access control)__。我们将判断什么组织能够以何种方式在哪种情况下可以访问哪个系统资源或者服务。基本上，它归结为另一个非常适合我们计算范式(computing paradigms)的二元决定：是或否。但是，如何制定这个决策呢?为了让问题更具体些，考虑这个例子。用户X希望读写文件`/var/foo`。在底层，这个例子可能意味着一个在用户X的标识下运行的进程发起了以类似如下的系统调用:
```c
open("/var/foo",O_RDWR);
```
这里注意，我们没有讨论Linux的`open()`系统调用，它是以一个特定方式处理访问控制的特定实现。我们讨论的是你可能能够访问控制一个文件打开系统调用的更一般的方式。所以为了提醒你使用了不同的字体。

系统应该如何处理来自进程的这个请求，从而确保在实施了的安全策略拒绝了这个请求时，文件不会被打开，但是同样还要确认如果策略允许了这个请求文件是被打开的?我们知道系统调用会陷入到内核，只给了内核机会可以做一些事情来决策。机械地说，这些"事情"应该是什么?
>#### 问题的症结：如何判断一个访问请求是否应该被授予?
>操作系统如何才能判断如果在某个给定的时刻属于由某个特定用户的特定进程发起的特定请求应该或者不应该被授予?会使用什么信息做出决策?我们要如何设置这个信息来编码我们想要为系统实施的安全策略呢?

### 55.2 访问控制的一个重要方面
和平常一样，系统会运行某种算法做出决策。它需要一些输入，然后做出一个二元决策，一个对授予访问 是-或-否 的决定。在高层，谈论访问控制通常会用到 __主体(subjects)__，__对象(objects)__ 和 __访问(access)__ 这些词汇。一个subject是想要执行访问的实体，可能是一个用户或者进程。一个object是subject想要访问的对象，可能是一个文件或者一个设备。access是处理这个object的一个特定模式(mode)，例如读取它或者修改它。因此一个访问控制决定就是关于是否允许某个特定subject对某个特定object执行一个特定access模式。我们有时候将判定是否允许某个特定subject对某个特定[<sup id="content1">1</sup>](#1)object执行一个access的特定形式的进程叫做 __授权(authorization)__。

一个相关的问题是，什么时候会做出访问控制的决定?无论系统使用的是什么算法，系统在每次做这种决定的时候都要运行它。实现了这个算法的的代码叫做 __引用监视器(reference monitor)__，这是一个明显的动机，保证算法的实现正确快速。如果不正确，你就做出了错误的访问决策-显然很糟。它的效率也很重要，因为只要使用它，他就会引入一些开销。可能我们希望通过不是在每一次可能的机会都检测访问控制来最小化这种开销。另一方面，回忆下我们在前面几章介绍的全面介入(complete mediation)的原则?这个原则说我们应该在每次有人请求资源的时候都要检查安全条件。

显然，我们需要平衡开销和安全收益。但是，如果我们可以找到某个有意义的特殊情况，在那种情况下，我们可以在不违背安全的情况下完成低开销，我们可能管理避免在二者之间做取舍，至少在那些情况下。

达成这个的一个方式是给予subject只属于它们的objects。如果object本质上是他们固有的，而且是不可改变的，那么系统就可以让subject（在操作系统的情况下，一个进程）自由地访问它[<sup id="content2">2</sup>](#2)。(If the object is inherently  theirs,by its vary nature and unchangeably so,the system can let the subject(a process,in the operating system case)access it freely)虚拟化允许我们创建这种类型的虚拟对象。虚拟内存是一个极好的例子。一个进程被允许自由的访问自己的虚拟内存，在进程尝试使用内存的时候，不需要特殊的操作系统访问控制检查。这是也是好事，因为不是这样的话我们需要对每个进程引用都运行我们的访问控制算法，这会导致荒谬的慢的系统。我们可以对外设使用类似的虚拟化技巧。如果一个进程被给予访问某个虚拟设备，而这个虚拟设备实际上是由OS控制的一个真实的物理设备支撑，如果没有其它进程被允许使用那个设备，操作系统不需要在每次进程想要使用它的时候检查访问控制。例如，基于初始访问控制决策，一个进程被授予对GPU的控制，那么后面这个进程可以写GPU的内存或者直接发送指令给GPU而不需要后续OS的介入。

当然，就像前面讨论的，虚拟化基本就是操作系统提供的一个幻象。进程共享内存，设备以及其它计算资源。看似属于他们自己的资源实际上是共享的，在幕后是操作系统在周围运行才能保持这个幻象持续，有时候还需要来自特殊硬件的帮助。这意味着操作系统没有直接的知识和参与应用使用这个虚拟资源，一就必须要确保只有合适的访问形式被允许。因此仅仅依靠虚拟化确保合适的访问仅仅是把问题下推到OS对虚拟化功能的保护。即使我们将这个问题放到一边，迟早我们不得不离开过去便宜的特殊情况并处理一般的问题。Subject X想要读写object `/tmp/foo`。肯能他被允许，可能不?现在要怎么样?

计算机科学家已经提出了两个基本方法解决这个问题，依靠不同的数据结构和不同的指定决策的方法。一个叫做 __访问控制列表(access controll list)__ 另一个叫做 __能力(capabilities)__。实际上说是计算机科学家提出了这些方式有些错误，因为它们已经在非计算机领域中使用了近千年。让我们在考虑操作系统实现前，用一个更普遍的观点看看它们。

让我们说我们想要开一个独有的夜店(可能，叫做 Chez Andrea[<sup id="content3">3</sup>](#3))，这个夜店只允许最好的操作系统研究员和开发人员进。我们不想让任何数据库或者编程语言的人偷偷进来，因此我们需要确保只有我们认可的客户可以通过大门。我们要怎么做?一个做法是雇佣一个让人畏惧的魁梧保镖，他有着被认可人员列表。当有人想要进入到俱乐部，它们会给保镖提供证件，保镖会看看它是否在列表上。如果是Linus Torvalds或Barbara Liskov，保镖就让它们进去，但是会拦着那些没有在操作系统中出类拔萃的一大波网络人士拒之门外。

另一个方式是在俱乐部大门上装一个巨大的锁，将钥匙送给我们的OS兄弟。如果Jerome Saltzer想要进到Chez Andrea中，它只需要拿出钥匙打开锁。如果某个没有OS经验的计算机架构师想要进去，由于没有钥匙就只有堵在门外。和其他方式相比较，我们省下了保镖的薪水，尽管我们需要购买锁和钥匙[<sup id="content4">4</sup>](#4)。随着在OS领域中出现我们想认可的新的杰出人物，我们需要新的钥匙，而一旦我们偶尔犯了错误，把钥匙递给了某个不应该有钥匙的人，又或者某个成员丢了一把钥匙，在这些情况下我们需要确保钥匙将不再可以打开俱乐部的门。

同样的想法可以用在计算机系统中。早先的计算机科学家决定称呼像锁和钥匙的那种方式叫做 __基于能力的系统(capability-based system)__，而基于保镖和列出了许可的表的方式叫做 __访问控制列表系统(access control list system)__。能力就类似于钥匙，电影票，地铁票。访问控制列表就类似于，emmm，列表。这个在操作系统中是怎么工作的呢?如果你使用能力，当一个属于用户X的进程想要读写文件`/tmp/foo`，它给这个系统提供了针对这个文件的特定能力。(你可能会问，在这个上下文中具体是哪个能力?好问题!我们会回答它。)如果你使用访问控制列表(简写 __ACLs__)，系统在一个和`/tmp/foo`相关的ACL上查找用户X，只有用户在ACL上才允许访问。在这两个情况中，这个检查会在需要访问(`open()`调用，在我们的例子中)的时候执行。这个检查会在陷入操作系统后，并在访问被实际允许前执行，如果访问控制检查失败就会尽快失败并返回错误码。

在一个高的层级，这两个选项可能听起来没有这么多差异，但是当你开始考虑你需要运行的算法，以及支撑这些算法要求的数据结构，你就会很快发现有主要的不同。让我们按顺序查看它们。

### 55.3 使用ACL做访问控制
如果按照英国老式俱乐部的传统，Chez Andrea除了提供图书馆、餐厅、台球厅和其他共享空间外，还为每个会员提供自己的私人房间，会是怎样的呢？在这种情况下，我们需要确保不仅仅只有成员可以进入到俱乐部中，还要防止Ken Thompson(以顽皮著称)偷偷溜进Whitfield Diffie的房间在床上恶作剧(short-sheet his bed)。我们可以有一个巨大的访问控制列表，指明了每个房间允许访问的人，但这会导致不可管理。相反，为什么不对俱乐部中每个房间都设置一个ACL呢?

对于依赖ACL做访问控制的典型操作系统，我们对文件使用了同样的方式。每个文件都有自己的访问控制列表，这导致了一个更简单，更短的列表以及更快速的访问控制检查。所以在一个ACL系统中我们的`open()`调用会检查`/tmp/foo`的列表，而不是一个编码了系统中每个文件的所有访问的ACL。

当系统调用陷入到操作系统中，OS检查运行进程的PCB判断谁拥有这个进程。这个数据结构标识了用户X拥有这个进程。系统必须要持有`/tmp/foo`的访问控制列表。这个ACL更多的是文件元数据，类似于我们在"文件与目录"那章讨论的。因此他很可能就和其它文件元数据存放在一起或者靠近它们。以某种方式，我们取得了从持久化存储中取得了这个列表。现在我们在列表中查找X。X要么在这要么不在。如果不在，X就不能访问。如果在，通常我们要进一步判断X的ACL条目是否允许请求的访问类型。在我们的例子中，X想要读写`/tmp/foo`。可能ACL允许X读但不允许X写。在这种情况下，系统会拒绝访问然后返回一个错误给进程。

原则上，这不复杂，但是想起来细节是魔鬼了么?这里也有。考虑某些细节。例如，ACL持久化存储的到底是什么?它必须对于大多数资源来说确实是真的要持久化，因为ACL高效的编码了我们选择的安全策略，它不太可能经常变化。因此它会存放在闪存或者硬盘中。除非它被缓存了，每次有人试图打开这个文件的时候，我们都需要从设备中把它读取出来。在大多数文件系统中，就像我们在讨论持久化中段落中说过那样，为了真正的从一个文件中获取信息，你本来就需要几次设备读取操作。我们还需要另一次读取操作来获取文件的ACL么?如果需要，我们在设备的哪个地方存放ACL才可以保证快速访问?如果它靠近，甚至是我们已经读取到的内容的一部分，就非常好了，这就提供了少量的几个可能位置以供选择：文件的目录条目，文件的inode，或者坑你是文件的第一个数据块。最少，我们希望ACL靠近这些位置中的一个，如果它就在这些地方中的一个，例如inode，那就更好了。

这导致了另一个让人烦恼的细节：这个列表要多大?如果我们做的是很直接的事情，创建一个实际用户ID和访问模式的列表，大体上这个列表可以变成任意尺寸，最多是系统已知的用户数量。对于某些系统，这可能就是数千个条目了。但是一个文件一般是属于一个用户，并且通常只对那个用户，可能还有几个朋友，可用。所以我们不想在每个ACL张都保留足够的空间以容纳所有可能被列入到其中的用户，因为大多数用户在大多数ACL中都不会出现。当然，还是有例外：大部分文件对所有用户在某些模式中(可能是读或者执行)应该是可用的。毕竟，常见的可执行命令(例如`ls`和`mv`)都存放在文件中，并且我们会对它们应用访问控制，就像其他文件一样。我们的用户可能会共享一样的字体文件，网络配置文件，等等。我们要允许所有用户访问这些文件否则他们在系统中就没法做太多事情了。


因此，直接的实现会保留一个大的每文件列表(per-file list)，对某些文件它会被填满，而对于其它文件几乎就是空的。这就很浪费了。对于几乎是满了的列表，这里还有另一个要担心的细节：每次我们想要检查列表中的访问控制，我们都需要搜索它。现代计算机可以很快的搜索完一个包含了一千个条目的列表，但是如果每次我们都要执行这样的搜索，我们会对我们的系统增加很多不需要的开销。我们可以通过可变大小的访问控制列表解决这个问题，对每个列表只分配需要的空间。花点时间想一下你会如何适配这样的元数据到我们已经学习过的文件系统类型中，以及它对性能的影响。

幸运的是，在大多数情况下我们可以从来自最初的贝尔实验室Unix系统传给我们的遗产中受益。回到最初那些计算机科学巨人还在地球(或者至少是新泽西的一部分)漫步的时候，持久化存储供应不足且价格昂贵。他们根本无法负担得起为每个文件存储巨大的ACL。事实上，当他们计算完，他们发现只能为每个文件的ACL负担得起9bit。9bit没有超出太多，但是幸运的是那些早期Unix设计者十分聪明可以弥补硬件的缺失。它们思考了问题并指出他们关心的实际上有三种访问模式(对于大多数文件而言，就是读，写和执行)，并且他们可以在每个访问控制列表上只用三个条目就处理大多数安全策略。当然，如果他们是以一个条目一个访问模式一个bit的方式使用，他们可能早就用完了9个bit，没有空间指明这个条目归属于谁。所以他们很聪明的对访问控制列表分为了三组。一个是文件的拥有者，他的标识符已经存放在了`inode`中了。一个是特定组或者用户们的成员；这个组ID也已经存放在了`inode`。最后一个是其它人，例如所有除了文件拥有者和拥有者所在组成员的人员。不需要任何bit存储这个信息，因为它就是用户和用户组的补集。

这个方案不仅仅解决了ACL对存储占用量的问题，还解决了访问和检查它们的开销问题。为了对文件执行任何操作，你已经需要读取这个文件的inode了，因此，如果ACL是嵌入在inode中的，就不需要额外的查找和读取了。而且，不需要搜索一个任意大小的列表，对少量bit的一点简单逻辑就可以回答访问控制问题了。并且这个逻辑在这些年一直在为那些使用Posix兼容文件系统的大多数系统提供了答案。当然，这个方式有自己的限制，因为他不能表达复杂的访问模式和共享关系。对于这个原因，某些现代系统(例如Windows)允许扩展，这个扩展许可了对更一般的ACL的使用，但是很多还是依赖经过考验的Unix式的9bit ACL[<sup id="content5">5</sup>]。

ACL有一些好的功能以及一些限制。先说好的。首先，假如你想要查找谁被允许访问一个资源?如果你正在使用ACL，这个答案很容易回答，因为你只用查看ACL自身。第二，如果如果你想要修改可以访问一个object的subjects集合，你仅仅需要修改ACL，因为没有别的可以给予用户访问。第三，因为ACL通常要么是和文件保存在一起，要么是靠近文件，如果你可以得到文件，你可以得到所有和访问控制相关的信息。这在分布式系统中特别重要，但是对所有系统来说也是一个很好的性能影响，只要你的设计保持ACL靠近文件或文件的inode。

现在说一下不可取的功能。首先，ACL要求你解决我们前面提到的问题：不得不将这个访问控制信息存储在靠经文件的地方，并且处理长列表潜在的昂贵搜索。我们已经描述了实际的解决方案可以在大多数系统中工作的很好，但是这些方案限制了ACL可以做的事情。第二，如果你想要知道某个principal(一个进程或者一个用户)是否对整个资源集合都有权访问呢?你需要检查系统中每个ACL，因为pincipal可以会访问它们中的任意一个。第三，在分布式的环境中，为了使ACL有效，你需要有一个横跨所有机器的共通的身份视图(a common view of identity across all the machines for ACLs to be effective)。如果一个在`cs.ucla.edu`的用户想要访问一个存放在`cs.wisconsin.edu`的文件，这个威斯康星机器会检测由UCLA提供的某个身份标识对比存在威斯康星的访问控制列表。位与UCLA的用户`remzi`确实和在威斯康星的用户`remzi`指向的是同一个principal么?如果不是，你可能允许一个远程用户访问了他不该访问的内容。但是尝试维护一个跨多个不同计算域的一致的用户名称空间很有挑战。

>>#### 附注：名称空间(name spaces)
>>我们刚刚遇到了在分布式系统中那些有趣且困难的问题中的一个：在不同的机器上，名字意味着什么?__名称空间(name space)__ 问题在单个计算机上面相对容易。如果为一个新事物选择了已经使用过的名字，计算机是不允许这种赋值的。因此，在那个系统上由任意用户或者进程发起的特定名称，它代表的是同一个事情。`/etc/password`对于你以及你电脑上的所有其他用户来说是同一个文件。
>>但是对于由多个计算机组成的分布式系统来说又是什么情况呢?如果你想要得到同样的保证:所有人都知道的唯一名称，你就需要确保某个人你在位与UCLA的机器上不会创建一个已经在威斯康星大学使用过的名字。怎么做到这个?不同的答案有不同的优缺点。一个方式是不要操心它并且理解名称空间是不同的--举个例子，这就是我们用进程ID所做的事情。另一个方式是请求一个授权批准名字选择--这或多或少就是AFS处理文件名创建的方式。另一个方式是给每个参与者都划分出一部分名字空间，每个参与者可以使用得到的名字空间中的任意值，但是不允许使用其他人的名字空间--这就是万维网(World Wide Web WWW)以及IPv4地址空间处理这个问题的方式。这些答案没有对错。针对你的需求设计名称空间，但是要理解相关的影响。

### 使用能力(capabilities)进行访问控制
访问控制列表在计算机系统内不是访问控制的唯一选项。差不多，但不全是。你还可以使用能力(capabilities)，这个选项更像钥匙或者门票。Chez Andrea可以把钥匙给他的成员允许入场。不同的房间有不同的钥匙，防止顽皮的成员在别人的房间留下小小的惊喜。每个成员有可能携带一个钥匙串，允许她/他进入到俱乐部他/她可以访问的特定区域。就像ACLs，能力(capabilities)在就算及系统中有很长的使用历史，Dennis和van Horn可能是最早的例子。Wulf及其合作人员描述了Hydra操作系统，使用能力作为基本的控制机制。Levy总结了能力(capabilities)在早期硬件和软件系统中的使用，有一本书的长度。在能力(capability)系统中，一个运行中的进程一些能力(capabilities)的集合指定了他的访问权限。如果你正在使用一个纯能力(capability)系统，就没有ACL，这个集合就是这个进程可以访问权限的整个编码。这不是Linux或者Windows工作方式，但是其他操作系统，例如Hydra，是检查整个方式处理访问控制。

在这种纯能力系统中我们要怎么执行`open()`调用呢？当调用了这个请求，要么你的应用将提供一个能力允许你的进程打开问题中的文件作为参数，或者操作系统将会为你找到一个能力。在这两个例子中，操作系统给都会检测是否允许你打开一个文件(例如`/tmp/foo`)执行读写操作。如果允许，OS就会为你打开它。否则，会给你的进程返回一个错误，指示说它试图打开一个它不具有打开能力的文件。(记住，我们这里没有在讨论Linux，Linux使用的是ACL，而不是能力，判断是否应该允许一个`open()`调用。)

这里有一些显然的问题。精确的说，什么是能力？显然我们讨论的不是金属钥匙或者纸质门票。同样，OS要怎么检测能力的有效性？以及，在最开始的时候，能力是从哪里来的？和计算机中其他信息一样，能力就是一组bit。他们是数据。由于可能存在很多资源需要保护，而能力必须指定一个资源，因此，能力可能会相当的长，而且可能相当复杂。但是，本质上，它们就是bit。我们要记住，任何由一组bit组成的东西都有某种属性。例如，任何人都可以按照他们的想法创建任意的bit组。不存在某种进程无法制造的专利或者保留的bit模式。同样，如果一个进程有一份特定的bit位集合的拷贝，它很容易就创建出来很多份拷贝。第一个特性意味着任何人都有可能创建任意的能力。第二个特性意味着一旦某个人有一个可以工作的能力，他们可以创建任意多拷贝，可以在任何地方存储它们，包括完全不同的机器上。

从安全的角度看，这听起来并不好。如果一个进程需要一个有着特定bit模式的能力打开`/tmp/foo`进行读写，可能它可以生成那个bit模式并且成功的给自己应得的权限访问这个文件。在一个访问控制机制中这不是我们要找的。我们想要能力是不能够伪造的(unforgeable)。即使我们可以解决这个问题，可以复制能力(capability)的功能(ability)也表明，一旦赋予了访问权限，我们就无法撤销了，因为进程可以将权限的拷贝存放在任意地方[<sup id="content6">6</sup>](#6)。更进一步的，这个进程可能仅仅通过使用IPC将能力的拷贝传送给另一个进程从而给另外的进程授权。

当使用能力进行访问控制的时候，我们处理这些问题的典型方式是通过不让进程的手触碰任何能力。操作系统控制和维护能力，将它们存放到操作系统的受保护的内存空间。进程可以对能力执行各种操作，但是只能通过操作系统中介。举个例子，如果进程A希望使用能力给与进程B读写文件`/tmp/foo`的权限，A不能仅仅是发送给B合适的bit模式。相反，A必须发起一个系统调用请求操作系统给与B合适的能力。这个给了OS机会决定它的安全策略是否允许B访问`/tmp/foo`，可以在不符合的时候拒绝能力转移。

因此，如果我们想要依赖能力进行访问控制，操作系统将需要维护他拥有的每个进程的受保护的能力列表。这足够简单的，因为OS对每个进程已经有了受保护的数据结构，PCB。在进程的PCB中加上指向能力列表(存放在内核内存)的指针你就做完了所有的设置。现在，当进程尝试卡开文件`/tmp/foo`读写，调用会陷入到OS，OS会检查那个进程的能力列表，看看在列表上是否存在一个和这个操作相关的能力并做相应的处理。

在一个通用系统中，保存某些principal有权访问的所有东西的在线能力列表会导致高负载。如果对基于文件的访问控制，我们使用能力，用户可能会有几千个能力，每一个文件用户都会以任意方式被允许访问。通常，如果某个系统正在使用能力，系统会在某个安全的地方持久化存储能力，然后在需要的时候导入它们。因此与一个进程相关的能力列表没有必要很长，但是，有一个问题，就是决定用户可以自行决定将所拥有的巨大的能力集合中哪些能力可以给与他们运行的所有进程(我的理解，这句话的意思是，操作系统需要决定，在用户对自己可以自行决定是否授权的所有的能力集合中，哪些能力可以给予用户运行的每一个进程)。

这里有另一个选项。能力不需要存在操作系统中。相反，它们可以被加密保护。如果能力是相对较长的，并且是通过强加密的，它们不会以特定的方式猜测到并交给用户手上。加密的能力在分布式系统中很有意义，因此我们会在后面分布式系统安全的章节中讨论。

关于能力，既有优点也有缺点，就像访问控制列表一样。使用能力，可以很容易的确定一个给定的principal可以那些系统资源。只需要检查下principal的能力列表就行了。回收访问仅仅需要从能力列表中删除这个能力，如果OS是互斥的访问这个能力，就足够简单(如果不是，就很难了)。如果你的能力已经在内存中可用了，你可以很方便的检查它，特别是因为能力可以自身包含一个指针指向和它保护的资源相关联的数据或者软件。可能仅仅拥有这个指针是能力的系统核心实现。

另一方面，确定可以访问一个资源的完整principal集合变得更复杂了。任何一个principal都有可能有这个资源的一个能力，因此你需要检查所有principal的能力列表才能分辨。让能力列表变短并易于维护的简单方法还没有像UNIX那样提供短的ACL开发好。而且，系统必须能够以某种可以克服伪造问题的方式创建，存储并回收能力，这是一个挑战。

能力的一个干净的方面是它们提供了一个很好的方式可以创建受限权限的进程。使用访问控制列表，一个进程继承了他的父进程的标识，也继承了那个principal所有的权限。很难只给这个进程他父进程权限的一个子集。要么你需要创建一个新的只有那些受限的权限的principal，修改一些访问控制列表，然后设置新的进程的标识为那个新的principal，或者你需要扩展你的访问控制模型，和访问控制列表原始做法不是那么的一致。如果父进程拥有能力X，Y和Z，但仅仅只想要子进程只有权限X和Y，当子进程被创建时，父进程只转移X和Y，而不转移Z。

实践中，用户可见的访问控制机制由于很多原因倾向于使用访问控制列表而不是能力。然而，在底层，操作系统广泛的使用了能力。例如，在一个典型的Linux系统中，`open()`调用使用ACL控制访问。然而，假设Linux的`open()`成功了，只要进程保持文件是打开的，ACL不会检查后续的读写。相反，Linux创建一个数据结构记录了一个能力，标识这个进程对这个文件有读写权限。这个结构附加到了进程的PCB上。对每一次读/写操作，OS可以简单的咨询这个数据结构确定是否允许读/写，而不用取查询文件的访问控制列表。如果文件被关闭了，这个类似能力的结构就会从PCB中删除掉然后进程就无法再次访问这个文件，除非再次执行`open()`调用，这又回到了ACL。类似的技术可以用来控制访问硬件设备和IPC通道，特别是因为类UNIX系统将这些资源当作是文件。结合了ACL和能力的使用允许系统避免与单个机制有关的某些问题。检查访问控制列表的开销被节约下来了，因为这种能力的形式很容易检查，因为仅仅是在一个操作系统数据结构内是否存在一个指针。管理所有可访问对象的能力的开销也避免了，因为这个能力只在ACL检查成功后才设置。如果对象永远不会被进程访问，ACL永远不会被检查，从而就不需要能力。由于任何典型的进程都只会打开它允许打开的所有文件的一小部分，规模问题不会总是出现。

### 强制和自由裁量访问控制(mandatory and discretionary access control)
谁能决定对于一个计算机资源的访问控制应该是什么？对于大多数人来说，答案看起来很显然：拥有这个资源的人。对于用户文件这种场景，用户应该决定访问控制设置。系统资源这个场景，系统管理员，可能是计算机的拥有者，应该决定它们。然而，对于某些系统和某些安全策略，没有正确的答案。特别的，最关心信息安全的部门有时候想要比那个更加严格的控制。

军事是最显然的例子。我们都听过顶级机密信息，也可能都理解，即使允许你阅读顶级机密信息，也不允许你让别人看。并且，即使谈到的信息是存在你为自己创建的文件中，例如包含了来自其他顶级机密文档的统计或者引用，也是不允许别人看的。在这些情形中，创建者控制访问权限这一简单的回答是不正确的。在组织机构中负责整体信息安全的人需要做出这个决定，这意味着principal拥有设置由其他用户创建，属于其他用户的信息的访问控制权限，而这些其他用户无法覆盖他的决定。比较常见的例子叫做 __自由裁量访问控制(discretionary access control)__。要么是几乎所有人都可以要么是几乎所有人都不可以访问一个资源，依赖于所有者的自由裁量。比较严格的场景叫做 __强制访问控制(mandatory access control)__。在这样的系统中，至少访问控制决定的某些元素是由权威强制的，它可以覆盖信息所有者的需求。选择强制还是自由裁量访问控制和使用ACL还是能力进行访问控制是正交的(orthogonal)，而且它通常独立于访问控制机制的其他方面，例如受访的信息是如何存储和处理的。强制访问控制系统也可以包括自由裁量的元素，它允许强制控制进一步的限制(但不是放松)。

很多人永远不会工作在运行强制访问控制的系统，因此我们不会进一步研究他们是如何工作的，出了观察到操作系统显然会涉及到参与它们。如果你需要在一个强制访问控制是很重要的环境中工作，你可以确认你将听到它。在那个时候，你应该学习更多它的知识，因为当某些人足够关心使用强制访问控制时，他们也足够关心惩罚不遵守规则的用户。Loscocco描述了一个特殊的Linux版本，它纳入了强制访问控制。如果你想要学习这样的系统更多的特性，这个论文是一个好的开始。

### 访问控制机制实践
大多数系统暴露给他们用户的要么是简单的要么是强大的访问控制列表机制，它们中的大多数使用自由裁量访问控制。然而，一个现代计算机可以很容易拥有成百上千，甚至是百万个文件，让人类用户单独对这些文件设置访问控制权限不可行。一般地，这个系统允许每个用户建立默认的访问权限，用于用户创建的每个文件。如果某个人使用Linux的`open()`调用创建文件，他可以指定一开始要赋予这个权限的访问权限。在Unix/Linux系统中新创建的文件的访问权限可以由`umask()`调用进一步的控制，执行了这个调用的进程创建的所有新文件都可以应用到。

如果需要，拥有者可以修改最初的ACL，但是经验表明用户很少会这样做。这种倾向性表明了选择合适的默认值的重要性。这里，就像操作系统中其他很多地方一样，一个理论上可以修改或者调优的设置在实践上几乎会被所有人几乎总是不修改的使用。
> #### 附注：安卓的访问控制模型
> 安卓系统对今天的移动计算设备，特别是智能手机，是领先的软件平台之一。这些设备提出了不同于典型的服务器计算机甚至是个人桌面计算机或者是笔记本那样的访问控制挑战。他们的功能是基于使用很多相对小的独立的应用——通常也叫做app——，它们被下载，安装并运行在只属于单个用户的设备上。



[<sup id="1">1</sup>](#content1)喔。你知道将这么多"特定"二字排列成这样一句有多难么?这是"特定"的一行！可能，也没有特别有意思。
[<sup id="2">2</sup>](#content2)基本上。回忆下在页表中判断是否一个特殊页可以被读写执行的bits?但是这里不是操作系统做的运行时检查，它是虚拟内存硬件。
[<sup id="3">3</sup>](#content3)作者Arpaci-Dusseau希望备注是作者Reiher负责安全章节中名字的选择，并且没有强迫他在这个和其它例子种种那个使用他们的名字。现在我们让你返回正常的阅读...
[<sup id="4">4</sup>](#content4)注意，对于访问控制列表和能力，我们假设我们已经认证了试图进入俱乐部的人。如果某个小人物带了Linus Torvalds或者Barbara Liskov的面具骗过了我们的保镖，或者如果我们在给某个人钥匙前没有仔细的判断它是否是Jerome Saltzer，我们就没法把乌合之众排除在外。拒绝可爱的比喻，在真实的计算机系统中据对会有同样的问题，这也是为什么名字啊之前的文章中详细的讨论了认证。
[<sup id="5">5</sup>](#content5)这个历史比这个还要更复杂些。CTSS系统提供了一个比Unix更受限的简要ACL形式，而Multics系统在一个有用户和用户组字符串名字组成的更一般化的访问控制列表中包含了组的概念。因此，Unix方式是这些更早期系统的结合。