## 认证(Authentication)
本章由Peter Reiher(UCLA)撰写
### 54.1 介绍
由于我们需要和大范围的安全目标以及用以达成这些目标的安全策略打交道，我们需要从操作系统中得到什么？操作系统为进程提供服务，这些服务中有些有安全影响。显然，在这些情况中，操作系统需要很小心才能做正确事情，安全方面的。但是操作系统服务被允许的原因根本上是有时候这些服务需要被完成，所以操作系统可能能够执行的任何服务大概应该被执行，在正确的环境下。

在操作系统决定是执行某个服务还是由于它违背了安全目标而拒绝执行的过程中，上下文就是操作系统依赖的全部(Context will be everything in operating system decisions on whether to perform some service or to refuse to do so because it will compromise security goals)。那个上下文中最重要的元素可能就是谁正在要求做事情。在现实世界中，如果对你重要的人叫你在回家的路上买一加仑牛奶，你很可能会这样做，但如果是街上的陌生人说了同样的事情，你就可能不会了。在操作系统上下文中，如果系统系统管理员要求操作系统安装一个新程序，它很可能会安装，然而，如果是一个从随机网页下载下来的脚本要求安装一个新程序，操作系统在执行安装前就会很仔细了。在计算机安全讨论中，我们常常称请求做某件事的组织(party)为 __当事人(principal)__。(注:后面都将使用英文)。Principals是对安全有意义的实体，可以请求访问资源，例如人类用户，用户组，或者复杂的软件系统。

因此，知道谁正在请求操作系统服务对于达成你的安全目标很关键。操作系统是如何知道的这些的呢?这里让我们稍微回去点弄清楚它。

操作系统服务最常见的是由某个特定进程发起的系统调用请求的，它会从用户代码陷入到操作系统代码中。接着，操作系统会占有控制权并执行某些服务回应这个系统调用。和调用进程(calling process)相关的是由操作系统控制的数据结构，他会描述这个进程，因此操作系统可以通过检查那个数据结构确定进程的身份。基于那个身份，操作系统现在有机会做出基于策略的决定：是否执行请求的操作。在计算机安全的讨论中，代表principal执行请求的进程或者其它活动的计算实体通常叫做 __代理(agent)__。

请求是为了访问某些特定的资源，我们常常叫做访问请求的 __对象__[<sup id="content1">1</sup>](#1)。操作系统已经决定了这个agent进程是否可以访问这个object。如果决定了进程允许访问，OS可以记住这个决定，而这只是放在类似PCB的每个进程(per-process)的数据结构中，保持跟踪这一事实就可以了(a matter of keeping tracing,presumably in some per-process data sturcture like PCB,of that fact)。举个例子，就像我们在调查内存虚拟化中讨论的那样，每进程数据结构，例如页表，展示了在任意给定时间，哪个页以及页帧可以被进程访问。任何由操作系统创建和管理的，为了在将来引用而保持类似访问决策的数据结构通常叫做 __证书(credential)__(Any form of data created and managed by operating system that keeps track of such access decisions for future reference is often called a __credential__)。

如果操作系统还没有产生一个说明agent进程可以访问特定object的credential，它需要和进程的principal有关的信息，从而判断它的请求是否应该被授权(granted)。不同的操作系统对principal使用不同类型的身份标识。举个例子，大多数操作系统都有用户身份的概念，这些用户一般就是某些人类(多年来，用户的概念不断扩展，增加了它的力量，我们稍后会看到这些)。因此，由一个特定人员运行的所有进程都会有相同的身份与之相关。另一个常见的身份类型是用户组。在一个大型公司里面，你可能想给你全部的销售人员访问库存的信息，这样他们就可以判断在你的仓库中有多少货品，而你的人力资源部门就没有必要有权访问这些信息了[<sup id="content2">2</sup>](#2)。另一个形式的身份是进程正在运行的程序。回忆下，进程就是程序正在运行的版本。在某些系统中(例如安卓操作系统)，你可以授予某些权限给特定的程序。无论何时它们运行了，它们就可以使用这些权限，但是别的程序就不行。

先不管我们用来达成安全目标的是哪种身份类型，我们必须有某种方式将这个身份和一个特定进程关联。显然，这个关联是一个关键的安全问题。如果你错误的标识了一个程序员雇员进程为一个会计部门员工进程，你最后就剩下空的银行账户(还没有提你需要雇一个新的程序员)。或者当你公司主席正试图给投资者进行一个很重要的展示会而你没有没有成功的认出来主席，你可能会发现一旦公司确定就是你导致公司无法进行下一轮的初创融资，因为系统不能允许主席出席一个可能让某些潜在投资者震惊的展示会上，你就会丢掉工作。

另一方面，除了操作系统自己的活动，所有事情都是由某些进程执行的，如果我们可以正确的处理进程这些问题(get it right)，我们可以相当确定我们会有机会在每个重要动作上检查我们的策略。但是我们需要牢记于心的操作系统用来认证的惯常方式的另一个重要特质：一旦一个principal已经被认证了，至少是在基础南横的生命周期内，系统将几乎总是依赖这个认证决定。这个特质给予了把事情做对(get it right)很高的奖励。这导致了问题：
>#### 症结：如果安全的标识进程
>对于那些支持进程属于多个principal的系统，我们如何确认每个进程有正确的标识与之关联?随着一个新的进程被创建，我们如何确认这个进程有着正确的标识?我们如何可以确认恶意实体不能错误的修改进程的标识?

### 54.2 关联标识到进程
进程是从哪里来的呢?通常他们是其它进程创建的。将一个标识关联到一个新进程的一个简单方式是，复制创建了这个进程的进程的标识。子进程继承了父进程的标识。机械地，当一个操作系统服务了一个从进程A创建新进程B的调用(`fork`，举个例子)，它查阅A的进程控制块确定A的标识，为B创建一个新的进程控制块，然后复制A的标识。简单吧，不么?

如果所有的进程总是有着同样的表示这总是好的。我们可以在操作系统启动的时候创建一个初始进程，可能赋予给它某个不会赋予给任何人类用户的特别的系统标识。所有其他进程都是他的后代并且所有它们都继承这个单个标识。但是如果真的只有一个标识，我们将无法实现任何可以区分不同进程权力的策略。

我们必须要重新安排某些进程有不同的标识并且使用这些差异管理我们的安全策略。考虑一个多用户系统。我们可以基于进程属于哪个人类用户给进程分配标识。如果我们的安全策略主要是关于允许某些人做某些事以及不允许其他人做某些事，我们现在对如何做决策就有了主意了。

如果一个进程有安全相关的身份标识，例如一个用户ID，我们对新进程设置合适的用户ID。在大多数系统中，一个用户都会使用一个进程：在命令行系统中是shell进程，在面向窗口的系统中是窗口管理进程--你已经看出来这两个自身都是进程，是不是?所以，当你在shell中键入一个命令或者在窗口系统中点击一个图标启动一个进程时，你正在请求操作系统在你的标识下启动一个新的进程。

很好！但是我们确实还有别的问题要处理。shell或者窗口管理器是怎么将你的标识关联到它本身?这里有一个小的操作系统特权可以使用。当一个用户先开始和一个系统交互，这个操作系统可以为这个用户启动一个进程。因此这个操作系统可以修改(fiddle with)它自己拥有的数据结构，例如进程控制块，它可以设置新的进程所有权为刚刚加入到系统中的用户。

再一次，很好，但是，操作系统是怎么确定用户的标识，从而可以合适的设置进程所有权?你可能可以猜到答案--用户登录了，意味着用户提供了标识信息给操作系统证明了用户是谁。我们现在已经找到了操作系统的一个新需求：他必须能够从人类用户那里查询标识并且验证他们就是他们声称的人，这样我们可以给进程关联可信的标识，这样我们可以使用那些标识实现我们的安全目标。在操作系统中一个事情往往导致另一个问题。

所以操作系统是如何做到的呢?应该清楚的是，我们是基于操作系统在这里做出正确的决定，用来会有着不可预见的影响的高耸的安全结构。我们的选项是什么?

### 54.3 如何鉴定用户?
_因此整个人类走向了一个计算机..._

假设我们不考虑开玩笑的可能性，做什么才可以允许这个系统在合理的精度中可以确定这个人是谁?首先，如果这个人不是系统的一个已授权用户，我们应该完全的据接这次潜入尝试。第二，如果ta是一个已授权用
户，我们需要决定，他是谁?
典型地，鉴定人类的表示有三种方式：
* 基于你知道什么的鉴定
* 基于你有什么的鉴定
* 基于你是什么的鉴定
当在这里我们说"典型地"，我们意味着"典型地"在经典场景(we mean "classically" in the,well,classical sense)。经典地要回到古希腊和罗马。例如，在公元前2世纪时，波利比阿斯描述了罗马士兵是如何使用"暗号"区分朋友和敌人，是一个基于你知道什么的鉴定。一个叫做Celer的罗马建筑师在公元2世纪为它的一个奴隶写了一封推荐信(这封信依旧保留着)给与了帝国行政长官--基于奴隶有什么的鉴定。甚至更回去些，在(字面意义上地)圣经时间，基列人(Gileadites)要求在一场战争后的难民说一个单词"shibboleth"，因为他们寻找的敌人(古以色列人(Ephraimites))不能很好的发这个音。这是基于你是什么的鉴定的一个形式：基列方言或者古以色列方言的母语者。

在确认了这些鉴定方法的很古老后，让我们跳过几个世纪的历史直到计算机时代来讨论在计算机鉴定的上下文中我们是如何使用它们。

### 54.4 通过你知道什么来鉴定
通过你知道什么来鉴定最常见的是通过使用密码来执行的。密码在计算机历史中有一个很长(以及主要是不光彩的)历史，至少可以回溯到二十世纪60年代早期在MIT的CTSS系统中。密码只有被认证组织秘密知道的。通过在登陆的时候泄露给计算机操作系统这个秘密，这个组织可以证明它们的标识。(你应该对这是否意味着系统必须知道密码感到好奇，以及这可能会有的进一步影响。我们回到讨论这个。)这种鉴定形式的效力显然依赖几个因素。我们假设其它人不知道组织的密码。如果它们知道，系统就被愚弄了。我们假设也没有人可以猜出来。以及，当然讨论中的组织必须知道(并且记住)它。

让我们先处理其他人知道密码这个问题。将猜测放到一边，他们如何可以知道这个?某个已经知道的人可能泄露了它，越少的组织知道密码，我们需要担心的组织就越少。我们要鉴定的人必须知道它。我们真的不想其它任何人可以被鉴定为我们系统的那个人，所以我们确实倾向没有第三方组织知道密码。广阔的思考这里"第三方组织"的意思，这也意味着用户不应该写道一个会丢失的纸上，因为任何偷了这张纸的人现在知道了密码。但是但是这里还多一个组织看起来需要知道这个密码：我们系统本身。这导致了另一个可能的弱点，系统对我们密码的副本可能会泄露[<sup id="content3">3</sup>](#3)。

尽管如此，有够有意思的是，我们系统实际上不需要知道密码。仔细思考下当系统在检查用户提供的密码时它在做什么。所以如果用户提供给我们了密码，但是我们不知道密码，我们的系统到底是怎么做的呢?

你已经知道答案了，或者至少一旦你听到了答案，你会拍拍你的额头说"我应该想到这个的"。存放密码的 __哈希(hash)__，



[<sup id="1">1</sup>](#content1)单词"object"又一次被计算机科学复用。这里，他跟"面向对象(object oriented)"无关，而是对一个有着边界和行为的特定资源更一般的概念(the more genernal concept of a specific resource with boundaries and behaviors)，例如一个文件或者一个IPC channel。
[<sup id="2">2</sup>](#content2)还记得之前章节中最少权限原则么?这里就是使用它的一个例子。一个劣迹斑斑的人力服务员工不能命令你的仓库情况pop-doodles，如果你没有给这些雇员权力去做这些事情。当你在阅读本书和安全有关的章节时，请注意我们之前章节讨论过的安全原则的其他运用。
[<sup id="3">3</sup>](#content3)"可能是一个很弱的词"。已知的第一个这种被偷的密码泄露是1962年，发生在当今的泄露有着令人沮丧的规律以及相当大的范围。论文讨论了以可用的方式存储的超过一亿个密码泄露。