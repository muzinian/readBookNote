## 认证(Authentication)
本章由Peter Reiher(UCLA)撰写
### 54.1 介绍
由于我们需要和大范围的安全目标以及用以达成这些目标的安全策略打交道，我们需要从操作系统中得到什么？操作系统为进程提供服务，这些服务中有些有安全影响。显然，在这些情况中，操作系统需要很小心才能做正确事情，安全方面的。但是操作系统服务被允许的原因根本上是有时候这些服务需要被完成，所以操作系统可能能够执行的任何服务大概应该被执行，在正确的环境下。

在操作系统决定是执行某个服务还是由于它违背了安全目标而拒绝执行的过程中，上下文就是操作系统依赖的全部(Context will be everything in operating system decisions on whether to perform some service or to refuse to do so because it will compromise security goals)。那个上下文中最重要的元素可能就是谁正在要求做事情。在现实世界中，如果对你重要的人叫你在回家的路上买一加仑牛奶，你很可能会这样做，但如果是街上的陌生人说了同样的事情，你就可能不会了。在操作系统上下文中，如果系统系统管理员要求操作系统安装一个新程序，它很可能会安装，然而，如果是一个从随机网页下载下来的脚本要求安装一个新程序，操作系统在执行安装前就会很仔细了。在计算机安全讨论中，我们常常称请求做某件事的组织(party)为 __当事人(principal)__。(注:后面都将使用英文)。Principals是对安全有意义的实体，可以请求访问资源，例如人类用户，用户组，或者复杂的软件系统。

因此，知道谁正在请求操作系统服务对于达成你的安全目标很关键。操作系统是如何知道的这些的呢?这里让我们稍微回去点弄清楚它。

操作系统服务最常见的是由某个特定进程发起的系统调用请求的，它会从用户代码陷入到操作系统代码中。接着，操作系统会占有控制权并执行某些服务回应这个系统调用。和调用进程(calling process)相关的是由操作系统控制的数据结构，他会描述这个进程，因此操作系统可以通过检查那个数据结构确定进程的身份。基于那个身份，操作系统现在有机会做出基于策略的决定：是否执行请求的操作。在计算机安全的讨论中，代表principal执行请求的进程或者其它活动的计算实体通常叫做 __代理(agent)__。

请求是为了访问某些特定的资源，我们常常叫做访问请求的 __对象(object)__[<sup id="content1">1</sup>](#1)。操作系统已经决定了这个agent进程是否可以访问这个object。如果决定了进程允许访问，OS可以记住这个决定，而这只是放在类似PCB的每个进程(per-process)的数据结构中，保持跟踪这一事实就可以了(a matter of keeping tracing,presumably in some per-process data sturcture like PCB,of that fact)。举个例子，就像我们在调查内存虚拟化中讨论的那样，每进程数据结构，例如页表，展示了在任意给定时间，哪个页以及页帧可以被进程访问。任何由操作系统创建和管理的，为了在将来引用而保持类似访问决策的数据结构通常叫做 __证书(credential)__(Any form of data created and managed by operating system that keeps track of such access decisions for future reference is often called a __credential__)。

如果操作系统还没有产生一个说明agent进程可以访问特定object的credential，它需要和进程的principal有关的信息，从而判断它的请求是否应该被授权(granted)。不同的操作系统对principal使用不同类型的身份标识。举个例子，大多数操作系统都有用户身份的概念，这些用户一般就是某些人类(多年来，用户的概念不断扩展，增加了它的力量，我们稍后会看到这些)。因此，由一个特定人员运行的所有进程都会有相同的身份与之相关。另一个常见的身份类型是用户组。在一个大型公司里面，你可能想给你全部的销售人员访问库存的信息，这样他们就可以判断在你的仓库中有多少货品，而你的人力资源部门就没有必要有权访问这些信息了[<sup id="content2">2</sup>](#2)。另一个形式的身份是进程正在运行的程序。回忆下，进程就是程序正在运行的版本。在某些系统中(例如安卓操作系统)，你可以授予某些权限给特定的程序。无论何时它们运行了，它们就可以使用这些权限，但是别的程序就不行。

先不管我们用来达成安全目标的是哪种身份类型，我们必须有某种方式将这个身份和一个特定进程关联。显然，这个关联是一个关键的安全问题。如果你错误的标识了一个程序员雇员进程为一个会计部门员工进程，你最后就剩下空的银行账户(还没有提你需要雇一个新的程序员)。或者当你公司主席正试图给投资者进行一个很重要的展示会而你没有没有成功的认出来主席，你可能会发现一旦公司确定就是你导致公司无法进行下一轮的初创融资，因为系统不能允许主席出席一个可能让某些潜在投资者震惊的展示会上，你就会丢掉工作。

另一方面，除了操作系统自己的活动，所有事情都是由某些进程执行的，如果我们可以正确的处理进程这些问题(get it right)，我们可以相当确定我们会有机会在每个重要动作上检查我们的策略。但是我们需要牢记于心的操作系统用来认证的惯常方式的另一个重要特质：一旦一个principal已经被认证了，至少是在基础南横的生命周期内，系统将几乎总是依赖这个认证决定。这个特质给予了把事情做对(get it right)很高的奖励。这导致了问题：
>#### 症结：如果安全的标识进程
>对于那些支持进程属于多个principal的系统，我们如何确认每个进程有正确的标识与之关联?随着一个新的进程被创建，我们如何确认这个进程有着正确的标识?我们如何可以确认恶意实体不能错误的修改进程的标识?

### 54.2 关联标识到进程
进程是从哪里来的呢?通常他们是其它进程创建的。将一个标识关联到一个新进程的一个简单方式是，复制创建了这个进程的进程的标识。子进程继承了父进程的标识。机械地，当一个操作系统服务了一个从进程A创建新进程B的调用(`fork`，举个例子)，它查阅A的进程控制块确定A的标识，为B创建一个新的进程控制块，然后复制A的标识。简单吧，不么?

如果所有的进程总是有着同样的表示这总是好的。我们可以在操作系统启动的时候创建一个初始进程，可能赋予给它某个不会赋予给任何人类用户的特别的系统标识。所有其他进程都是他的后代并且所有它们都继承这个单个标识。但是如果真的只有一个标识，我们将无法实现任何可以区分不同进程权力的策略。

我们必须要重新安排某些进程有不同的标识并且使用这些差异管理我们的安全策略。考虑一个多用户系统。我们可以基于进程属于哪个人类用户给进程分配标识。如果我们的安全策略主要是关于允许某些人做某些事以及不允许其他人做某些事，我们现在对如何做决策就有了主意了。

如果一个进程有安全相关的身份标识，例如一个用户ID，我们对新进程设置合适的用户ID。在大多数系统中，一个用户都会使用一个进程：在命令行系统中是shell进程，在面向窗口的系统中是窗口管理进程--你已经看出来这两个自身都是进程，是不是?所以，当你在shell中键入一个命令或者在窗口系统中点击一个图标启动一个进程时，你正在请求操作系统在你的标识下启动一个新的进程。

很好！但是我们确实还有别的问题要处理。shell或者窗口管理器是怎么将你的标识关联到它本身?这里有一个小的操作系统特权可以使用。当一个用户先开始和一个系统交互，这个操作系统可以为这个用户启动一个进程。因此这个操作系统可以修改(fiddle with)它自己拥有的数据结构，例如进程控制块，它可以设置新的进程所有权为刚刚加入到系统中的用户。

再一次，很好，但是，操作系统是怎么确定用户的标识，从而可以合适的设置进程所有权?你可能可以猜到答案--用户登录了，意味着用户提供了标识信息给操作系统证明了用户是谁。我们现在已经找到了操作系统的一个新需求：他必须能够从人类用户那里查询标识并且验证他们就是他们声称的人，这样我们可以给进程关联可信的标识，这样我们可以使用那些标识实现我们的安全目标。在操作系统中一个事情往往导致另一个问题。

所以操作系统是如何做到的呢?应该清楚的是，我们是基于操作系统在这里做出正确的决定，用来会有着不可预见的影响的高耸的安全结构。我们的选项是什么?

### 54.3 如何鉴定用户?
_因此整个人类走向了一个计算机..._

假设我们不考虑开玩笑的可能性，做什么才可以允许这个系统在合理的精度中可以确定这个人是谁?首先，如果这个人不是系统的一个已授权用户，我们应该完全的据接这次潜入尝试。第二，如果ta是一个已授权用
户，我们需要决定，他是谁?
典型地，鉴定人类的表示有三种方式：
* 基于你知道什么的鉴定
* 基于你有什么的鉴定
* 基于你是什么的鉴定
当在这里我们说"典型地"，我们意味着"典型地"在经典场景(we mean "classically" in the,well,classical sense)。经典地要回到古希腊和罗马。例如，在公元前2世纪时，波利比阿斯描述了罗马士兵是如何使用"暗号"区分朋友和敌人，是一个基于你知道什么的鉴定。一个叫做Celer的罗马建筑师在公元2世纪为它的一个奴隶写了一封推荐信(这封信依旧保留着)给与了帝国行政长官--基于奴隶有什么的鉴定。甚至更回去些，在(字面意义上地)圣经时间，基列人(Gileadites)要求在一场战争后的难民说一个单词"shibboleth"，因为他们寻找的敌人(古以色列人(Ephraimites))不能很好的发这个音。这是基于你是什么的鉴定的一个形式：基列方言或者古以色列方言的母语者。

在确认了这些鉴定方法的很古老后，让我们跳过几个世纪的历史直到计算机时代来讨论在计算机鉴定的上下文中我们是如何使用它们。

### 54.4 通过你知道什么来鉴定
通过你知道什么来鉴定最常见的是通过使用密码来执行的。密码在计算机历史中有一个很长(以及主要是不光彩的)历史，至少可以回溯到二十世纪60年代早期在MIT的CTSS系统中。密码只有被认证组织秘密知道的。通过在登陆的时候泄露给计算机操作系统这个秘密，这个组织可以证明它们的标识。(你应该对这是否意味着系统必须知道密码感到好奇，以及这可能会有的进一步影响。我们回到讨论这个。)这种鉴定形式的效力显然依赖几个因素。我们假设其它人不知道组织的密码。如果它们知道，系统就被愚弄了。我们假设也没有人可以猜出来。以及，当然讨论中的组织必须知道(并且记住)它。

让我们先处理其他人知道密码这个问题。将猜测放到一边，他们如何可以知道这个?某个已经知道的人可能泄露了它，越少的组织知道密码，我们需要担心的组织就越少。我们要鉴定的人必须知道它。我们真的不想其它任何人可以被鉴定为我们系统的那个人，所以我们确实倾向没有第三方组织知道密码。广阔的思考这里"第三方组织"的意思，这也意味着用户不应该写道一个会丢失的纸上，因为任何偷了这张纸的人现在知道了密码。但是但是这里还多一个组织看起来需要知道这个密码：我们系统本身。这导致了另一个可能的弱点，系统对我们密码的副本可能会泄露[<sup id="content3">3</sup>](#3)。

尽管如此，有够有意思的是，我们系统实际上不需要知道密码。仔细思考下当系统在检查用户提供的密码时它在做什么。所以如果用户提供给我们了密码，但是我们不知道密码，我们的系统到底是怎么做的呢?

你已经知道答案了，或者至少一旦你听到了答案，你会拍拍你的额头说"我应该想到这个的"。存放密码的 __哈希(hash)__，而不是密码本身。当用户给了你他成为密码的东西，把它进行哈希并与已经存储的值进行比较。如果匹配，你相信ta知道密码。如果不匹配，你就不认为。这意味着如果你没有仔细对待存放认证信息的方式，你实际上没有丢失密码，而是密码的哈希。根据哈希的性质，你无法逆向哈希算法，所以敌人就无法通过窃取到的哈希获取密码。如果攻击者提供的是哈希值而不是密码，系统会对哈希值进行哈希操作，而一个哈希值的哈希值是不会等于这个哈希值的。

还有一点比这个更重要。我们存储密码的哈希的好处是：如果存储的副本泄露给了攻击者，攻击者无法知道密码本身。但是仅仅存储和密码不同的某种东西是不够的。我们也想要保证无论我们存储了什么泄露给了攻击者，都无法帮助他们猜测到密码。如果攻击者窃取了已经哈希了的密码，ta应该不能通过分析哈希获取到关于密码本身的线索。这是一类特殊的哈希算法叫做 __加密哈希(cryptographic hashes)__，它们使得通过哈希值找出密码是不可能的，除非真正的给哈希算法传入一个密码的猜测。加密哈希一个不太好的特性是他们很难被设计出来，甚至聪明的人都不应该尝试。他们使用由专家创建。这就是现代系统使用密码哈希城的方式：使用被完全研究过的没有已知缺陷的加密哈希。在任意给定时间，哪些加密哈希算法能满足这些需求可能会很不同。在正在编写本书的时候，SHA-3是US的标准加密哈希算法，而它是一个好的选项。

>#### tips:避免存储密码
>存储类似明文密码或者加密keys这些秘密是很危险的事情，因为这些秘密通常会泄露出去。通过不存储你不需要的密码来保护你的系统。如果你确实需要，存储密码经过一个强加密哈希哈希后的值。如果你没法做到这样，使用一个安全加密套件加密它们。(可能正在想自己抱怨我们没有早早的告诉你。耐心点。)在尽可能的少的地方，用尽可能少的副本存储它们。不要忘记临时编辑器文件，备份，日志以及类似的东西，因为这些秘密可能也会在这里。回忆下，你嵌入到任何会分发给他人的可执行文件中的东西都不再是秘密，因此，存放秘密在可执行文件中特别的微现。在某些例子中，甚至存放在正在执行的程序的堆中的秘密都被泄露了(divulge)，因此，甚至要在运行中的程序中避免存储和保持秘密。

让我们转向另一个问题：猜测。一个想要假装为一个用户的攻击者可以简单的猜出秘密么?考虑一个这个可能是最简单的密码：单个bit，值是0或者1。如果你的密码是单bit长，那么攻击者可以猜测"0"并且拥有50/50的机会是正确的。即使失败了，如果允许第二次猜测，攻击者现在就知道密码是"1"并且可以正确的才出来。

显然的，一个bit的密码太容易被猜出来了。那么8bit的密码呢?现在你可以选择256个密码。如果攻击者猜测了256次，迟早可以猜对，平均会猜测128次。比只猜两次好，但依然不够好。这应该让你明白了，对于这一点，密码长度是对抗猜测的关键。密码越长，越难猜测。

但是这里还有另一个重要的因子，因为我们通常希望人类从键盘或者类似的东西输入密码。考虑到我们已经排除掉把密码写在某个地方(因为不安全)，人们必须要记住密码。密码的早期使用通过限制密码为字母表字符解决了这个问题。这是的密码容易输入和记忆，但是它也大幅削减了攻击者为了找出密码需要猜测的密码bit模式(bit pattern)的个数，因为所有无法表示为字母字符的bit模式都不会出现在密码中。随着时间推移，密码系统已经倾向于扩展密码中可能的字符，包括大小写字母，数字，以及特殊字符。可能性越多，越难猜测。

所以，我们希望由各种不同类型字符组成的长密码。但是攻击者知道人们不会选择由这些字符组成的随机字符串作为密码。他们通常选择名字或者熟悉的字，因为这些容易记忆。攻击者在尝试猜测时会先尝试这些名字和单词然后再是随机字符串。这种密码猜测的形式叫做 __字典攻击(dictionary attack)__，它可以相当高效。这里的字典不是韦氏字典(websters)(或者剑桥英语字典(oxford english dictionary))，而是由单词，名字，有意义的数字字符串(例如"123456")，以及其它人们会用来作为密码使用的字符模式组成的特殊列表，通过被用来作为密码的概率排序。一个好的字典对于一个典型的站点可以找到90%的密码。
>#### 附注：密码保险库
>避免选择密码导致的问题的一个方式是使用叫做password valut或者key chain的工具。这是一个加密了的文件，存储在你的电脑上，内部存储了密码。他使用自己的密码加密文件。为了从库中获取密码，你必须提供库的密码，这减轻了为每个站点记忆不同密码的问题，你只需要记住一个密码。当然，它保证了攻击者只有在既有你保险库的密码，又能够访问你的保险库时才能使用你的密码。当然，这种安全存储密码的方式的好处会受到存储在保险库中密码长度的限制，因为猜测和字典攻击依然起作用。某些密码保险库会为你生成强密码，一个不是很容易记忆的密码，但是这没有关系，因为保险库才需要记它，而你不用。你还可以在云中找到存放了你密码的保险库。如果你是让它们存储密码的明文，你就是给了另一个实体分享了密码，而它并不真正需要，这就会有本不必要的风险。如果云只是存放了你加密后的密码，风险就降低了很多。

如果你善于设置你的系统，一个攻击者真的不应该可以远程的对登录进程进行字典攻击。稍微慎重些，攻击者将会才开始5，6次猜测中就猜出用户的密码(哎，有时候就是不够慎重，而攻击者就可以猜出来)，而没有理由你的系统会允许一个远程用户可以对一个账户的密码进行15000次猜测而无法猜对。因此，要么就当多次尝试输入密码失败时关闭对账户的访问 ，要么(更好的)在几次错误猜测后，大幅减慢密码检查过程(这会导致长字典攻击花费不切实际的时间)，你可以从这些攻击中保护账号。

但是，如果攻击者窃取了你的密码文件呢?因为我们假设你已经很小心了，它包含的是密码的哈希，而不是密码本身。但是我们还假设了在我们告诉你使用一个被广为人知的加密哈希时，你注意到了，而且，如果你知道这个，那么窃取你密码文件的人也知道。如果攻击者获取了你哈希后的密码，哈希算法，字典，以及某些计算力，攻击者可以在他们空闲时随意猜测你的密码。更糟糕的是，如果每个人使用的是同样的加密哈希算法(这在实际中是很可能的)，攻击者只需要通过这个哈希算法运行每个可能的密码并存储结果(本质上，字典被翻译为哈希形式了)。因此，当攻击者窃取了你的密码文件，ta只需要用你的哈希后的密码和新创建的哈希后密码字典进行字符串比较，这就非常快了。

有一个简单的修复：在对一个新密码进行哈希并存放在你的密码文件中前，生成一个随机数(例如32或者64bit)并把它和密码结合起来。哈希这个结果并存储它。你还需要存储这些随机数，因为当用户尝试登录并提供正确的密码，你需要使用用户提供的密码，以及存储的随机数字，然后使用哈希算法进行哈希。否则，自身哈希后的密码实不会和你存储的匹配的。通常你会在存放密码的文件中，在已经哈希过的密码右边存放这个随机数(也被叫做 __盐(salt)__)。这个概念是由Robert Morris和Ken Thompson关于密码安全的早期论文中引入的。

这会有什么帮助?攻击者将无法在字典中创建密码到哈希的翻译了。他需要的是对所有可能的盐进行翻译，因为被窃取的密码文件对每个密码都有不同的盐。如果盐是32位，那么对字典中每一个字都有$2^32$不同的翻译，这就使得提前计算翻译的方式变得不可行。相反，对于被窃取的密码文件中每个条目，字典攻击必须重新使用密码的盐和猜测的密码一起进行哈希。如果你选择了糟糕的密码，这个攻击依旧是可行的，但是它不会很容易了。任何使用密码的系统，如果关心安全，就会存储加密哈希和加盐后的密码。如果你不是，你就在将你的用户置于风险中。

使用密码还有其他的问题，但是这些中很多不特定于OS，因此我们这里不会过多的说密码的不好。可以这么说，在计算机安全社区中，有着广泛的认同，即密码是过时的技术，对于现今的环境他已经不太安全。在最好的情况下，它们可以用来作为几种认证机制中的一种一起使用。这个想法叫做 __多因子认证(multi-factor authentication)__，其中 __双因子认证(two-factor authentication)__ 是最广泛使用的一个版本。你可能已经对这个概念很清楚了：为了从ATM中取钱，你需要知道你的个人标识数(personal identification number PIN)。这本质上是一个密码。但是你还需要提供你身份的更多证明。

>#### 附注：Linux登录过程
>Linux，在早期的UNIX系统的传统中，基于密码认证用户并将标识和与新登录用户关联的一个初始化进程绑定，很上面描述的很像。这里我们对当一个用户尝试登录Unix系统时发生的事情，提供一个更加详细的一步一步的描述，作为作为一个真是系统是如何处理这一关键安全问题的稳固例子。
>1. 一个运行在高权限系统标识下的特殊登陆进程显示了一个提示符要求用户录入ta的标识，通常是以一个短的用户名的形式。用户键入用户名并输入回车返回。用户名会在终端显示。
>2. 登陆进程地提示用户密码。用户键入密码，这个不会显示。
>3. 登陆进程在密码文件中查询用户提供的名字。如果没有找到，登录进程会回绝登录尝试。如果找到了，登录进程判断这个用户归属的内部用户标识(一个唯一的用户ID数)，用户组(另一个唯一ID数)，一旦用户登录完成，就会提供初始的命令shell，以及这个shell应该从中开始的home目录。还有，登录进程找到盐和加盐哈希过的用户正确密码，这被持久化存储在系统中安全的地方。
>4. 登陆进程把用户提供的密码以及用户密码对应的盐结合起来执行哈希。比较由上一步获取到的存放了的版本密码和这个结果比较。如果不匹配，登录进程拒绝登录尝试。
>5. 如果匹配，fork一个进程。根据之前判断出来的用户和用户组设置这个fork出来的进程的这些值，而登陆进程是拥有特权标识，所以允许这样做。修改目录为用户的home目录然后执行与用户关联的shell进程(在第三步中，目录名称和shell类型都已经判断了)。
>还有其它与之关联的细节用来确保我们可以在同一个终端，在这个账户登出后，登录另一个用户而不会回到这里。
>注意，在第三步和第四步中，登录失败的原因可以实因为用户名在系统中不存在，或者是因为用户名密码不匹配。如果失败了，Linux和大多数其他系统不会标识是哪种条件失败了。这样就组织了攻击者通过输入猜测的用户名可以知道合法用户的用户名，因为他们无法知道他们是猜到了一个不存在的用户名还是对猜错了合法用户名的密码。不给未认证用户有用的信息通常是一个好的安全想法，被应用在了其它类型的系统中。
>思考下为什么Linux系统选择输出输入的用户名而不输出输入的密码。输出用户名是否有非安全的不利影响，是否绝对有必要输出用户名，或者它是安全与方便之间的权衡么?为什么不输出用户名?

### 54.5 根据你有什么的认证
我们中的大多数可能经历过这种情况，我们需要一个身份证才能进入到某个地方。至少，我们出席过某些赛事，而进场许可是依靠赛事门票的。这些都是基于你有什么进行认证的例子，在前面的例子中，就是身份证卡和门票。

当像一个操作系统证明你自己时，事情就变得不一样了。在特别的情况中，例如前面提到的ATM，设备(毕竟，里面是有一个电脑的--你知道的，对吧?)有着可以读取我们ATM卡的特殊硬件。这个硬件允许它判断我们有这个卡，然后使用你的PIN提供进一步的证明。大多数桌面电脑，笔记本，平板，智能手机很有可能没有这种特殊设备。所以它们是如何区分我们有什么的?

如果你有可以插到计算机某个接口的设备，例如使用USB的设备，假设适配的软件支持，操作系统可以区分尝试登陆的用户是否有着合适的设备。某些安全token(有时候叫做 __电子狗(dongles)__，一个不幸的名字选择)被设计按照这种方式工作。

在其他例子中，因为无论怎样，我们试图认证一个人类用户，我们利用了人类的能力来转换任何来自ta所有的信息给需要认证的系统。例如，某些智能token会在一个小的内嵌屏幕上面显示一个数字或者字符串。人类用户读取这些信息并输入到计算机中。操作系统不会得到用户有这个设备的直接证明，但是如果只有访问设备的某个人可以知道应该被输入的信息是什么，这个证据就已经很好了。

这类设备依赖于这个设备(直接或者间接)传给操作系统的信息会频繁的修改，可能是每过几秒钟，可能是每次ta试图认证ta自己。为什么?嗯，如果他不这样，任何知道了这个设备提供的静态信息都可以不再需要它来扮演用户了。这个认证机制从"你有什么东西"转换为"你知道什么东西"，而它的安全性现在依赖于一个攻击者了解到秘密有多困难。

所有基于你有什么的认证形式都有的一个弱点是，如果你没有它呢?如果你今早把你的手机落在了梳妆台上呢?如果你再上班路上把电子狗弄丢了呢?如果一个狡猾的扒手在咖啡店和你擦肩而过顺走了你的秘密认证设备呢?你现在有两层问题。首先，你没有了那个魔力设备可以向操作系统认证你自己。你可以尽可能的向计算机哭诉，但是他不会搭理你。它会一直要求你提供你丢失的魔力设备。第二，某个人拥有了你的魔力设备，很可能它们可以假装为你，愚弄那些依赖于你有什么来认证的操作系统。注意多因子认证在此刻仍旧可以保护你。如果小偷偷走了你的安全token，但是不知道你的密码，这个小偷依旧需要猜测你的密码才能假装你[<sup id="content4">4</sup>](#4)。

如果你在实践中研究了很久系统安全，你会发现，在学术界中(比如作者)告诉你什么是安全的与在现实中会发生什么之间有很大间隔。这个间隔中的一部分是因为真实世界需要处理真实的问题，例如用户方便。部分是因为安全学术界会有一个倾向，会诋毁任何一个事物，如果他们可以想出方法摧毁它，甚至是这个方法本身不是特别实用。在基于你有什么的认证机制领域中的一个例子是通过给一个用户手机发送短信为系统认证用户。然后用户在计算机中输入信息。在理论中思考这种方式，看起来非常弱。除了丢失手机的风险外，安全专家还会考虑外部攻击：这个短信被发送到了攻击者的手机上，从而允许攻击者可以提供短信上的秘密信息给计算机。

在实际中，人们通常都会有自己的手机，并且会仔细保管防止丢失。如果他们的手机确实丢了，他们很快就会注意到并且会快速的修复这个问题。所以这里在你丢失手机和系统知道不能通过你的手机认证你之间就只会有相对很小的时间窗口。同样在实际中，重定向短信发送给手机是可能的，但是很困难。涉及的影响很可能超出了攻击者从愚弄认证系统中获取到的任何好处，至少在大部分情况下是这样的。所以一个可能会让安全存粹主义者惊讶的移开目光的机制在实际使用中可能会提供合理的安全[<sup id="content5">5</sup>](#5)。记住这个例子。即使他不会出现在考试中，他可能会在你后面的职业生涯中出现[<sup id="content6">6</sup>](#6)。

### 54.6 基于你是什么的认证
如果你喜欢像是密码这样的方式，或者你不想要给你用户智能卡或者安全token，这里还有其它的选择。人类(就是这里我们讨论要进行认证的人)都是唯一的生物，有着和其他所有人都不一样的物理特征，有时候在某些细节上，有时候在显著的地方。除了人类身体(从位于基层的DNA到在顶层我们面部的样子)的属性外，人类行为特性也是唯一的，或者至少不会和大多数人一样。这个观察建议如果我们的操作系统可以只精确的测量这些属性或者特征，它可以区分不同的人，从而解决认证的问题。

这个方式对很多人都有吸引力，特别是对那些还从没有试着让这个可以工作的人。从基本观察到可以工作，可靠的认证系统远不简单。但是它是可以工作的，可以和其他认证机制达到相同的程度。我们可以使用它，但是她并不完美，并且他有着自己的问题和挑战。

记住，我们这里讨论的是计算机程序(要么是OS自身，要么是OS为了这个目的而调用的其它程序)测量一个人类特质并确定他是否属于一个特定的人。考虑下这意味着什么。如果我们计划使用智能手机上的相机进行人脸识别认证手机拥有者呢?如果我们决定它是正确的人，无论是谁拍摄了这个照片我们就允许他使用手机。如果不是，我们就给他们覆盆子(raspberry)(以赛博的意思 in cyber sense)并且不允许他们进入。

你应该察觉出来一些挑战了。首先，相机将要拍摄某个可能正在持有手机的人的照片。可能是所有者，也可能不是。这就是拍照的重点。如果它不是，我们就应该假设无论它是谁，它想要愚弄我们认为它们是真正的所有者。如果某个人长得很想正确的用户，但又不是，会怎样?如果这个人带了口罩会怎样?如果这个人拿着手机对着正确的用户，而不是他自己的脸呢?如果灯光太暗，或者这个人没有在镜头前露出全脸呢?另外，如果是正确的用户，而这个人没有在镜头露出全脸，或者灯光太暗，或者其他什么东西修改了这个人的面貌呢?(例如，发型)

计算机程序不是按照人类的方式识别人脸的。他们是按照程序处理数据的套路来处理的:它把图片转换为0和1，然后使用某种算法处理它们。所以，你拍摄的"照片"实际上是一堆数字的集合，标识了阴影和亮面，颜色的深浅，对比以及类似的东西。OK，现在呢?是时候决定这个照片是否是正确的人的了，怎么判断?

如果它是密码，我们可以存放正确的密码(更好的方式，正确密码的哈希值)，并将我们存储的密码和用户输入的密码进行比较。如果完美匹配，就认证。否则，就不认证。我们可以以同样的方式来比较代表我们刚刚拍摄照片的0和1的集合么?我们能在某个文件(也是按照01的形式)中持久化存放正确用户的照片并拿它和来自相机的数据进行比较么?

可能和我们比较密码不是同一个方式。考虑我们上面提到的一个因素:灯光。如果我们存放在文件中的图片是在明亮的灯光下拍摄的，而从相机中拍摄的照片是在昏暗的灯光下拍摄的，这两个01集合很可能匹配不上。事实上，同一个人的两个图片，即使第二张是在完全相同的条件下拍摄的，代表着两张图片的bit集合也不太可能是一样的。所以，显然我们不能按照基于每个bit相等的方式进行比较。

相反，我们需要基于对两张图片(正确用户存储的以及声称是这个用户的刚刚通过相机拍摄的照片)更高层次的分析进行比较。通常这会涉及到提取照片中高级特征并进行比较。我们可能，例如，试图计算鼻子的长度，或者判断眼睛的颜色，或者设置嘴型的某种模型。然后我们比较这两张图片中特征集。

甚至是现在，精确匹配仍然不太可能。例如，灯光可能会稍微修改下眼睛的颜色。所以我们需要在比较中允许不同。如果特征比较是"足够的"，我们就认证，否则，我们就不认证。我们会查询接近的匹配，而不是完美匹配，这就会在认证过程中引入公差(nose of the camel of tolerances into our authentication tent)。如果我们除了最接近的匹配外别的都不接受，那么总有一天我们会在比较正确用户的照片和存储的版本时会失败。这叫做 __假阴性(false negative，假阴性，伪阴性，漏报率)__，因为我们错误的决定认证不通过。如果我们对测量的和存储的数据的差异容忍过多，我们认证一个用户为并他所声称的那个用户，尽管他不是，这是 __假阳性(false positive，错报率)__，因为我们错误的判断认证通过。

生物测定的本质是任何实现都会有假阴性和假阳性特性。这些都很糟糕，所以你想要二者都很低。对于任意某种生物识别认证实现，你一般可以调节它达成某种假阴性率，或者调整它达成某种假阳性率。但是你通常无法将两者都最小化。因为假阴性下降了，假阳性率就会上升，反之亦然。__敏感度(sensitivity)__ 描述了这些比较是如何的接近。

![figure54.1.png "交叉错误率"](figure54.1png "交叉错误率")

图54.1显示了这些错误率的典型关系。注意两条线交叉点的圆圈。这个点表示了交叉错误率(crossover error rate)，一个常见的描述生物测定准确度的测量指标(metric)。这表示了在两类错误之间一个相等的权衡。我们在调优一个生物测定系统时并不总是会触及这个交叉错误率，因为相对于一个错误，你可能会更关心另一个错误。例如，一个智能手机频繁地由于指纹读取结果不匹配而将它的合法用户锁在外面是不会流行的，因为偷窃手机的小偷拥有类似指纹的概率很低。可能低假阴性在这里更重要。另一方面，如果你使用视网膜扫描打开一个银行保险库，要求银行经理偶尔扫描两次并不糟糕，因为允许一个抢劫犯使用义眼就打开这个保险库就是灾难了。低假阳性在这里就更好了。

将使用基于生物测量的认证的可靠性放在一边，使用人类特征认证的另一个大问题是测量这些生物信息的很多激素需要特殊的硬件，在大多数机器上不常见。很多计算机(包括智能手机，平板和笔记本)都会有摄像机，但是嵌入式设备和服务器机器可能没有。相当少的机器有指纹读取器，测量其他生物特征的设备就更少了。而一些生物测量技术(例如测量打字模式)相对来出需要很常见的硬件，在大多数机器上面都会有，但是这样的技术很少。尽管有可用的特殊硬件设备，为这个目的使用它们的方便性可能很受限。

当考虑使用生物认证时你想要思考的进一步的问题是在被测量的生物测定量的地方与检测这些测定量之间的物理间隔。特别的，检测由一个跨网络不受信任的机器提供的生物测量信息是危险的。从网络传递过来的东西只是分布在一个或者多个消息的比特模式，无论它代表的是网页片段，在VoIP交谈中的音素，或者是扫描的指纹的部分。比特就是比特，任何人都可以按照他们的想法创建任何的比特模式。如果一个远程敌人知道什么样的比特模式代表你的指纹看起来的样子，他可能不需要你的手指，甚至是一个指纹扫描仪，就可以创建一个并送给你的机器。当执行扫描的硬件是和你的机器是物理连接的，那么偷偷使用不是来自这个设备的伪造比特模式机会就比较少了。当硬件是在位于世界的另一边的你无法控制的机器上，就会有很多机会了。这里的重点是仔细对待远程提供给你的生物认证信息。

总的来说，对于认证来说，生物测量听起来很糟糕，但这是错误的。就此而言，之前的段落可能让所有的认证方法听起来很糟糕。当然他们都不是完美的，但是作为一个系统设计者你的任务不是找到一个完美的认证机制，而是使用能够适配你系统和它的环境的机制。好的智能手机自带的指纹读取器可以很好的完成自己的工作。长的，难以猜测的密码可以提供大量的安全。良好设计的智能卡可以让没有它们在手时几乎无法认真你自己。并且，一种机制失败了，你还可以通过使用在同样情况下不会失败的第二个或者第三个认证机制修复这个错误。

### 54.7 认证非人类
不，我们不是在讨论外星人或者额外维度的存在，或者你的猫。如果你广泛的考虑当今计算机是怎么被使用的，你会发现在很多环境中是没有人类用户与正在运行的进程关联。考虑一个web server。确实不太会有已经登录的人类用户的标识应该跟web server关联。或者考虑嵌入式设备，例如智能电灯。没有用户会登录电灯，但是这里肯定会有代码运行，很可能是面向进程的代码。

机械式地，这些进程没有标识操作系统也不会有问题。简单的给讨论中系统设置一个用户叫做`webserver`或者`lightbulb`，并把这个"用户"的标识与这些运行的进程(运行着的web server或者对电灯的开与关)关联。但是确实会导致问题：如何确保这唯一真正的web server进程被标记为这个标识。在web server的机器上我们不希望任意用户创建的进程会属于这个server，而不是那个用户。

一个方式是也为这些非人类用户使用密码。简单的给这些web server用户赋一个密码。什么时候使用这些密码?当它需要时，就是当你想要创建一个进程属于这个web server，但是现在还不存在。系统管理员可以以web server用户
创建一个命令shell并用它生成这个server需要完成它的业务的一个实际的进程。就像平常一样，由shell进程创建的进程会继承他们的父进程的标识，在这个例子中就是，`webserver`。更一般地，我们跳过中间步骤(这里，就是登录)并提供某种机制通过特权用户可以创建不属于它，而是属于别的用户(例如`webserver`)的进程。或者，我们可以提供一个机制允许进程修改自己的所有权，这样web server进程可以在其他用户的标识下启动(例如系统管理员的)，然后修改自己的所有权为`webserver`。另一个方式是允许临时修改进程标识符，并且始终记住原来的标识符。(我们在后面的章节会更多的讨论最后一个方法)。显然，这些方式需要强控制，因为它们允许一个用户创建一个属于另一个用户的进程。

就像上面提到的，密码是用来判断一个进程是否可以被付给那些非人类用户中的一个最常见的认证方式。尽管，有时候也根本不需要认证非人类用户。相反，某个其他用户(例如，受信任的管理员)被赋予了权限可以给他们创建的进程赋予新的标识，而不需要提供除了他们自己以外的其它任何认证信息。在Linux和其它Unix系统中，`sudo`命令提供了这个能力，例如，你可以输入如下命令:`sudo -u webserver apache2`。

这会标识`apache2`程序应该在`webserver`的标识下启动，而不是在运行`sudo`命令的人的标识下运行。这个命令可能要求用户提供自己的认证证书(为了真的确定这真的就是特权用户要求的，而不是某个人趁着特权用户喝咖啡的时候访问的电脑)，但是不会要求和`webserver`相关的认证信息。当然，任何由`apache2`创建的子进程，都会继承`webserver`的标识。在访问控制的章节中我们会讨论更多和`sudo`相关的内容。

最后一个我们前面暗指过的标识的问题是有些时候我们希望不仅仅标识独立的用户，还可以标识共享了共同特质(通常是安全相关的特质)的用户组。例如，我们可能会有4，5个系统管理员，他们都被允许可以启动web server。相对于跟别给他们每个人关联这个权限，创建一个对系统有意义的有这个权限的用户组更有好处。我们后面标识这4，5个管理员作为组的成员。这种组类型是安全相关的principal的另一个例子，因为我们是基于组身份的基础做决策，而不是独立的标识。当有一个系统管理员希望做某件事情需要组身份，我们检查ta是否是一个成员。我们要么可以给每个进程都关联一个组成员，或者使用进程独立的表示信息作为这个人归属组列表的索引。后者更灵活，因为它允许我们可以将用户放到任意数量的组中。

大多数现代操作系统，包括Linux和Windows，都支持这些种类的组，因为在处理安全策略的应用下提供了易用性和灵活性。它们处理组身份和组权限的方式大致类同独立用户的方式。例如，一个子进程通常和它的父进程有着一样的组相关(group-related)的权限。当在这些系统中工作时，记住组身份提供了一个用户可以获取访问资源权限的第二条路很重要，这有着自己的利弊。

>#### 附注：其他的认证可能性
>通常，你知道什么，你有什么以及你是什么已经覆盖了可用的认证可能性，但是有时候还有其他选项。考虑去车管所申请驾照。你可能会走到一个柜台然后和柜台后面的员工交谈，可能会给他一大堆个人信息，甚至会支付驾照的费用。到底为什么你会认为这个人确实就是DMV的员工，可以让你得到合法的驾照?你可能不知道这个人；他没有给你展示工作证；这个人也没有背诵秘密的DMV咒语证明ta是这个机构的新人。你相信是因为这个人站在一个特殊的柜台后面，而这是DMV员工的位置。你在基于这个人的位置认证他。
>偶尔，这个方式在计算机系统会有用，最常见的是在移动或者普适计算(mobile or pervasive computing)。如果你想使用它，仔细思考你是如何获取目标确实在某个特殊位置的证据。它其实相当麻烦。
>还有什么?可能有时候你可以基于某人做了什么进行认证。如果你在查找个人特征行为，例如他们的输入模式或者两个命令间的延迟，这是生物测量的一类。(举个例子，Google在它的安卓手机上引入了这类多因子认证。)但是，相对于认证它们属于某一类有着良好行为的用户，你对认证它们到底是谁可能兴趣更少些。例如，很多网站，很少关心他们的访问者是谁，而关心的是他们是否在合适的使用网站。在这个情况下， 你可以通过他们和你系统持续的互动认证他们在集合中身份。

### 54.8 总结
如果我们想要对我们系统中执行动作的进程应用安全策略，我们需要知道进程的标识，从而指定合适的策略。我们从在启动时刻创建一个属于某个系统用户(他的目的是为了认证用户)的进程开启整个进程链。他们登录，提供一种或多种形式的认证信息证明它们的身份标识。这个系统使用这些信息验证他们的身份标识并将他们的标识赋予给新的进程从而允许这个用户可以继续自己的事业，通常是涉及到运行其它进程。这些其他进程会从它们的父进程继承这个用户的标识。特殊的安全机制可以允许进程的标识被修改或者被设置为其它的标识而不是父进程的标识。然后这个系统可以确定进程属于这个合适的用户并相应的指定安全决策。

历史上以及实践上，提供给系统的认证信息要么是待认证用户知道的某些事(例如密码或者PIN)，要么是用户拥有的(例如智能卡或者拥有一个智能手机)，或者用户是什么(例如用户的指纹或者声纹扫描)。这些方式都有自己的强处和弱点。更高等级的安全可以用过多因子认证获取到，这要求用户提供超过一种形式的证据，例如要求用户提供密码和发送给用户智能手机上的一次性码。

[<sup id="1">1</sup>](#content1)单词"object"又一次被计算机科学复用。这里，他跟"面向对象(object oriented)"无关，而是对一个有着边界和行为的特定资源更一般的概念(the more genernal concept of a specific resource with boundaries and behaviors)，例如一个文件或者一个IPC channel。
[<sup id="2">2</sup>](#content2)还记得之前章节中最少权限原则么?这里就是使用它的一个例子。一个劣迹斑斑的人力服务员工不能命令你的仓库情况pop-doodles，如果你没有给这些雇员权力去做这些事情。当你在阅读本书和安全有关的章节时，请注意我们之前章节讨论过的安全原则的其他运用。
[<sup id="3">3</sup>](#content3)"可能是一个很弱的词"。已知的第一个这种被偷的密码泄露是1962年，发生在当今的泄露有着令人沮丧的规律以及相当大的范围。论文讨论了以可用的方式存储的超过一亿个密码泄露。
[<sup id="4">4</sup>](#content4)假设，当然，你没有使用记号笔在被偷走的智能卡背后写上密码。嗯，在之前这个看起来是一个好主意...
[<sup id="5">5</sup>](#content5)然而，在2016年美国国家标准技术委员会发布了草案废弃了这项技术用于两因子认证，至少是在某些环境。这里是另一个安全课程：今天可以工作的明天不一定可以
[<sup id="6">6</sup>](#content6)我们不知道你什么情况，但是每次我们提到"测试"，"问题"或这"考试"，我们的心会少跳一两下。做了太多年学生就会这样