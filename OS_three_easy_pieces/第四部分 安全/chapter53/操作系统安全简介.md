## 操作系统安全简介
本章由Peter Reiher(UCLA)撰写
### 53.1 介绍
计算系统的安全性至关重要且只增不减。由于计算机安全的失效导致了很多钱物和人力的损失。对计算机系统的攻击是如此的常见，几乎在任何你会执行计算的场景中都不可避免。一般的，计算机系统的所有元素都会成为攻击目标，它们中的任何缺陷都会给攻击者机会做某些你想要阻止的事情。但是从安全的角度来看，操作系统特别的重要。为什么？

首先，基本上所有东西都是运行在操作系统之上。作为一个法则，如果你依赖某个软件，无论这个软件是操作系统，中间件的一部分或者是其它什么东西，如果它是不安全的，那么在它之上的都将是不安全的。这就像是在沙子上面盖房子一样。你可以构建一个很稳固的结构，但是洪水依旧可以冲走你房子下的地基，无论你在房子结构中用了多少心思，他都会完全摧毁这个房子。类似地，你的应用本身可能没有安全缺陷，但是如果攻击者可以误用你底层的软件从而偷取你的信息，使你的程序崩溃，或者其它让你受伤的方式，你自己用来保护你代码的努力可能为零。

这一点对于操作系统来说至关重要。如果你不运行某个特定软件(例如某个web server或者是数据库系统)，你可能不关心它的安全，你可能不关心你没有用到的中间件平台的安全，但是每个人都会运行一个操作系统，而可选项相对很少。因此，操作系统的安全缺陷，特别是一个被广泛使用的操作系统，对很多用户和软件都有巨大的影响。

操作系统安全是如此重要的另一个原因是根本上我们所有软件都依赖于底层硬件的正确行为：处理器，内存，以及外围设备。是什么对这些硬件资源有着根本控制?操作系统。想一下你已经学习过的和内存管理，调度，文件系统，同步等等有关内容，如果一个敌人可以以某种任意糟糕的方式使用你的操作系统，那这些组件会发生什么?如果已经理解了目前你学习到内容，你应该知道这个预测让人深深的不安(you should find this prospect deeply disturbing)[<sup id="content1">1</sup>](#1)。我们的计算生活依赖于我们的操作系统是按照它们定义的行为工作，并且特别的是它们不会按照有利于我们敌人而不是我们的行为工作。

保护操作系统(securing operating systems)的任务并不简单，因为现代操作系统巨大且复杂。你的编码经验已经指出了，你写的代码越多，算法越复杂，你的代码中就越可能包含缺陷。规模大而复杂的程序相比于规模小而简单的程序更难于保护。并没有多少程序想操作系统那么庞大复杂。

在保护操作系统(securing operating systems)中的另一个挑战是在大部分情况，它们都打算同时支持多进程。正如你学得到的，在操作系统中，有很多机制都是用来隔离各个进程，从而保护硬件中共享部分不会被其他进程影响(and to protect shared pieces of hardware from being used in ways that interfere with other processes)。如果每个进程都是可信任的，它们使用机器上任意的硬件资源和数据做任何它们想做的事情而不会伤害到其它进程(If every process could be trusted to do anything it wants with any hardware resource and any piece of data on the machine without harming any other process)，对系统的保护就容易的多了。然而，我们一般不能同等的信任所有事情。当你从一个之前没有访问过的网站下载并执行一个脚本，你真想要它可以删除你硬盘上所有的文件，杀掉你其他所有进程，并使用你的网络接口发送垃圾邮件给其他机器？可能不，但是如果你是电脑的所有者，你有权做所有那些事情，如果这就是你想要做的。并且除非操作系统很仔细，任何它运行的进程，包括你下载的那个脚本，可以做任何你可以做的事情。

从不同的角度考虑操作系统安全问题。操作系统的一个角色就是给应用程序提供可以在之上构建的可用抽象(one role of operating system is to provide useful abstractions for application programs to build on)。这些应用必须依赖这些抽象的操作系统实现可以按照它们定义的那样工作(These applications must rely on the OS implementations of the abstractions to work as they are defined)。通常，这些抽象的定义有部分是关于它们的安全行为。例如，我们期望操作系统的文件系统会执行他们应该执行的访问限制。然后，应用程序可以在这个期望之上构建从而完整它们需要的安全目标，例如指望(counting on)文件系统访问保证来确保它们特别指定为不可编辑的(unwriteable)文件不会被修改(altered)。如果应用程序无法依赖对操作系统抽象的安全保证的正确实现(proper implementation of security guarantees for OS abstractions)，那么它们就不能使用这些抽象完成自己的安全目标。往小的说，这意味着应用开发者要有大量的工作要做，因为它们需要采用额外的测量完成它们所需的安全目标。考虑到我们之前的讨论，它们通常无法达成这些目标，如果它们必须依赖的抽象(例如，虚拟内存或者有着良好定义的调度策略)不可信任。

显然，操作系统安全至关重要，单很难实现。因此，我们我们需要做些什么来保护我们的操作系统?解决这个问题已经成为了几代计算机科学家的挑战，目前依旧没有完整的答案。但是还是存在一些重要的原则和工具可以供我们保护操作系统使用。这些一般都是内建于任何你可能会使用的通用目的(general-purpose)操作系统中，它们改变了这个系统可以完成什么(they alter what can be done with that system.这句不太好翻译，deepl给出来的翻译是它们改变了系统的功能)以及你要如何着手做。因此，你可能认为你对安全不感兴趣，但是你需要理解你的操作系统做了哪些事情保护自身，也要理解如何让系统做你想要做的事情。
>#### 症结：如何保护操作系统资源
>面对多个可能的并发和交互进程运行在同一个机器上，我们如何保证每个进程允许访问的资源确实就是它们应该访问的，并严格按照我们想要方式访问?我们需要从OS中获取什么样的原语?硬件应该提供怎样的机制?我们要怎么使用它们解决安全问题?

### 53.2 我们保护的是什么?
当我们说我们操作系统应该被保护时，我们不太可能达成良好的保护除非我们对我们要保护的东西有一个相当全面的观点。幸运的是，这个问题对于操作系统来说很容易回答，至少在高层的上面：所有事情。

典型的商用操作系统对机器上所有(或者是几乎所有的)硬件都由完全的控制并且有能力可以真正意思上做任何硬件允许做的事情。这意味着它可以控制处理器，读和写所有寄存器，检查任何主存位置，以及执行任何它外设支持的操作。作为结果，操作系统可以做的是：
* 检查或者修改任意进程的内存
* 读，写，删除或者污染在任意可写持久化存储介质上的任意文件，包括硬件和闪存驱动
* 改变调度或者甚至是停止任何进程的执行
* 发送任意消息到任意位置，包括一个进程想要发送内容的修改版本
* 启用或者禁用任意外围设备
* 给任意进程访问任意其它进程资源的权限
* 武断的夺取一个进程控制的任意资源
* 用伤害最大化的谎言回应任意系统调用

本质上，进程是受操作系统支配的。对于一个进程来说，它几乎不太可能在一个恶意操作系统中保护自己任何部分。我们一般假设我们的操作系统实际上不是充满恶意的[<sup id="content2">2</sup>](#2)，但是缺陷可能会允许恶意进程导致操作系统错误的行为近似于坏的，因为它可能潜在的允许进程获取操作系统本身的任意能力。这一点应该能让你严肃的考虑设计安全操作系统的重要性以及，更常见的，给你正在使用的操作系统应用安全补丁(security patches)。在你操作系统中的安全缺陷可以让系统运行在的机器所有东西受损，因此，阻止它们并对任何被发现的缺陷打补丁至关重要。

### 53.3 安全目标和策略
当我们谈到我们想要操作系统，或者任何系统是安全的，我们是什么意思呢？这是一个相当模糊的陈述。我们真正的意思是有些事我们希望在这个系统里发生，而有些事情我们不希望，我们希望能够高度保证我们想要的。在生活中其它方面，我们通常最终要为我们得到的东西付费，所以仔细考虑我们实际需要的安全属性和效果到底是什么很重要，然后只为这些付费，而不用为其他我们不需要的付费。这些归根到底就是我们想要明确我们系统中安全相关行为的目标，并选择能够以合理成本达成这些目标的防御手段。

安全研究员已经在广泛的范围内考虑这个问题很长时间了。在一个高的概念层级上，他们定义了三个在很多系统中(包括操作系统)都通用的安全相关的目标。他们是：
* __保密性(Confidentiality)__ 如果消息中某些部分要对一些人隐藏，就不允许他们找到。例如，如果你想要保证你的信用卡号是机密的，你肯定不想其他人知道你的信用卡号。
* __完好性(Integrity)__ 如果信息的某个部分或者系统的组件应该处于一个特定状态，不应允许敌人修改它。例如，如果你已经在线订购了一个意大利腊肠比萨，你不想要一个爱开玩笑的人修改你的订单为1000个凤尾鱼披萨。完好性的一个重要方面是真实性(authenticity)。确保不仅仅消息没有被修改，而且消息是有特定组织而不是敌人创建的通常很重要。(注：这里不仅仅有消息的完整性还有不可篡改性和验证)
* __可用性(Availability)__ 如果某些消息或者服务对于你活着其他人是可用的，确保攻击者不能阻止使用它。例如，如果你的生意正在大减价，你肯定不想你的竞争对手可以阻塞你店铺周围的街道，阻止你的客户到你那。

对于计算机系统来说安全的另一个重要方面是我们通常希望保证当某人告诉我们一些事情时，他们在后面不能否认他们做了这个。这个方面通常叫做 __不可否认性(non-repudiation)__。人们否认他的动作越难越昂贵，控制人们为这些行为负责(account for)越容易，人们也就更少的执行恶意操作。毕竟，他们可能会被抓住并且很难拒绝他们做的事情。

这些都是大的，一般性的目标。对于一个真实的系统，你需要向下钻取到更详细的，明确的目标。例如，在一个典型的操作系统中，我们可能需要一个保密性目标，它声明了一个进程的内存空间不能被其它进程任意读取。我们可能需要一个完整性目标，他声明了如果一个用户在一个特定文件中写了一行记录，其他没有能力对那个文件写入的用户不能修改这条记录。我们可能有一个可用性目标，他声明了在系统中运行的一个进程不能独占(hog)CPU，阻止其它进程获取他们的CPU份额。如果你回想你已经学习过关于进程抽象，内存管理，调度，文件系统，IPC和本课程其它主题，你应该能考虑到其它明显的保密性，完好性和可用性目标加入到我们操作系统中。

对于任意特定的系统，甚至这个级别的目标都不够明确。上面的完整性目标中，一个用户文件不应该被其它不允许被编辑的用户被重写，会给你一个提示，就是对于一个特定系统我们的安全目标是要多么明确。也许有某些用户可以复写这个文件，例如当两个人合作编写一个报告时。但是这不意味着无关的第三方人员能够编辑这个文件，如果它没有合作编写存储在这里的报告。操作系统的设计，是为了让很多人按照不同需求使用，操作系统安全应该反映这种通用性。对于操作系统的安全机制，我们想要的是在我们描述的详细安全目标中的灵活性。

当然，根本上，操作系统软件必须尽最大努力达成这些灵活的安全目标，这意味着我们将需要编码那些目标为软件可以理解的方式。我们通常必须将我们安全目标不明确的理解转为高度明确的 __安全策略(security policies)__。例如，再上面描述的关于文件的例子，我们可能想要明确一个策略类似"用户A和B可能写文件X，但是其它用户不能写它"。有了这种程度的明确性，回到仔细地设计和实现机制，我们可以希望达成我们的安全目标。

注意对于操作系统安全一个重要的暗示(implication)：在很多情况中，一个操作系统会有必需的机制实现所需的安全策略，并在它的适当的应用中对这些策略提供高度保证，但仅在有人精确的告诉操作系统这些策略是什么的时候，才会有这些机制。除了某些重要的例外(例如除非有特别的指示(specifically directed)，维护一个进程地址空间私有)，操作系统只提供可以实现多种特定策略的一般机制。然而，如果缺乏对策略的智能设计和对机制的仔细应用，操作系统应该或者可以做的事情可能不是你的操作系统要做的事情。
>#### 附注：安全VS容错(security vs fault tolerance)
>当讨论进程抽象时，我们讲述了虚拟化是如何保护一个进程不受其它进程动作干扰的。例如，我们不希望我们的进程内存被其他进程意外覆写，因此我们的虚拟化机制不得不阻止这样的行为。然后我们主要讲了进程间的缺陷和错误。这个相比于担心恶意行为(在我们讨论的安全中它是一个更加常见的上下文)有任何实际的区别么？我们是否已经使用虚拟化我们的资源解决了所有问题？
>是，也不是。(这难道不是一个有用词组么?)是的，如果我们完美的虚拟化了所有事情并且不允许任何事情之间有交互，我们很大可能解决了大部分的恶意问题。然而，大多数虚拟化机制并不是完全防弹的。当没有人尝试破坏它们时，他们就可以正常工作，但是不会对所有可能的错误行为形式都是完美的。第二，可能也是更重要的，我们并不真的想要完全的进程与进程隔离。进程们默认会共享某些操作系统资源(例如文件系统)并可以随意的选择共享其它资源。这些虚拟化中故意的放松(intentional relaxtions of virtualization)如果使用得当是没有问题的，但是它们打开了合法共享的可能性也就打开了恶意攻击的潜在通道。最后，OS并不总是对硬件有完全的控制...


### 53.4 设计安全系统
你们中很少会有人会构建你自己的操作系统，甚至都不会已存在的任何操作系统做一些严肃的修改，但我们希望你们中大多数将可以构建某种大规模软件系统。许多计算机科学家的系统设计经验表明在构建有安全需求的系统中有一些设计原则很帮助。这些原则最初由Jerome Saltzer和Michael Schroeder在一个有影响的论文中列出，尽管其中有些是来自于别人早期的观察。当然，无论是最初的作者还是后来的评论者都没有生成遵循这些原则就可以保证你的系统是安全的，重视他们已经被证明会通向更安全的系统，而你忽略它们就要承担风险。我们这里会简要的讨论它们。如果你真的在构建一个大规模软件系统，它很值得你花费时间查询这个论文(或者对它更详细的评注)并仔细学习这些概念。

* __机制的经济(economy of mechanism)__ 这基本上意味着保持你的系统尽可能地小和简单。简单的系统有着更少的bugs并且更容易理解它们的行为。如果你不理解你系统的行为，你就很不可能知道他是否达成了它的安全目标。
* __失败安全的默认项(Fails-safe defaults)__ 默认项倾向是安全而不是不安全的。如果策略可以设置为决定系统的行为，那么默认项应该是让这些策略更加安全，而不是更不安全。
* __完全调节(complete mediation)__ 这是一个安全词语，它意味着每一次采取一个动作你都应该检查这个被执行的动作是否遇到了安全策略[<sup id="content3">3</sup>](#3)。
* __开放设计(open design)__ 应该假设你的敌人知道你设计的每一个细节。如果系统还是可以达成它的安全性，你就在一个好的状态中。这个原则不是必须意味着你真的要告诉所有人所有细节，而是以假设攻击者已经知道所有事情为基础构建你的安全性。实际上，攻击者通常是知道所有事情。
* __权限分离(separation of privilege)__ 要求分离组织或者证书执行关键动作。例如，双重因子验证(two-factor authentication)，你要是用密码和拥有的硬件标识唯一身份，这笔只单独这些方法中使用任意一个更加安全。
* __最小权限(least privilege)__ 给一个用户或者进程为执行动作而请求的你希望允许的最小权限。你给予一个组织越多权限，他们滥用那些权限的危险就越大。尽管你对这些不是恶意组织很有信息，如果你犯了一个错误，敌人可以利用(leverage)他们的错误，以有害的方式使用它们多余的(superfluous)权限。
* __最小工共机制(least common mechanism)__ 对于不同的用户和进程，使用分离的数据结构或者机制处理它们。例如，在虚拟内存系统中，每个进程都有自己的页表，确保一个进程不会访问到另一个进程的页。
* __可接受性(acceptability)__ 一个很多程序员都不重视的关键属性。如果你的用户不使用它，你的系统就没有价值。太多有希望的安全系统都被抛弃了就是因为它们向用户索取的太多。

这些并不是对于设计安全系统唯一有用的建议。还有很多好的材料是关于下一步的，即将好的设计转换为可以达成你想要的安全性的代码，还有其它材料是关于如何评估你已经构建的系统确实满足了这些目标。这些问题超过了本课程的范围，但是当是你要构建大型，复杂的系统时，这些就极其重要。对于安全编程方法的讨论，如果你使用C语言，你可以从Seacord的论文开始。如果你使用其它语言，你应该查询其它特定于那个语言的类似书记，因为很多安全编码问题都是和语言细节相关的。对于如何评估你的系统是否安全的一个综合方法，可以从Dowd及其合作者的工作开始。

### 53.5 OS安全基础
在一个典型的操作系统中，我们有一些安全目标集合，它们以保密性，完好性和可用性的各个方面为中心。那些目标中有些倾向于构建在操作系统模型中，而剩下的则由系统的用户或者所有者控制。内建的目标应该那些极其常见的，或者是用来确保那些更明确的目标可以实现的目标。内建目标大多数和控制进程访问硬件有关。这是因为，硬件是由系统上所有进程共享的，因此，除非共享被仔细的控制，一个进程可以干涉另一个进程的安全目标。其它内建目标和操作系统提供的服务相关，例如文件系统，内存管理，以及进程间通信。如果这些服务没有被仔细控制，进程就会破坏系统的安全目标。

显然，很多系统安全都和进程处理有关系。如果操作系统可以在进程间维护一个干净的隔离，只有在操作系统的帮助下才能打破，这样，无论是共享的硬件还是操作系统服务都不能用来破坏我们的安全目标。这个需求意味着操作系统需要仔细的允许对硬件和它服务的使用。在很多情况下，操作系统都有很好的机会应用这个谨慎。例如，操作系统控制虚拟内存，进而完全控制了每个进程可以访问的物理内存地址。硬件支持甚至会阻止一个进程给没有映射到进程虚拟内存空间的物理内存地址命名(Hardware support prevents a process from even naming a physical memory address that is not mapped into its virtual memory space)。(我们周围的软件朋友应该记住定期的感谢硬件朋友他们提供供我们使用的伟大事物。)

系统调用给了操作系统另一个机会提供保护。在大多数操作系统中，进程通过一个显式的系统调用访问系统服务，就像我们前面章节讨论过的那样。正如你已经学过的那样，系统调用会切换处理器的执行模式，从用户模式切换到了管理员模式，调用适当的操作系统代码就像它们做的那样。那个代码可以判断哪个进程发起了系统调用以及进程请求的什么服务。之前，我们只讨论了这样是怎样允许操作系统调用合适的系统代码片段执行服务，并持续跟踪，当服务完成后，控制权限应该返回给谁。但是同样的机会给了操作系统机会检查请求的服务在操作系统的安全策略下是否被允许。因为访问外部设备是通过设备驱动，这通常也是通过系统调用访问的，同样的机制可以保证安全策略被很好的应用到硬件访问上。

当一个进程处理一个系统调用，那么，操作系统会在进程控制块或者类似结构中使用进程标识符判断进程的身份。然后OS可以使用 __访问控制机制(access control mechanisms)__ 决定这个被识别的进程是否 __授权(authorized)__ 了执行请求的动作。如果是，OS要么代表进程自己执行这个动作，或者安排进程执行它而不再进一步需要系统介入。如果进程没有被授权，OS可以简单的对系统调用产生一个错误码，并且如果系统调度算允许，返回控制权给这个进程。

### 53.6 总结
操作系统的安全对于系统本身和它应用的利益都至关重要。在这个软件中安全失败了导致本质上不受限的糟糕结果。而达成系统安全很有挑战，已知的设计原则可以提供帮助。这些原则不仅仅在设计操作系统中很有用，在设计任何大规模系统中也是这样。

完成操作系统的安全依赖于操作系统有的安全目标。这些目标典型的包含和保密性，完好性以及可用性相关的目标。在任何给定的系统中，这些安全目标更详细的细节各不相同，这意味着不同系统会有不同安全策略，旨在帮助各个系统实现其特定安全目标。

下一个需要解决的问题的是，我们的操作系统应该提供什么样的机制来帮助我们支持通用安全策略?进程和内存的虚拟化是一个有用的机制，因为它允许我们控制进程的行为到一个很大的范围。我们将在后面的章节中描述几个其它有用的操作系统安全机制。就像在操作系统设计的其它领域中，我们处理那些多样的需求是通过从用来实现所有系统策略的通用机制中分离出由任意特定系统使用的具体策略。(As in other areas of operating system design,wh handle these varying needs by separating the specific policies used by any particular system from the genernal mechanisms used to implement the policies for all systems.)

[<sup id="1">1</sup>](#content1) 如果你不能理解，你需要大量的重读。大量的。
[<sup id="2">2</sup>](#content2) 如果你怀疑你的操作系统是恶意的，是时候换一个操作系统了。
[<sup id="3">3</sup>](#content3) 这个特殊的原则经常在很多系统中被遗忘，这有利于低负载或者可用性。所有工程设计的最高特性是你常常必须平衡冲突的目标，正如我们在这个课程前面看到的，例如调度那一章。我们在后面安全相关的内容中还会更多的讨论它。