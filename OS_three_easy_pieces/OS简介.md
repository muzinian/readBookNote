# 操作系统简介

当一个程序运行时，发生了什么？

一个正在运行的程序只做一个很简单的事：执行指令。数百万(甚至十亿)次每秒，处理器从内存取出指令，解码，执行。处理器按照这样的方式周而复始的运行，直到程序完成[<sup id="content1">1</sup>](#1)。

就这样，我们刚刚描述了计算的冯诺依曼模型[<sup id="content2">2</sup>](#2)。听起来时不时很简单？但是，在这门课里，我们将学习到，当一个程序运行时，为了让系统更加易用，还有其他的事情同时在进行。

事实上，软件是有载体的，这个载体负责让程序易于运行(甚至允许在同一段时间里让你看起来是在运行多个程序)，它允许程序共享内存，确保程序可以和硬件交互等等。这个载体就叫做操作系统[<sup id="content3">3</sup>](#3)，他负责使系统以一种易用的方式正确且高效地运行。

>#### 问题的症结:<br />如何虚拟化资源
>我们将在本书回答的一个主要问题：操作系统是作何虚拟化资源的？这个问题问很简单，但是是我们问题的关键。OS为何要这样做不是主要问题，答案很显然：它使系统更易用。因此，我们专注于如何虚拟化：OS为了达到虚拟化资源，需要实现什么策略和机制？OS如何做才能高效？硬件需要提供什么支持？

操作系统主要通过一种称为虚拟化的通用技术完成这些任务。也就是说，OS把物理资源(比如处理器，内存，硬盘等)转换成一个更通用，更强大和更易于使用的虚拟形式。因此，我们有时说OS是一个虚拟机。

当然，为了允许用户指示OS干活并利用这个虚拟机的功能(例如运行一个程序，分配内存，或者访问文件)，OS也会提供一些接口(API)供你调用。事实上，一个典型的OS会暴露数百个可用的系统调用(system calls)给应用。由于OS提供了这些系统调用来运行程序，访问内存和设备，以及其它相关的操作，我们也说OS提供了标准库给应用。

最后，因为虚拟化允许多个程序运行(因此共享了CPU)，多个程序并发访问它们自己的指令和数据(因此共享了内存)，多个程序访问设备(因此共享了硬盘和其它设备)，OS也被称为资源管理器。每个CPU，内存和硬盘对于系统来说都是一个资源；因此，以或高效，或公平，或者其它可能的目标来管理资源是OS的一个任务。为了更好的理解这一角色，让我们看一些例子
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"
int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "usage: cpu <string>\n");
        exit(1);
        }
    char *str = argv[1];
    while (1) {
        Spin(1);
        printf("%s\n", str);
    }
    return 0;
}
```
### 虚拟CPU
这是本书的第一个例子，他没做什么工作，事实上，它所做的全部就是调用 ```Spin()``` ，这个函数重复的检查时间，每运行一秒钟，就返回一次。然后，它打印出来用户通过命令行传入的字符串，然后继续上面的流程。

保存上述文件为 cpu.c，在一个单处理器(或者是叫做单CPU)的系统上编译运行。
```bash
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
ˆC
prompt>
```
没多大意思，系统开始运行这个程序，重复的检查时间知道消逝掉一秒。一旦一秒过去了，代码就会打印用户传入的字符串(就是 A 字母)，然后继续。记住，这个程序会一直运行下去，只有按了`Ctrl+c`(在基于 UNIX 的系统上会终止运行在前台的程序)才能停止程序。

现在，我们运行这个程序的多个实例。下面的例子显示了这个显然更复杂的例子。
```bash
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
```
现在看起来就有点意思了。尽管我们只有一个处理器，但是着四个程序看起来像是在同一时间运行的。这是如何发生的呢？[<sup id="content4">4</sup>](#4)。

事实上，在硬件的帮助下，操作系统负责表现一种幻象，即系统拥有大量的虚拟CPU。把单个CPU(或者几个CPU)转变成看起来似乎是无线个数的CPU，从而允许多个程序看起来是在同时运行的技术，我们称之为虚拟化CPU。这是本书第一部分的关注点。

当然，起停程序，或者告诉OS运行哪个程序，需要一些接口(API)让你可以跟OS通讯。本书，我们会讨论这些API，事实上，这些API是跟OS交互的主要方式。

你可能会发现，同时运行多个程序会引发各种新问题。例如，如果两个程序想要在一个特定的时间运行，哪个应该运行呢？这个是有OS的策略来决定的，操作系统中会在很多不同的地方使用这些策略来决定上面的问题，因此，我们将通过学习它们，来了解操作系统实现的基本机制(比如同时运行多个程序的能力)。因此，OS也扮演了资源管理器的角色。
```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"
int main(int argc, char *argv[])
{
    int *p = malloc(sizeof(int)); // a1
    assert(p != NULL);
    printf("(%d) memory address of p: %08x\n",getpid(), (unsigned) p); // a2
    *p = 0; // a3
    while (1) 
    {
        Spin(1);
        *p = *p + 1;
        printf("(%d) p: %d\n", getpid(), *p); // a4
    }
    return 0;
}
```
### 虚拟内存
现在，让我们考虑下内存。现代机器的内存模型很简单。他仅仅是字节的数组，读取内存时，我们必须指定一个地址才能访问存在那里的数据；写或者更新内存时，我们必须也要指定数据可以写的地址。

当程序在运行时，访存操作一直都在发生。一个程序会让它的所有数据结构都保存在内存中，通过各种指令访问它们，比如加载(loads)或者存取(stores)，或者其它明确的指令来访问内存以完成工作。不要忘了，每个程序的指令也都是存在内存中的；每次次指令获取时都会访问这些内存。

我们看看上面的程序通过`malloc()`来分配内存。代码的输出如下：
```
prompt> ./mem
(2134) memory address of p: 00200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
ˆC
```
这个程序做了如下的事：第一，它在 a1 行分配了内存，然后，它在 a2 行打印了内存的地址，第三步，在 a3 行把数字0放在了新分配的内存的第一个 slot 里面，最后，每秒一次地更新地址```p```存的值。每次打印状态时，它也同时打印了运行中程序的进程标识符(process identifier PID)。PID对于每个运行的进程都是唯一的。

第一个结果没有多大意思。新分配的内存地址是00200000。随着程序的运行，它缓慢的更新值，并打印结果。现在，让我们再一次运行同一个程序多个实例来看看会发生什么。我们发现，每个运行的程序都把地址分配到了同一个地方(00200000)，然后看起来每次都是独立更新位于00200000的值。这好像每个运行中的程序有自己的私有内存，和不是和其他程序共享同一个物理内存[<sup id="content5">5</sup>](#5)。

事实上，这是因为OS正在虚拟化内存，才产生上述结果。每个进程访问它们各自拥有的私有虚拟地址空间(virtual address space)(有时就叫做地址空间),OS使用某种方法将其映射到机器的物理内存上。一个运行的程序所涉及的内存不会干扰到其它程序的地址空间(或者OS本身)；就运行的程序而言，他认为他拥有全部的内存。然而，现实是，物理内存是共享资源，被OS管理。关于这一切是如何实现的也是本书第一部分的主题，在虚拟化那里会讨论。
### 并发
本书另一个主要的主题是并发。我们使用这个概念术语来指代当一个程序中同时(例如，并发地)执行多个任务时引发的，必须要被定位的所有问题。操作系统本身内部就会出现并发问题，你可以在上面的虚拟化中看到例子，OS要同时处理很多事情，第一个时运行一个程序，然后另外一个等等。事实证明，这会导致一些深刻且有趣的问题。
```c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

volatile int counter = 0;
int loops;

void *worker(void *arg) 
{
    int i;
    for (i = 0; i < loops; i++) 
    {
        counter++;
        }
    return NULL;
}

 int main(int argc, char *argv[])
 {
     if (argc != 2)
      {
          fprintf(stderr, "usage: threads <value>\n");
          exit(1);
       }
       loops = atoi(argv[1]);
       pthread_t p1, p2;
       printf("Initial value : %d\n", counter);
       Pthread_create(&p1, NULL, worker, NULL);
       Pthread_create(&p2, NULL, worker, NULL);
       Pthread_join(p1, NULL);
       Pthread_join(p2, NULL);
       printf("Final value : %d\n", counter);
       return 0;
 }
```
不幸的是，并发的问题不仅仅只限于 OS 本身。事实上，现代多线程程序也表现了同样的问题。上面的程序演示了一个多线程例子。
尽管你可能现在还不能理解完全理解这个例子(我们会在后面的章节了解更多，在并发那一节中)，例子的基本原理还是很简单的。主程序通过`Pthread_create()`[<sup id="content6">6</sup>](#6) 创建了两个线程。你可以认为一个线程就是一个函数运行在和其它函数一样的内存空间，一次它们中不只一个是活跃的。在这个例子中，每个线程开始运行一个叫做worker()的例程(routine)，这个例程简单的循环`loops`次对一个计数器加一。下面是当我们设置变量`loops`的值为1000时，运行的结果。`loops`的值决定了这两个工作进程中的每一个再一个循环中将会对共享的计数器执行多少次加一操作。当程序的`loops`值以1000来运行，你期望的 counter 的最总结果是多少？
```Shell
prompt> gcc -o thread thread.c -Wall -pthread
prompt> ./thread 1000
Initial value : 0
Final value : 2000
```
>#### 问题的症结:<br />如何构建正确的并发程序
>当有多个在同一个内存空间并发执行的宪政，我们如果构建一个可以正确工作的程序？OS需要提供什么原语？硬件需要提供什么机制？我们如何利用它们解决并发的问题？

你可能猜到了，当这两个线程结束了，计数器最终值是2000，因为每个线程对计数器加一了1000次。事实上，当设置`loops`的值为 _N_ 时，我们可能会期望程序最终的输出会是 _2N_。但是事实证明，生活没有那么简单。然我们运行同一样的程序，但是把`loops`的值设置的更高些，让我们看看会发生什么：
```Shell
prompt> ./thread 100000
Initial value : 0
Final value : 143012 // huh??
prompt> ./thread 100000
Initial value : 0
Final value : 137298 // what the??
```
在这次运行中，当我们设置`loops`值为100000时，我们并没有得到200000，在第一次，我们的到了143012，然后，我们在运行一次这个程序，我们不仅仅再一次得到了 _错误_ 的值，还是一个跟上次 _不一样_ 的值。事实上，如果你使用一个很好的`loops`值来一遍又一遍的运行程序，你可能发现有时候你会得到正确的答案，为什么会发生这些事？
事实证明，这些奇怪且不同的输出的原因关系到指令如何执行(一次执行一个)。不幸的是，一个上面程序的一个关键部分是，计数器加一的操作使用了三个指令：一个把计数器的值从内存中取到寄存器中，一个对它加一，一个把它存回到内存中。因为这三个指令没有原子地(一次全都都执行)执行，就导致了奇怪的事情发生。在本书的第二个部分，我们将事无巨细的解决这个并发问题。
### 持久化
```c
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <sys/types.h>
int main(int argc, char *argv[])
{
    int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
    assert(fd > -1);
    int rc = write(fd, "hello world\n", 13);
    assert(rc == 13);
    close(fd);
    return 0;
}
```
这个教程第三个主题是持久化。在系统内存中，数据是易失的，比如 DRAM 以一种可变的方式存值，当掉电或者系统崩溃，内存的任何数据都会丢掉。因此我们需要硬件和软件有能力可以永久的存储数据；因此，对于任何系统，只要用户对数据非常的关心，那么这个存储就是系统的关键。

硬件采用以某种 input/output 或者 I/O 设备的形式构成，在现代系统中，一个硬盘是一个存储持久信息的公共仓库，尽管在这个舞台里，SSD 正在取得进展。

操作系统中用来管理磁盘的软件被叫做文件系统；因此，它的职责就是以一个可靠而有效的方式将用户创建的任何文件存储到系统的磁盘上。

不像OS为 CPU 和内存提供的抽象，OS 没有为每一个程序创建一个私有的，虚拟化的磁盘。相反的，它假设用户想要共享文件里面的信息。
例如，当编写一个 C 程序时，你可能先用一个编辑器(比如 Emacs[<sup id="content7">7</sup>](#7))来创建并编辑 C 文件(`emacs -nw main.c`)。一旦你完成后，你可能使用编译器将源码转换成可执行程序(例如，`gcc -o main main.c`)。当你完成后，你可能运行这个新的可执行文件(例如，`./main`)。因此，你可以看到文件是如何在不同的程序中共享的。第一，Emacs 创建了一个文件，作为编译器的输入；编译器使用这个输入文件来创建一个新的可执行文件(这里有很多步骤，请参阅一个编译器教材以获取详情)；最后，新的执行文件被执行。然后一个新的程序产生了！

>#### 问题的症结:<br />如何持久化存储数据
>文件系统是 OS 负责管理持久化数据的。需要什么技术才能把事情做正确？需要什么机制和策略才能高效的做这些？如何保证可靠性，在面对硬件和软件的错误(failures)时？

为了更好的理解这些，然我们看看代码。上面的代码展现了创建一个包含了 "hello world" 的字符串的文件(/tmp/file)。为了完成这个任务，程序需要使用三个系统调用。第一个：`open()`调用，打开并创建文件；第二个，`write()`，向文件写数据；第三，`close()`，简单的关闭文件，指示程序将不会再向文件里面些任何东西了。这些 __系统调用__ 被路由到 OS 中的叫做 __文件系统__ 的部分，这里会处理这些请求，然后会返回某种错误码给用户。

你可能会在想 OS 为了真正的写到磁盘里做了什么。我们可以告诉你，但是你先做好准备。这个过程很痛苦。文件系统必须要做一点点工作：第一，指出新数据会放在磁盘的哪里，然后在文件系统维护的各种数据结构中保持对它的跟踪。做这些操作需要向底层的存储设备发出 I/O 请求，要么读取已经存在的结构要么更新(写)它们。正如每个写过设备驱动[<sup id="content8">8</sup>](#8)的人知道，让设备代表你做一些事，是一个复杂而繁琐的过程。他要求需要对底层设备接口和它的确切语义有深入的了解。幸运的是，OS 提供了一个标准且简单的方式通过它的系统调用访问设备。这里，OS 有时被看作标准库。

当然，如何访问设备，文件系统如果管理上述设备中持久化的数据，这里面还有很多的细节。基于性能原因，大多数文件系统会首延迟一会儿写操作，希望可以以更大的组来批量处理它们。为了处理在写操作的过程中系统崩溃导致的问题，大多数文件系统会引入某种复杂的写策略，比如日志或者写拷贝(copy-on-write)，仔细的顺序写到磁盘来确保如果在写序列中发生了失败，系统可以恢复到合理的状态。为了确保不同的公共操作高效，文件系统使用了多种数据结构和访问方法，从简单的列表到复杂的 btree。如果这些都还不够过瘾，很好，我们会在本书的第三部分 __持久化__ 中更详尽的讨论这些。在第三部分，我们会概括的讲一下设备和 I/O，然后是磁盘，RAID，然后就是详细的介绍文件系统。
### 设计目标
现在你对操作系统实际上做什么有了概念了：它拿到物理资源，例如 CPU，内存或磁盘，然后虚拟化它们。它会处理跟并发相关的艰难而棘手的问题。它也会持久化存储文件，安全的长时间保存它们。根据这些，我们想要搭建这样的系统，我们需要一些目标来帮助我们设计，实现，必要时做出取舍；构造系统的一个关键点就是找到一个正确的取舍集合。

构建一些 __抽象__ 是这些最基本的目标之一，这些抽象是为了让系统方便并易于使用。在计算机科学中，抽象是我们做的任何事的基础。通过把程序分成一些小的，易于理解的部分，抽象使得编写大型程序成为可能。这样，我们就可以使用类似 C[<sup id='content9'>9</sup>](#9)这样的高层语言来编写这样的程序而不用关心汇编，使用汇编编写程序而不用关心逻辑门电路，使用门电路构建处理器而不用关心晶体管。抽象是如此的基本，以至于我们有时会忘掉它的重要性，但是这里我们不会；因此，在每个部分，我们会讨论那些随着时间已经开发出来的主要抽象，让你通过这个方法考虑 OS 的各个方面。

提供高性能的系统是设计和实现 OS 的一个目标；另一个说法是，我们的目标是最小化 OS 的负载。虚拟化和使系统易用使很值得做的，但不是不计任何代价，因此，我们需要努力提供虚拟化和其它 OS 的功能而不花费太多负载。这些负载可能有各种形式引起：额外的时间(更多的指令)和额外的空间(在内存或着在磁盘中)。我们会尽可能的寻找最小化这些问题的解决方案。完美不会总是可达的，有时，我们需要学会注意并(在合适的地方)容忍问题。

另一个目标是在程序之间提供保护，包括 OS 和程序之间。因为我们希望一个应用的确保恶意或意外的错误行为不会伤害到另外一个；我们肯定不想一个程序有能力伤害到 OS 本身(这样就会伤害到所有运行在这个系统上的应用了)。保护位于操作系统底层的主要原则之一的心脏地位，这个原则就是隔离，进程之间的相互隔离是保护的关键，因此，这成为了一个操作系统必须要做的事。

操作系统必须可以一直运行；当他挂掉了，所有运行在它上面的应用也都挂掉了。有由于这种依赖，操作系统常常要努力提供一个高标准的可靠性。随着操作系统增长的复杂(有时包含上百万行代码)，构建一个可靠的系统成为了一个挑战。事实上，大多数正在进行的研究都是在研究这个确切的问题。

其它目标也是有道理的：能耗对于我们绿色环境是很重要的；对抗恶意应用的安全(保护的扩展)也是很关键的，特别在那些使用网络很多地方，移动化也越来越重要，现在的 OS 运行在越来越小的设备上了。根据系统是如何使用的，OS 有不同的目标，因此也就在实现上至少有些许的不同。然而，就如同我们将要看到的，我们将要呈现的关于如何构建一个 OS 的大多数原理对于各种设备都是有用的。
### 聊聊历史
在结束这个介绍之前，让我们展示一下操作系统是如何发展的。就想任何由人构架的系统，好的理念是随着时间添加到操作系统中的，工程师也在了解到在他们的设计中，什么是重要的。这里，我们讨论几个主要的发展。
#### 早期的操作系统：只是一个库
在最开始，操作系统做的工作不多。基本上，它只是公用的函数库集合；比如，为了避免每个让这个系统的程序员编写底层 I/O 控制代码，这个“OS”可能会提供这些 API，让这些程序员好过些。通常，在一些老式的大型机系统上，一次只能运行一个程序，有一个人类操作员控制。大多数你认为现代 OS 会做的事(例如，以何种顺序决定任务运行) 都由这个操作员来做。如果你是一个聪明的开发者，你就会对这个操作员好点，这样，他们就可能把你的任务放在队列的前段。

这个计算的模式就是所谓的批处理，一些任务本设定然后由操作员再一个批次(batch)里运行。计算机，在这里面，没有被用于可以交互的方式。主要原因是消耗：这很简单，让一个使用者坐在计算机的前面并使用它太贵了而不被允许，因为这会导致大部分时间计算机只是闲置的，每小时花费成百上千的美元。
#### 超越库：保护
为了超越只是公用服务的库，OS 在扮演了一个更中心化的角色来管理机器。这里一个重要的方面是意识到有着 OS 行为的代码是特殊的；它控制着设备，因此就应该需要和其它正常的应用代码区别对待。为什么这样？想象一下，如果你允许其它任何应用可以从磁盘上任一地方读取内容，那么就没有隐私的概念了，因为任一应用都可以读取任一文件。因此，实现一个文件系统(来管理你的文件)作为一个库就有毫无意义了。相反，还需要其它的东西。就这样，系统调用(system call)这一理念就被发明出来了。这是由 Atlas 计算系统倡导的。不把 OS 例程提供为库(以库的形式的话，你就可以通过程序调用(procedure call)来访问文件)，这个理念是通过增加一对特殊的硬件指令和硬件状态来过渡到 OS 这个更正规，可控的进程。系统调用和程序调用的关键不同点在于，系统调用转移控制权(比如，jumps)到 OS 中，同时提升硬件特权等级(__hardware privilege level__)。用户应用程序运行在用户模式(__user mode__)中，这意味着硬件限制应用可以做什么；比如典型地，一个运行在用户模式的程序不可以创建到磁盘的 I/O 请求。当一个系统调用被创建了(通常是使用一个一个特别的硬件指令 __trap__)，硬件就转移控制权到一个预定义的 __trap handler__(操作系统提前设置的)同时提升特权等级到内核模式(__kernel mode__)。OS 可以完全访问系统的硬件，因此就可以做例如初始化一个 I/O 请求或者分配更多的内存给程序。当 OS 完成了一个这个请求，就会通过一个特殊的 __return-from-trap__ 指令把控制权返回给用户，这就会反转回用户模式，同时在应用交出控制权的地方把控制权返回给应用。
#### 多程序时代
操作系统真正起飞的时代是小型机时代。典型的机器，比如来自 Digital Equipment 的 PDP 系列让计算机可以被负担的起了。不想大型机，每个大型组织只能有一台，现在一个组织里的一小群人就可以有他们自己的计算机了。无疑，价格的下降激发了开发者的活力；越来越多的聪明人开始通过计算机做一些有趣且漂亮的事了。

特别的，由于对更好的利用机器资源的渴望，多程序变成了司空见惯的事。不在一次只运行一个任务，OS 开始加载多个任务到内存中，并且快速的切换他们，以提升 CPU 的利用率。这种切换特别重要，因为 I/O 设备很慢，让一个 I/O 这在处理的程序呆在 CPU 里是对 CPU 时间的浪费。相反的，为何不切换到另外的程序并运行呢？

支持多道程序和交替的出现 I/O 和中断迫使 OS 的开发理念沿着多个的道路取得了革新。解决内存保护变得重要了，我们不希望有可能访问其它程序的内存。理解如何处理由于多道程序导致的并发问题也很关键；确保尽管有中断存在 OS 的行为也是正确的变成了一个伟大的挑战。我门将在本书后面将会学习这些问题和相关的主题。

在这一时期，另一个实际进展是出现了 UNIX 系统，这主要感谢贝尔实验室的 Ken Thompson (和Dennis Ritchie)。UNIX 从各种不同的操作系统(特别是 Multics，有些来自 TENEX 和 Berkely Time-sharing System)获取了很多好的理念。同时他让这些变得更简单和好用。很快，这个团队提供了包含 UNIX 源代码的磁带给全世界的人。很多人都获取了代码，并在其中加入到了自己的系统，细节参见旁注[<sup id="content10">10</sup>](#10)
#### 现代
迈过小型机，一种对于大众来说更便宜，更快机器出现了：个人电脑，也叫做 PC。由 Apple 的早期机器(例如，APPLE II)和 IBM PC 开创，新机器很快就成为计算领域的优势力量，随着他们低价，使得每个人都可以拥有一台。不幸的是，对于操作系统，PC 在一开始可谓是向后退了一大步。早期的系统忘记了(或者说从未知道)小型机时代的教训。比如，早期的系统，如来自微软的 DOS(DISK Operating System)就不认为内存保护很重要，因此，一个恶意程序(或者可能只是一个写的很差的程序)可能修改所有的内存。第一代的 Mac OS(v9及以前)采用合作式的方式来做任务调度；这样，一个线程突然陷入到了无限循环中就可能拖垮这个系统导致重启。例子还有很多，就不讨论了。幸运的是，在忍受了这么多年，小型机系统的旧功能开始找到了进入桌面的方法。例如，Mac OS X 使用 UNIX 作为它的内核，包括了所有希望来自这个成熟系统的功能。Windows 类似的适应了计算机历史中伟大理念，特别的以 Windows NT 开始，微软 OS 技术向前迈了一大步。甚至是现在的运行在手机的操作系统（比如 Linux）也更像70年代的小型机而不是80年代的 PC。很高兴能够看到在 OS 发展的全盛时期的好的理念能够在现代世界找到出路。更好的是，这些里面还在持续的发展，提供更多的功能，让现代系统对用户和应用更友好。
>#### 旁注:UNIX 的重要性
>夸大操作系统历史中 UNIX 的重要性是很难的。受到早期系统的影响(特别的，来自 MIT 著名的 Multics 系统)，UNIX 带来了很多伟大的理念，并且让一个系统既简单有强大。以原来的贝尔实验室为基础，UNIX 是一个统一的原则，这个原则内容是：通过构建小而强大的程序，这些程序可以彼此互联，进而形成更大的工作流。__shell__（你可以输入命令的地方）提供了如 __pipes__这样的原语，你可以实现 meta-level 编程，这样，通过把程序连接在一起就可以很容易形成一个大的任务。比如，为了找到文件中包含有 "foo" 这个单词的行，然后统计有多少个行存在，你可以输入：`grep foo file.txt|wc -l`，通过使用`grep`和`wc`(word count)程序来完成你的任务。UNIX 环境对于程序员和或者类似的开发者很友好，也提供了 C 语言的编译器。这就让程序员很方便的编写自己的程序，分享它们，让 UNIX 更加流行。它的作者通过免费给任何想要程序的人代码拷贝提供了很多帮助，是一个早期的开源软件组织。
>
>代码的可读和可访问性也是关键的重要性。有一个使用 C 语言编写小而美的内核也邀请了其它一起来晚内核，给它添加新奇有趣的功能。例如，由 Bill Joy 领导的位于伯克利的有进取心的组织，制作了一个精彩的发行版(BSD,Berkeley System Distribution)，它包含先进的虚拟内存，文件系统和网络子系统。Joy 不久就成为了 Sun 公司的联合创始人。
>
>不幸的是，由于各个公司的希望声明所有权和从 UNIX 获利，UNIX 的传播速度下降了。最后，一个不幸(但常见的)结果就是律师介入了。很多公司都由它们自己的版本：SunOS 来自 Sun，AIX 来自 IBM，HPUX(a.k.a. "H-Pucks")来自 HP，IRIX 来自 SGI。来自 AT&T/贝尔实验室和其他玩家的法律争吵给 UNIX 带来了阴霾，很多人都想知道它是否还能生存，特别是 Windows 的抢占了大多数的 PC 市场。。。

>#### 旁注:LINUX的到来
>对于 UNIX 来说，幸运的是，一个来自芬兰叫做 __Linus Torvalds__ 的年起黑客决定编写自己的 UNIX 版本，它强烈的借鉴了原始版本的原则和理念，但是不是来自于代码基，这就避免了法律问题。他获得了来自世界的帮助，很快 Linux 就诞生了(同时，现代开源软件运动也开始了)。
>随着互联网时代的到来，大多数公司(比如 Google,Amazon,Fackbook 和其他)选择运行Linux，因为它是免费的，而且也很容易阅读修改以适合它们的需求，事实上，如果没有Linux，很难想象那些新兴公司会成功。随着智能手机变成了主要的面向用户的平台，Linux 同样找到了据点(通过 Android)，这也是多是因为同样的原因。 Steve Jobs 带着它自己的基于 UNIX 的操作环境 NeXTStep 回到了苹果，让 UNIX 在桌面系统流行起来(尽管大多数 Apple 技术的用户可能没有意识到这个事实)。因此 UNIX 还活着，还变得比以往更加重要。如果你相信计算之神，你应该感谢这个精彩的成果。 

### 总结
我们已经介绍完了 OS。今天的操作系统让系统相对的易于使用，实际上，我们将在本书讨论的 OS 的发展，影响了你今天使用的所有操作系统。不幸的是，由于时间的限制，OS 的一些部分我们不会在本书覆盖到。比如，在操作系统中有很多网络(networking)相关的代码，我们把它留到你的网络课上去学习；同样也包括图形学。最后，安全也是很重要的一部分，我们会讨论 OS 必须要提供的运行中程序之间的保护措施和给用户保护它们文件安全的能力，但是我们不会涉及到那些应该在安全课程中讨论的安全问题。然而， 这里仍然有很多重要的主题！

<sup id="1">1</sup>当然，现代操作系统在内部会使用很多奇技淫巧让程序运行的更快，比如，一次执行多个指令，甚至对指令做重排序。但是在此我们不关心这个，我们只关心大多数程序假设的简单模型：一次按照顺序次序地执行一条指令[&crarr;](#content1)。

<sup id="2">2</sup>冯诺依曼使计算系统先驱，也是博弈论和原子弹的先驱[&crarr;](#content2)。

<sup id="3">3</sup>OS早期的名字还有监管程序或主控程序。显然，后者听前来过于热心(参见电影Tron)，感谢使用了操作系统来代替[&crarr;](#content3)。

<sup id="4">4</sup>注意我们是如何通过使用 & 符号一次执行四个进程的。在`tcsh` shell 中这样做可以在后台运行一个 job，这意味着用户可以立刻执行下一个命令，在这个例子中，就是运行另一个程序。这里，在`tcsh` shell 中，每个命令之间的分号允许我们同时运行多个程序，如果你使用了不同的 shell (比如 bash),它们的工作方式有些许不同，详情查看在线文档[&crarr;](#content4)。

<sup id="5">5</sup>要运行这个例子，你需要确保地址空间随机化不可用；随机化，就像它的名字那样，可以有效的防御某些安全缺陷。请自行查阅相关自来哦，特别是如果你想知道如何通过堆栈攻陷计算机系统。记住，我们只是建议这个事。。。。。[&crarr;](#content5)。

<sup id="6">6</sup>实际的调用应该是小写的`pthread_create()`;大写的版本是我们的包装版本，它调用了`pthread_create()`并返回值来标识调用成功了，详见代码(在路径G:\study\source\os three easy peices\preface\code.intro中)[&crarr;](#content6)。

<sup id="7">7</sup>你应该使用 Emacs。如果你使用 vi，那么你可能错了。如果你正在使用那些甚至都不是一个真正的代码编辑器，就更糟了[&crarr;](#content7)。

<sup id="8">8</sup>设备驱动就是操作系统中知道如何处理特定设备的代码，我们将在后面更多的讨论设备和设备驱动[&crarr;](#content8)。

<sup id="9">9</sup>你可能反对把 C 叫做高层语言，记住，这是一个 OS 教材，因此，我们很高兴可以不用一直使用汇编编写代码[&crarr;](#content9)。

<sup id="10">10</sup>我们使用旁注和其他类似的文本框来处理那些不太适合本文主线内容的条目。有时候我们也使用这些旁注或文本框来将讲笑话[&crarr;](#content10)。